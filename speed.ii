namespace std
{
typedef long unsigned int size_t;
typedef long int ptrdiff_t;
}
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef long int __off_t;
typedef long int __off64_t;
typedef struct
{
} __fsid_t;
typedef long int __clock_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef char *__caddr_t;
namespace std __attribute__ ((__visibility__ ("default")))
{
  struct __true_type
  {
  };
  struct __false_type
  {
  };
  template <typename, typename> struct __are_same
  {
    enum
    {
      __value = 0
    };
    typedef __false_type __type;
  };
  template <typename _Tp> struct __is_integer
  {
    enum
    {
      __value = 0
    };
    typedef __false_type __type;
  };
  template <typename _Tp> struct __is_char
  {
    enum
    {
      __value = 0
    };
    typedef __false_type __type;
  };
  template <> struct __is_char<char>
  {
    enum
    {
      __value = 1
    };
    typedef __true_type __type;
  };
}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
  template <bool, typename> struct __enable_if
  {
  };
  template <typename _Tp> struct __enable_if<true, _Tp>
  {
    typedef _Tp __type;
  };
  template <bool _Cond, typename _Iftrue, typename _Iffalse>
  struct __conditional_type
  {
    typedef _Iftrue __type;
  };
  template <typename _Tp> struct __add_unsigned
  {
  private:
    typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

  public:
    typedef typename __if_type::__type __type;
  };
}
extern "C" {
extern double pow (double __x, double __y) throw ();
}
namespace std __attribute__ ((__visibility__ ("default"))) { using ::pow; }
extern "C" {
typedef long unsigned int size_t;
typedef int pthread_once_t;
typedef struct _IO_FILE FILE;
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
typedef struct
{
} _G_fpos64_t;
extern struct _IO_FILE *stderr;
extern int fprintf (FILE *__restrict __stream, const char *__restrict __format,
                    ...);
extern "C" {
typedef __u_char u_char;
typedef __clock_t clock_t;
typedef __time_t time_t;
}
extern time_t time (time_t *__timer) throw ();
}
namespace std
{
using ::time;
template <typename _Tp>
inline _Tp *
__addressof (_Tp &__r)
{
  return reinterpret_cast<_Tp *> (
      &const_cast<char &> (reinterpret_cast<const volatile char &> (__r)));
}
template <typename _Tp>
inline void
swap (_Tp &__a, _Tp &__b)
{
  _Tp __tmp = (__a);
  __a = (__b);
  __b = (__tmp);
}
template <class _T1, class _T2> struct pair
{
  typedef _T1 first_type;
  typedef _T2 second_type;
  _T1 first;
  _T2 second;
  pair () : first (), second () {}
  pair (const _T1 &__a, const _T2 &__b) : first (__a), second (__b) {}
  template <class _U1, class _U2>
  pair (const pair<_U1, _U2> &__p)
      : first (__p.first), second (__p.second)
  {
  }
};
template <class _T1, class _T2>
inline pair<_T1, _T2>
make_pair (_T1 __x, _T2 __y)
{
  return pair<_T1, _T2> (__x, __y);
}
void __throw_bad_alloc (void) __attribute__ ((__noreturn__));
void __throw_logic_error (const char *) __attribute__ ((__noreturn__));
void __throw_length_error (const char *) __attribute__ ((__noreturn__));
void __throw_out_of_range (const char *) __attribute__ ((__noreturn__));
}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
  template <typename _Value> struct __numeric_traits_integer
  {
    static const _Value __min
        = (((_Value)(-1) < 0)
               ? (_Value)1 << (sizeof (_Value) * 8 - ((_Value)(-1) < 0))
               : (_Value)0);
    static const _Value __max
        = (((_Value)(-1) < 0)
               ? (((((_Value)1
                     << ((sizeof (_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1)
                   << 1) + 1)
               : ~(_Value)0);
  };
  template <typename _Value> struct __numeric_traits_floating
  {
  };
  template <typename _Value>
  struct __numeric_traits
      : public __conditional_type<std::__is_integer<_Value>::__value,
                                  __numeric_traits_integer<_Value>,
                                  __numeric_traits_floating<_Value> >::__type
  {
  };
}
namespace std __attribute__ ((__visibility__ ("default")))
{
  struct input_iterator_tag
  {
  };
  struct forward_iterator_tag : public input_iterator_tag
  {
  };
  struct bidirectional_iterator_tag : public forward_iterator_tag
  {
  };
  struct random_access_iterator_tag : public bidirectional_iterator_tag
  {
  };
  template <typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
            typename _Pointer = _Tp *, typename _Reference = _Tp &>
  struct iterator
  {
    typedef _Category iterator_category;
    typedef _Tp value_type;
    typedef _Reference reference;
  };
  template <typename _Iterator> struct iterator_traits
  {
    typedef typename _Iterator::iterator_category iterator_category;
    typedef typename _Iterator::value_type value_type;
    typedef typename _Iterator::difference_type difference_type;
    typedef typename _Iterator::pointer pointer;
    typedef typename _Iterator::reference reference;
  };
  template <typename _Tp> struct iterator_traits<_Tp *>
  {
    typedef random_access_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp *pointer;
    typedef _Tp &reference;
  };
  template <typename _Iter>
  inline typename iterator_traits<_Iter>::iterator_category
  __iterator_category (const _Iter &)
  {
    return typename iterator_traits<_Iter>::iterator_category ();
  }
  template <typename _InputIterator>
  inline typename iterator_traits<_InputIterator>::difference_type __distance (
      _InputIterator __first, _InputIterator __last, input_iterator_tag)
  {
    typename iterator_traits<_InputIterator>::difference_type __n = 0;
    while (__first != __last)
      {
        ++__first;
        ++__n;
      }
    return __n;
  }
  template <typename _InputIterator>
  inline typename iterator_traits<_InputIterator>::difference_type distance (
      _InputIterator __first, _InputIterator __last)
  {
    return std::__distance (__first, __last,
                            std::__iterator_category (__first));
  }
  template <typename _BidirectionalIterator, typename _Distance>
  inline void __advance (_BidirectionalIterator & __i, _Distance __n,
                         bidirectional_iterator_tag)
  {
  }
  template <typename _InputIterator, typename _Distance>
  inline void advance (_InputIterator & __i, _Distance __n)
  {
  }
  template <typename _Iterator>
  class reverse_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
  {
  protected:
    _Iterator current;
    typedef iterator_traits<_Iterator> __traits_type;

  public:
    typedef _Iterator iterator_type;
    typedef typename __traits_type::difference_type difference_type;
    typedef typename __traits_type::pointer pointer;
    typedef typename __traits_type::reference reference;
    explicit reverse_iterator (iterator_type __x) : current (__x) {}
    reverse_iterator (const reverse_iterator &__x) : current (__x.current) {}
    iterator_type
    base () const
    {
      return current;
    }
    reference operator*() const
    {
      _Iterator __tmp = current;
      return *--__tmp;
    }
    reverse_iterator &operator++()
    {
      --current;
      return *this;
    }
    reverse_iterator &operator--()
    {
      ++current;
      return *this;
    }
  };
  template <typename _Iterator>
  inline bool operator==(const reverse_iterator<_Iterator> &__x,
                         const reverse_iterator<_Iterator> &__y)
  {
    return __x.base () == __y.base ();
  }
  template <typename _Iterator>
  inline bool operator!=(const reverse_iterator<_Iterator> &__x,
                         const reverse_iterator<_Iterator> &__y)
  {
    return !(__x == __y);
  }
}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
  using std::iterator_traits;
  template <typename _Iterator, typename _Container> class __normal_iterator
  {
  protected:
    _Iterator _M_current;
    typedef iterator_traits<_Iterator> __traits_type;

  public:
    typedef _Iterator iterator_type;
    typedef typename __traits_type::difference_type difference_type;
    typedef typename __traits_type::reference reference;
    typedef typename __traits_type::pointer pointer;
    explicit __normal_iterator (const _Iterator &__i) : _M_current (__i) {}
    reference operator*() const { return *_M_current; }
    __normal_iterator &operator++()
    {
      ++_M_current;
      return *this;
    }
    const _Iterator &
    base () const
    {
      return _M_current;
    }
  };
  template <typename _Iterator, typename _Container>
  inline bool operator!=(const __normal_iterator<_Iterator, _Container> &__lhs,
                         const __normal_iterator<_Iterator, _Container> &__rhs)
  {
    return __lhs.base () != __rhs.base ();
  }
}
namespace std __attribute__ ((__visibility__ ("default")))
{
  template <typename _Tp>
  inline const _Tp &min (const _Tp &__a, const _Tp &__b)
  {
    if (__b < __a)
      return __b;
    return __a;
  }
}
extern "C++" {
namespace std
{
class exception
{
public:
  exception () throw () {}
  virtual ~exception () throw ();
  virtual const char *what () const throw ();
};
class bad_exception : public exception
{
public:
  ;
  ;
};
;
}
inline void *operator new(std::size_t, void *__p) throw () { return __p; }
}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
  using std::ptrdiff_t;
  template <typename _Tp> class new_allocator
  {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp *pointer;
    typedef const _Tp *const_pointer;
    pointer
    allocate (size_type __n, const void * = 0)
    {
      if (__n > this->max_size ())
        std::__throw_bad_alloc ();
      return static_cast<_Tp *> (::operator new(__n * sizeof (_Tp)));
    }
    void
    deallocate (pointer __p, size_type)
    {
      ::operator delete(__p);
    }
    size_type
    max_size () const throw ()
    {
      return size_t (-1) / sizeof (_Tp);
    }
    void
    construct (pointer __p, const _Tp &__val)
    {
      ::new ((void *)__p) _Tp (__val);
    }
    void
    destroy (pointer __p)
    {
      __p->~_Tp ();
    }
  };
}
namespace std __attribute__ ((__visibility__ ("default")))
{
  template <typename> class allocator;
  template <> class allocator<void>
  {
  public:
    typedef size_t size_type;
    typedef const void *const_pointer;
    typedef void value_type;
    template <typename _Tp1> struct rebind
    {
      typedef allocator<_Tp1> other;
    };
  };
  template <typename _Tp>
  class allocator : public __gnu_cxx::new_allocator<_Tp>
  {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp *pointer;
    typedef const _Tp *const_pointer;
    typedef _Tp &reference;
    typedef const _Tp &const_reference;
    typedef _Tp value_type;
    template <typename _Tp1> struct rebind
    {
      typedef allocator<_Tp1> other;
    };
    allocator () throw () {}
    allocator (const allocator &__a) throw ()
        : __gnu_cxx::new_allocator<_Tp> (__a)
    {
    }
    template <typename _Tp1> allocator (const allocator<_Tp1> &) throw () {}
    ~allocator () throw () {}
  };
}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
  template <typename _Alloc> struct __alloc_traits
  {
    typedef _Alloc allocator_type;
    typedef typename _Alloc::pointer pointer;
    typedef typename _Alloc::const_pointer const_pointer;
    typedef typename _Alloc::value_type value_type;
    typedef typename _Alloc::reference reference;
    typedef typename _Alloc::const_reference const_reference;
    typedef typename _Alloc::size_type size_type;
    typedef typename _Alloc::difference_type difference_type;
    static pointer
    allocate (_Alloc &__a, size_type __n)
    {
      return __a.allocate (__n);
    }
    static void
    deallocate (_Alloc &__a, pointer __p, size_type __n)
    {
      __a.deallocate (__p, __n);
    }
    static const _Alloc &
    _S_select_on_copy (const _Alloc &__a)
    {
      return __a;
    }
    template <typename _Tp> struct rebind
    {
      typedef typename _Alloc::template rebind<_Tp>::other other;
    };
  };
}
namespace std __attribute__ ((__visibility__ ("default")))
{
  template <class _CharT> struct char_traits;
  template <typename _CharT, typename _Traits = char_traits<_CharT>,
            typename _Alloc = allocator<_CharT> >
  class basic_string;
  typedef basic_string<char> string;
  typedef basic_string<wchar_t> wstring;
}
typedef __mbstate_t mbstate_t;
namespace std
{
typedef long streamoff;
typedef ptrdiff_t streamsize;
template <typename _StateT> class fpos
{
  ;
};
typedef fpos<mbstate_t> streampos;
template <> struct char_traits<char>
{
  typedef char char_type;
  typedef int int_type;
  typedef streampos pos_type;
  typedef streamoff off_type;
  typedef mbstate_t state_type;
  static void
  assign (char_type &__c1, const char_type &__c2)
  {
    __c1 = __c2;
  }
  static int
  compare (const char_type *__s1, const char_type *__s2, size_t __n)
  {
    return __builtin_memcmp (__s1, __s2, __n);
  }
  static size_t
  length (const char_type *__s)
  {
    return __builtin_strlen (__s);
  }
  static char_type *
  copy (char_type *__s1, const char_type *__s2, size_t __n)
  {
    return static_cast<char_type *> (__builtin_memcpy (__s1, __s2, __n));
  };
  ;
  ;
  ;
  ;
  ;
};
template <typename _CharT, typename _Traits = char_traits<_CharT> >
class basic_ios;
template <typename _CharT, typename _Traits = char_traits<_CharT> >
class basic_streambuf;
template <typename _CharT, typename _Traits = char_traits<_CharT> >
class basic_istream;
template <typename _CharT, typename _Traits = char_traits<_CharT> >
class basic_ostream;
template <typename _CharT, typename _Traits = char_traits<_CharT>,
          typename _Alloc = allocator<_CharT> >
class basic_ostringstream;
template <typename _CharT, typename _Traits = char_traits<_CharT> >
class istreambuf_iterator;
template <typename _CharT, typename _Traits = char_traits<_CharT> >
class ostreambuf_iterator;
typedef basic_ostream<char> ostream;
typedef basic_ostringstream<char> ostringstream;
template <typename _CharT> class ctype;
template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
class num_get;
template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
class num_put;
template <typename _Arg, typename _Result> struct unary_function
{
  typedef _Arg argument_type;
  typedef _Result result_type;
};
template <typename _Arg1, typename _Arg2, typename _Result>
struct binary_function
{
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
};
template <typename _Tp>
struct equal_to : public binary_function<_Tp, _Tp, bool>
{
  ;
};
template <typename _Tp> struct less : public binary_function<_Tp, _Tp, bool>
{
  bool operator()(const _Tp &__x, const _Tp &__y) const { return __x < __y; }
};
template <typename _Tp> struct _Identity : public unary_function<_Tp, _Tp>
{
  ;
  ;
};
template <typename _Pair>
struct _Select1st : public unary_function<_Pair, typename _Pair::first_type>
{
  const typename _Pair::first_type &operator()(const _Pair &__x) const
  {
    return __x.first;
  }
};
}
typedef pthread_once_t __gthread_once_t;
static inline int
__gthread_active_p (void)
{
}
typedef int _Atomic_word;
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
  static inline _Atomic_word __exchange_and_add (volatile _Atomic_word * __mem,
                                                 int __val)
  {
    return __atomic_fetch_add (__mem, __val, 4);
  }
  static inline void __atomic_add (volatile _Atomic_word * __mem, int __val)
  {
    __atomic_fetch_add (__mem, __val, 4);
  }
  static inline _Atomic_word __exchange_and_add_single (_Atomic_word * __mem,
                                                        int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }
  static inline void __atomic_add_single (_Atomic_word * __mem, int __val)
  {
    *__mem += __val;
  }
  static inline _Atomic_word __attribute__ ((__unused__))
  __exchange_and_add_dispatch (_Atomic_word * __mem, int __val)
  {
    if (__gthread_active_p ())
      return __exchange_and_add (__mem, __val);
    else
      return __exchange_and_add_single (__mem, __val);
  }
  static inline void __attribute__ ((__unused__))
  __atomic_add_dispatch (_Atomic_word * __mem, int __val)
  {
    if (__gthread_active_p ())
      __atomic_add (__mem, __val);
    else
      __atomic_add_single (__mem, __val);
  }
}
namespace std __attribute__ ((__visibility__ ("default")))
{
  template <typename _CharT, typename _Traits, typename _Alloc>
  class basic_string
  {
    typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;

  public:
    typedef _Traits traits_type;
    typedef typename _Traits::char_type value_type;
    typedef _Alloc allocator_type;
    typedef typename _CharT_alloc_type::size_type size_type;
    typedef typename _CharT_alloc_type::difference_type difference_type;
    typedef typename _CharT_alloc_type::reference reference;
    typedef typename _CharT_alloc_type::const_reference const_reference;
    typedef typename _CharT_alloc_type::pointer pointer;
    typedef typename _CharT_alloc_type::const_pointer const_pointer;
    typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
    typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
        const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;

  private:
    struct _Rep_base
    {
      size_type _M_length;
      size_type _M_capacity;
      _Atomic_word _M_refcount;
    };
    struct _Rep : _Rep_base
    {
      typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
      static const size_type _S_max_size;
      static const _CharT _S_terminal;
      static size_type _S_empty_rep_storage[];
      static _Rep &
      _S_empty_rep ()
      {
        void *__p = reinterpret_cast<void *> (&_S_empty_rep_storage);
        return *reinterpret_cast<_Rep *> (__p);
      }
      bool
      _M_is_leaked () const
      {
        return this->_M_refcount < 0;
      }
      bool
      _M_is_shared () const
      {
        return this->_M_refcount > 0;
      }
      void
      _M_set_sharable ()
      {
        this->_M_refcount = 0;
      }
      void
      _M_set_length_and_sharable (size_type __n)
      {
        if (__builtin_expect (this != &_S_empty_rep (), false))
          {
            this->_M_set_sharable ();
            this->_M_length = __n;
            traits_type::assign (this->_M_refdata ()[__n], _S_terminal);
          }
      }
      _CharT *
      _M_refdata () throw ()
      {
        return reinterpret_cast<_CharT *> (this + 1);
      }
      _CharT *
      _M_grab (const _Alloc &__alloc1, const _Alloc &__alloc2)
      {
        return (!_M_is_leaked () && __alloc1 == __alloc2)
                   ? _M_refcopy ()
                   : _M_clone (__alloc1);
      }
      static _Rep *_S_create (size_type, size_type, const _Alloc &);
      void
      _M_dispose (const _Alloc &__a)
      {
        if (__builtin_expect (this != &_S_empty_rep (), false))
          {
            ;
            if (__gnu_cxx::__exchange_and_add_dispatch (&this->_M_refcount, -1)
                <= 0)
              {
                ;
                _M_destroy (__a);
              }
          }
      }
      void _M_destroy (const _Alloc &) throw ();
      _CharT *
      _M_refcopy () throw ()
      {
        if (__builtin_expect (this != &_S_empty_rep (), false))
          __gnu_cxx::__atomic_add_dispatch (&this->_M_refcount, 1);
        return _M_refdata ();
      }
      _CharT *_M_clone (const _Alloc &, size_type __res = 0);
    };
    struct _Alloc_hider : _Alloc
    {
      _Alloc_hider (_CharT *__dat, const _Alloc &__a)
          : _Alloc (__a), _M_p (__dat)
      {
      }
      _CharT *_M_p;
    };

  public:
    static const size_type npos = static_cast<size_type> (-1);

  private:
    mutable _Alloc_hider _M_dataplus;
    _CharT *
    _M_data () const
    {
      return _M_dataplus._M_p;
    }
    _CharT *
    _M_data (_CharT *__p)
    {
      return (_M_dataplus._M_p = __p);
    }
    _Rep *
    _M_rep () const
    {
      return &((reinterpret_cast<_Rep *> (_M_data ()))[-1]);
    };
    ;
    static void
    _M_copy (_CharT *__d, const _CharT *__s, size_type __n)
    {
      if (__n == 1)
        traits_type::assign (*__d, *__s);
      else
        traits_type::copy (__d, __s, __n);
    }
    static int
    _S_compare (size_type __n1, size_type __n2)
    {
      const difference_type __d = difference_type (__n1 - __n2);
      if (__d > __gnu_cxx::__numeric_traits<int>::__max)
        return __gnu_cxx::__numeric_traits<int>::__max;
      else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
        return __gnu_cxx::__numeric_traits<int>::__min;
      else
        return int(__d);
    };
    ;
    static _Rep &
    _S_empty_rep ()
    {
      return _Rep::_S_empty_rep ();
    }

  public:
    basic_string () : _M_dataplus (_S_empty_rep ()._M_refdata (), _Alloc ()){};
    basic_string (const basic_string &__str);
    ;
    ;
    ;
    basic_string (const _CharT *__s, const _Alloc &__a = _Alloc ());
    ;
    ;
    ~basic_string () { _M_rep ()->_M_dispose (this->get_allocator ()); }
    basic_string &operator=(const basic_string &__str)
    {
      return this->assign (__str);
    }
    const_iterator
    begin () const
    {
      return const_iterator (_M_data ());
    }
    const_iterator
    end () const
    {
      return const_iterator (_M_data () + this->size ());
    }

  public:
    size_type
    size () const
    {
      return _M_rep ()->_M_length;
    }
    size_type
    length () const
    {
      return _M_rep ()->_M_length;
    };
    size_type
    capacity () const
    {
      return _M_rep ()->_M_capacity;
    }
    void reserve (size_type __res_arg = 0);
    bool
    empty () const
    {
      return this->size () == 0;
    };
    ;
    ;
    ;
    basic_string &operator+=(const basic_string &__str);
    basic_string &operator+=(const _CharT *__s);
    basic_string &operator+=(_CharT __c)
    {
      this->push_back (__c);
      return *this;
    }
    basic_string &append (const basic_string &__str);
    ;
    basic_string &append (const _CharT *__s, size_type __n);
    basic_string &
    append (const _CharT *__s)
    {
      ;
      return this->append (__s, traits_type::length (__s));
    };
    void
    push_back (_CharT __c)
    {
      const size_type __len = 1 + this->size ();
      if (__len > this->capacity () || _M_rep ()->_M_is_shared ())
        this->reserve (__len);
      traits_type::assign (_M_data ()[this->size ()], __c);
      _M_rep ()->_M_set_length_and_sharable (__len);
    }
    basic_string &assign (const basic_string &__str);
    ;
    const _CharT *
    c_str () const
    {
      return _M_data ();
    }
    const _CharT *
    data () const
    {
      return _M_data ();
    }
    allocator_type
    get_allocator () const
    {
      return _M_dataplus;
    };
    ;
    ;
    ;
    int
    compare (const basic_string &__str) const
    {
      const size_type __size = this->size ();
      const size_type __osize = __str.size ();
      const size_type __len = std::min (__size, __osize);
      int __r = traits_type::compare (_M_data (), __str.data (), __len);
      if (!__r)
        __r = _S_compare (__size, __osize);
      return __r;
    };
  };
  template <typename _CharT, typename _Traits, typename _Alloc>
  basic_string<_CharT, _Traits, _Alloc> operator+(
      const basic_string<_CharT, _Traits, _Alloc> &__lhs,
      const basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    basic_string<_CharT, _Traits, _Alloc> __str (__lhs);
    __str.append (__rhs);
    return __str;
  }
  template <typename _CharT, typename _Traits, typename _Alloc>
  inline basic_string<_CharT, _Traits, _Alloc> operator+(
      const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    basic_string<_CharT, _Traits, _Alloc> __str (__lhs);
    __str.append (__rhs);
    return __str;
  }
  template <typename _CharT>
  inline
      typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
      operator==(const basic_string<_CharT> &__lhs,
                 const basic_string<_CharT> &__rhs)
  {
    return (__lhs.size () == __rhs.size ()
            && !std::char_traits<_CharT>::compare (
                   __lhs.data (), __rhs.data (), __lhs.size ()));
  }
  template <typename _CharT, typename _Traits, typename _Alloc>
  inline bool operator<(const basic_string<_CharT, _Traits, _Alloc> &__lhs,
                        const basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare (__rhs) < 0;
  }
  template <typename _CharT, typename _Traits, typename _Alloc>
  basic_ostream<_CharT, _Traits> &operator<<(
      basic_ostream<_CharT, _Traits> & __os,
      const basic_string<_CharT, _Traits, _Alloc> &__str);
  template <typename _CharT, typename _Traits, typename _Alloc>
  const typename basic_string<_CharT, _Traits, _Alloc>::size_type
      basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_max_size
      = (((npos - sizeof (_Rep_base)) / sizeof (_CharT)) - 1) / 4;
  template <typename _CharT, typename _Traits, typename _Alloc>
  const _CharT basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_terminal
      = _CharT ();
  template <typename _CharT, typename _Traits, typename _Alloc>
  typename basic_string<_CharT, _Traits, _Alloc>::size_type
      basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage
          [(sizeof (_Rep_base) + sizeof (_CharT) + sizeof (size_type) - 1)
           / sizeof (size_type)];
  template <typename _CharT, typename _Traits, typename _Alloc>
  basic_string<_CharT, _Traits, _Alloc>::basic_string (
      const basic_string &__str)
      : _M_dataplus (__str._M_rep ()
                         ->_M_grab (_Alloc (__str.get_allocator ()),
                                    __str.get_allocator ()),
                     __str.get_allocator ())
  {
  }
  template <typename _CharT, typename _Traits, typename _Alloc>
  basic_string<_CharT, _Traits, _Alloc> &
  basic_string<_CharT, _Traits, _Alloc>::assign (const basic_string &__str)
  {
    if (_M_rep () != __str._M_rep ())
      {
        const allocator_type __a = this->get_allocator ();
        _CharT *__tmp = __str._M_rep ()->_M_grab (__a, __str.get_allocator ());
        _M_rep ()->_M_dispose (__a);
        _M_data (__tmp);
      }
    return *this;
  }
  template <typename _CharT, typename _Traits, typename _Alloc>
  void basic_string<_CharT, _Traits, _Alloc>::_Rep::_M_destroy (
      const _Alloc &__a) throw ()
  {
    const size_type __size = sizeof (_Rep_base)
                             + (this->_M_capacity + 1) * sizeof (_CharT);
    _Raw_bytes_alloc (__a)
        .deallocate (reinterpret_cast<char *> (this), __size);
  }
  template <typename _CharT, typename _Traits, typename _Alloc>
  void basic_string<_CharT, _Traits, _Alloc>::reserve (size_type __res)
  {
    if (__res != this->capacity () || _M_rep ()->_M_is_shared ())
      {
        if (__res < this->size ())
          __res = this->size ();
        const allocator_type __a = get_allocator ();
        _CharT *__tmp = _M_rep ()->_M_clone (__a, __res - this->size ());
        _M_rep ()->_M_dispose (__a);
        _M_data (__tmp);
      }
  }
  template <typename _CharT, typename _Traits, typename _Alloc>
  typename basic_string<_CharT, _Traits, _Alloc>::_Rep *
  basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_create (
      size_type __capacity, size_type __old_capacity, const _Alloc &__alloc)
  {
    if (__capacity > _S_max_size)
      __throw_length_error (("basic_string::_S_create"));
    const size_type __pagesize = 4096;
    const size_type __malloc_header_size = 4 * sizeof (void *);
    if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
      __capacity = 2 * __old_capacity;
    size_type __size = (__capacity + 1) * sizeof (_CharT) + sizeof (_Rep);
    const size_type __adj_size = __size + __malloc_header_size;
    if (__adj_size > __pagesize && __capacity > __old_capacity)
      {
        const size_type __extra = __pagesize - __adj_size % __pagesize;
        __capacity += __extra / sizeof (_CharT);
        if (__capacity > _S_max_size)
          __capacity = _S_max_size;
        __size = (__capacity + 1) * sizeof (_CharT) + sizeof (_Rep);
      }
    void *__place = _Raw_bytes_alloc (__alloc).allocate (__size);
    _Rep *__p = new (__place) _Rep;
    __p->_M_capacity = __capacity;
    __p->_M_set_sharable ();
    return __p;
  }
  template <typename _CharT, typename _Traits, typename _Alloc>
  _CharT *basic_string<_CharT, _Traits, _Alloc>::_Rep::_M_clone (
      const _Alloc &__alloc, size_type __res)
  {
    const size_type __requested_cap = this->_M_length + __res;
    _Rep *__r = _Rep::_S_create (__requested_cap, this->_M_capacity, __alloc);
    if (this->_M_length)
      _M_copy (__r->_M_refdata (), _M_refdata (), this->_M_length);
    __r->_M_set_length_and_sharable (this->_M_length);
    return __r->_M_refdata ();
  }
  template <typename _CharT, typename _Traits, typename _Alloc>
  basic_string<_CharT, _Traits, _Alloc> operator+(
      const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs);
  extern template class basic_string<char>;
  class locale
  {
  public:
    typedef int category;
    class facet;
    class id;
    class _Impl;
    friend class facet;
    ;
    ;
    ;

  private:
    _Impl *_M_impl;
    ;
    ;
    ;
  };
  enum _Ios_Fmtflags
  {
    _S_boolalpha = 1L << 0,
    _S_dec = 1L << 1,
    _S_fixed = 1L << 2,
    _S_hex = 1L << 3,
    _S_internal = 1L << 4,
    _S_left = 1L << 5,
    _S_oct = 1L << 6,
    _S_right = 1L << 7,
    _S_scientific = 1L << 8,
    _S_showbase = 1L << 9,
    _S_showpoint = 1L << 10,
    _S_showpos = 1L << 11,
    _S_skipws = 1L << 12,
    _S_unitbuf = 1L << 13,
    _S_uppercase = 1L << 14,
    _S_adjustfield = _S_left | _S_right | _S_internal,
    _S_basefield = _S_dec | _S_oct | _S_hex,
    _S_floatfield = _S_scientific | _S_fixed,
    _S_ios_fmtflags_end = 1L << 16
  };
  enum _Ios_Openmode
  {
    _S_app = 1L << 0,
    _S_ate = 1L << 1,
    _S_bin = 1L << 2,
    _S_in = 1L << 3,
    _S_out = 1L << 4,
    _S_trunc = 1L << 5,
    _S_ios_openmode_end = 1L << 16
  };
  enum _Ios_Iostate
  {
    _S_goodbit = 0,
    _S_badbit = 1L << 0,
    _S_eofbit = 1L << 1,
    _S_failbit = 1L << 2,
    _S_ios_iostate_end = 1L << 16
  };
  enum _Ios_Seekdir
  {
    _S_beg = 0,
    _S_cur = 1,
    _S_end = 2,
    _S_ios_seekdir_end = 1L << 16
  };
  class ios_base
  {
  public:
    class failure : public exception
    {
    public:
      explicit failure (const string &__str) throw ();
      virtual ~failure () throw ();
      ;
    private:
      string _M_msg;
    };
    typedef _Ios_Fmtflags fmtflags;
    static const fmtflags boolalpha = _S_boolalpha;
    typedef _Ios_Iostate iostate;
    static const iostate badbit = _S_badbit;
    static const iostate eofbit = _S_eofbit;
    static const iostate failbit = _S_failbit;
    static const iostate goodbit = _S_goodbit;
    typedef _Ios_Openmode openmode;
    static const openmode app = _S_app;
    static const openmode ate = _S_ate;
    static const openmode binary = _S_bin;
    static const openmode in = _S_in;
    static const openmode out = _S_out;
    static const openmode trunc = _S_trunc;
    typedef std::streamoff streamoff;
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
    typedef void (*event_callback)(event __e, ios_base &__b, int __i);
    ;

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;
    struct _Callback_list
    {
      _Callback_list *_M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;
      ;
      ;
      ;
    };
    _Callback_list *_M_callbacks;
    ;
    ;
    struct _Words
    {
      void *_M_pword;
      long _M_iword;
      ;
    };
    _Words _M_word_zero;
    enum
    {
      _S_local_word_size = 8
    };
    _Words _M_local_word[_S_local_word_size];
    int _M_word_size;
    _Words *_M_word;
    ;
    locale _M_ios_locale;
    ;

  public:
    class Init
    {
      friend class ios_base;
    public:
      Init ();
      ~Init ();
    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };
    ;
    ;
  };
  template <typename _CharT, typename _Traits>
  streamsize __copy_streambufs_eof (basic_streambuf<_CharT, _Traits> *,
                                    basic_streambuf<_CharT, _Traits> *,
                                    bool &);
  template <typename _CharT, typename _Traits> class basic_streambuf
  {
  public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    template <typename _CharT2, typename _Traits2, typename _Alloc>
    friend basic_istream<_CharT2, _Traits2> &
    operator>>(basic_istream<_CharT2, _Traits2> &,
               basic_string<_CharT2, _Traits2, _Alloc> &);
    template <typename _CharT2, typename _Traits2, typename _Alloc>
    friend basic_istream<_CharT2, _Traits2> &
    getline (basic_istream<_CharT2, _Traits2> &,
             basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);

  protected:
    char_type *_M_in_beg;
    char_type *_M_in_cur;
    char_type *_M_in_end;
    char_type *_M_out_beg;
    char_type *_M_out_cur;
    char_type *_M_out_end;
    locale _M_buf_locale;

  public:
    virtual ~basic_streambuf ();
    locale pubimbue (const locale &__loc);
    ;

  private:
    ;
    ;
  };
  template <typename _CharT, typename _Traits>
  class basic_ios : public ios_base
  {
  public:
    typedef _CharT char_type;
    typedef typename _Traits::int_type int_type;
    typedef typename _Traits::pos_type pos_type;
    typedef typename _Traits::off_type off_type;
    typedef _Traits traits_type;
    typedef ctype<_CharT> __ctype_type;
    typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
        __num_put_type;
    typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;

  protected:
    basic_ostream<_CharT, _Traits> *_M_tie;
    mutable char_type _M_fill;
    mutable bool _M_fill_init;
    basic_streambuf<_CharT, _Traits> *_M_streambuf;
    const __ctype_type *_M_ctype;
    const __num_put_type *_M_num_put;
    const __num_get_type *_M_num_get;

  public:
    ;
    ;
    ;
  };
  template <typename _CharT, typename _Traits>
  class basic_ostream : virtual public basic_ios<_CharT, _Traits>
  {
  public:
    typedef _CharT char_type;
    typedef typename _Traits::int_type int_type;
    typedef typename _Traits::pos_type pos_type;
    typedef typename _Traits::off_type off_type;
    typedef _Traits traits_type;
    typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
    typedef basic_ios<_CharT, _Traits> __ios_type;
    typedef basic_ostream<_CharT, _Traits> __ostream_type;
    class sentry;
    friend class sentry;
    __ostream_type &operator<<(__ostream_type &(*__pf)(__ostream_type &));
    ;
    ;
    ;
    __ostream_type &operator<<(unsigned long __n);
    __ostream_type &operator<<(bool __n);
    ;
    ;
    __ostream_type &operator<<(int __n);
    ;
    ;
    ;
    __ostream_type &operator<<(double __f);
    ;
    ;
  };
  template <typename _CharT, typename _Traits>
  basic_ostream<_CharT, _Traits> &endl (basic_ostream<_CharT, _Traits> & __os);
  template <typename _CharT, typename _Traits, typename _Alloc>
  class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
  {
  public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef _Alloc allocator_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;
    typedef basic_streambuf<char_type, traits_type> __streambuf_type;
    typedef basic_string<char_type, _Traits, _Alloc> __string_type;
    typedef typename __string_type::size_type __size_type;

  protected:
    ios_base::openmode _M_mode;
    __string_type _M_string;

  public:
    explicit basic_stringbuf (ios_base::openmode __mode = ios_base::in
                                                          | ios_base::out);
  };
  template <typename _CharT, typename _Traits, typename _Alloc>
  class basic_ostringstream : public basic_ostream<_CharT, _Traits>
  {
  public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
    typedef basic_ostream<char_type, traits_type> __ostream_type;

  private:
    __stringbuf_type _M_stringbuf;

  public:
    explicit basic_ostringstream (ios_base::openmode __mode = ios_base::out);
    ;
    ~basic_ostringstream ();
    ;
    __string_type str () const;
    ;
  };
  extern ostream cout;
  extern ostream cerr;
  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };
  enum float_denorm_style
  {
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
  };
  struct __numeric_limits_base
  {
    static const bool is_specialized = false;
    static const int digits = 0;
  };
  template <typename _Tp> struct numeric_limits : public __numeric_limits_base
  {
    ;
    ;
    ;
    ;
    ;
    static unsigned long
    max () throw ()
    {
      return 0x7fffffffffffffffL * 2UL + 1;
    }
    static const int digits
        = (sizeof (unsigned long) * 8 - ((unsigned long)(-1) < 0));
    static const int digits10 = ((sizeof (unsigned long) * 8
                                  - ((unsigned long)(-1) < 0)) * 643L / 2136);
    static const bool is_signed = false;
    static const bool is_integer = true;
    static const bool is_exact = true;
    static const int radix = 2;
  };
  template <> struct numeric_limits<double>
  {
    static const bool is_specialized = true;
    ;
    static double max () throw ();
    static const int digits = 53;
  };
  namespace __detail
  {
  struct _List_node_base
  {
    _List_node_base *_M_next;
    _List_node_base *_M_prev;
    ;
    ;
    ;
    ;
    ;
  };
  }
  template <typename _Tp> struct _List_node : public __detail::_List_node_base
  {
    _Tp _M_data;
  };
  template <typename _Tp> struct _List_iterator
  {
  };
  template <typename _Tp, typename _Alloc> class _List_base
  {
  protected:
    typedef typename _Alloc::template rebind<_List_node<_Tp> >::other
        _Node_alloc_type;
    typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;
    ;
    ;
    ;
  };
  template <typename _Tp, typename _Alloc = std::allocator<_Tp> >
  class list : protected _List_base<_Tp, _Alloc>
  {
    typedef typename _Alloc::value_type _Alloc_value_type;
    typedef _List_base<_Tp, _Alloc> _Base;
    typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
    typedef typename _Base::_Node_alloc_type _Node_alloc_type;

  public:
    typedef _Tp value_type;
    typedef typename _Tp_alloc_type::pointer pointer;
  };
  enum _Rb_tree_color
  {
    _S_red = false,
    _S_black = true
  };
  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base *_Base_ptr;
    typedef const _Rb_tree_node_base *_Const_Base_ptr;
    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;
    static _Base_ptr
    _S_minimum (_Base_ptr __x)
    {
      while (__x->_M_left != 0)
        __x = __x->_M_left;
      return __x;
    }
    static _Base_ptr
    _S_maximum (_Base_ptr __x)
    {
      while (__x->_M_right != 0)
        __x = __x->_M_right;
      return __x;
    }
  };
  template <typename _Val> struct _Rb_tree_node : public _Rb_tree_node_base
  {
    typedef _Rb_tree_node<_Val> *_Link_type;
    _Val _M_value_field;
    _Val *
    _M_valptr ()
    {
      return std::__addressof (_M_value_field);
    }
    const _Val *
    _M_valptr () const
    {
      return std::__addressof (_M_value_field);
    }
  };
  __attribute__ ((__pure__)) _Rb_tree_node_base
      * _Rb_tree_increment (_Rb_tree_node_base * __x) throw ();
  __attribute__ ((__pure__)) const _Rb_tree_node_base
      * _Rb_tree_increment (const _Rb_tree_node_base *__x) throw ();
  __attribute__ ((__pure__)) _Rb_tree_node_base
      * _Rb_tree_decrement (_Rb_tree_node_base * __x) throw ();
  __attribute__ ((__pure__)) const _Rb_tree_node_base
      * _Rb_tree_decrement (const _Rb_tree_node_base *__x) throw ();
  template <typename _Tp> struct _Rb_tree_iterator
  {
    typedef _Tp value_type;
    typedef _Tp &reference;
    typedef _Tp *pointer;
    typedef bidirectional_iterator_tag iterator_category;
    typedef ptrdiff_t difference_type;
    typedef _Rb_tree_iterator<_Tp> _Self;
    typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
    typedef _Rb_tree_node<_Tp> *_Link_type;
    explicit _Rb_tree_iterator (_Link_type __x) : _M_node (__x) {}
    reference operator*() const
    {
      return *static_cast<_Link_type> (_M_node)->_M_valptr ();
    }
    _Self &operator++()
    {
      _M_node = _Rb_tree_increment (_M_node);
      return *this;
    }
    _Self operator++(int)
    {
      _Self __tmp = *this;
      _M_node = _Rb_tree_increment (_M_node);
      return __tmp;
    }
    _Self &operator--()
    {
      _M_node = _Rb_tree_decrement (_M_node);
      return *this;
    }
    bool operator==(const _Self &__x) const { return _M_node == __x._M_node; }
    bool operator!=(const _Self &__x) const { return _M_node != __x._M_node; }
    _Base_ptr _M_node;
  };
  template <typename _Tp> struct _Rb_tree_const_iterator
  {
    typedef _Tp value_type;
    typedef const _Tp &reference;
    typedef const _Tp *pointer;
    typedef _Rb_tree_iterator<_Tp> iterator;
    typedef bidirectional_iterator_tag iterator_category;
    typedef ptrdiff_t difference_type;
    typedef _Rb_tree_const_iterator<_Tp> _Self;
    typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
    typedef const _Rb_tree_node<_Tp> *_Link_type;
    explicit _Rb_tree_const_iterator (_Link_type __x) : _M_node (__x) {}
    _Rb_tree_const_iterator (const iterator &__it) : _M_node (__it._M_node) {}
    iterator
    _M_const_cast () const
    {
      return iterator (static_cast<typename iterator::_Link_type> (
          const_cast<typename iterator::_Base_ptr> (_M_node)));
    }
    reference operator*() const
    {
      return *static_cast<_Link_type> (_M_node)->_M_valptr ();
    }
    pointer operator->() const
    {
      return static_cast<_Link_type> (_M_node)->_M_valptr ();
    }
    _Self &operator++()
    {
      _M_node = _Rb_tree_increment (_M_node);
      return *this;
    }
    _Self operator++(int)
    {
      _Self __tmp = *this;
      _M_node = _Rb_tree_increment (_M_node);
      return __tmp;
    }
    _Self &operator--()
    {
      _M_node = _Rb_tree_decrement (_M_node);
      return *this;
    }
    bool operator==(const _Self &__x) const { return _M_node == __x._M_node; }
    bool operator!=(const _Self &__x) const { return _M_node != __x._M_node; }
    _Base_ptr _M_node;
  };
  void _Rb_tree_insert_and_rebalance (
      const bool __insert_left, _Rb_tree_node_base *__x,
      _Rb_tree_node_base *__p, _Rb_tree_node_base &__header) throw ();
  _Rb_tree_node_base *_Rb_tree_rebalance_for_erase (
      _Rb_tree_node_base * const __z, _Rb_tree_node_base &__header) throw ();
  template <typename _Key, typename _Val, typename _KeyOfValue,
            typename _Compare, typename _Alloc = allocator<_Val> >
  class _Rb_tree
  {
    typedef typename __gnu_cxx::__alloc_traits<_Alloc>::
        template rebind<_Rb_tree_node<_Val> >::other _Node_allocator;
    typedef __gnu_cxx::__alloc_traits<_Node_allocator> _Alloc_traits;

  protected:
    typedef _Rb_tree_node_base *_Base_ptr;
    typedef const _Rb_tree_node_base *_Const_Base_ptr;

  public:
    typedef _Key key_type;
    typedef _Val value_type;
    typedef value_type *pointer;
    typedef const value_type *const_pointer;
    typedef value_type &reference;
    typedef const value_type &const_reference;
    typedef _Rb_tree_node<_Val> *_Link_type;
    typedef const _Rb_tree_node<_Val> *_Const_Link_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Alloc allocator_type;
    _Node_allocator &
    _M_get_Node_allocator ()
    {
      return *static_cast<_Node_allocator *> (&this->_M_impl);
    }
    const _Node_allocator &
    _M_get_Node_allocator () const
    {
      return *static_cast<const _Node_allocator *> (&this->_M_impl);
    }
    allocator_type
    get_allocator () const
    {
      return allocator_type (_M_get_Node_allocator ());
    }

  protected:
    _Link_type
    _M_get_node ()
    {
      return _Alloc_traits::allocate (_M_get_Node_allocator (), 1);
    }
    void
    _M_put_node (_Link_type __p)
    {
      _Alloc_traits::deallocate (_M_get_Node_allocator (), __p, 1);
    }
    _Link_type
    _M_create_node (const value_type &__x)
    {
      _Link_type __tmp = _M_get_node ();
      try
        {
          get_allocator ().construct (__tmp->_M_valptr (), __x);
        }
      catch (...)
        {
          _M_put_node (__tmp);
          throw;
        }
      return __tmp;
    }
    void
    _M_destroy_node (_Link_type __p)
    {
      get_allocator ().destroy (__p->_M_valptr ());
      _M_put_node (__p);
    }
    _Link_type
    _M_clone_node (_Const_Link_type __x)
    {
      _Link_type __tmp = _M_create_node (*__x->_M_valptr ());
      __tmp->_M_color = __x->_M_color;
      __tmp->_M_left = 0;
      __tmp->_M_right = 0;
      return __tmp;
    }

  protected:
    template <typename _Key_compare,
              bool _Is_pod_comparator = __is_pod(_Key_compare)>
    struct _Rb_tree_impl : public _Node_allocator
    {
      _Key_compare _M_key_compare;
      _Rb_tree_node_base _M_header;
      size_type _M_node_count;
      _Rb_tree_impl ()
          : _Node_allocator (), _M_key_compare (), _M_header (),
            _M_node_count (0)
      {
        _M_initialize ();
      }
      _Rb_tree_impl (const _Key_compare &__comp, const _Node_allocator &__a)
          : _Node_allocator (__a), _M_key_compare (__comp), _M_header (),
            _M_node_count (0)
      {
        _M_initialize ();
      }
    private:
      void
      _M_initialize ()
      {
        this->_M_header._M_color = _S_red;
        this->_M_header._M_parent = 0;
        this->_M_header._M_left = &this->_M_header;
        this->_M_header._M_right = &this->_M_header;
      }
    };
    _Rb_tree_impl<_Compare> _M_impl;

  protected:
    _Base_ptr &
    _M_root ()
    {
      return this->_M_impl._M_header._M_parent;
    }
    _Const_Base_ptr
    _M_root () const
    {
      return this->_M_impl._M_header._M_parent;
    }
    _Base_ptr &
    _M_leftmost ()
    {
      return this->_M_impl._M_header._M_left;
    }
    _Base_ptr &
    _M_rightmost ()
    {
      return this->_M_impl._M_header._M_right;
    }
    _Link_type
    _M_begin ()
    {
      return static_cast<_Link_type> (this->_M_impl._M_header._M_parent);
    }
    _Const_Link_type
    _M_begin () const
    {
      return static_cast<_Const_Link_type> (this->_M_impl._M_header._M_parent);
    }
    _Link_type
    _M_end ()
    {
      return reinterpret_cast<_Link_type> (&this->_M_impl._M_header);
    }
    _Const_Link_type
    _M_end () const
    {
      return reinterpret_cast<_Const_Link_type> (&this->_M_impl._M_header);
    }
    static const_reference
    _S_value (_Const_Link_type __x)
    {
      return *__x->_M_valptr ();
    }
    static const _Key &
    _S_key (_Const_Link_type __x)
    {
      return _KeyOfValue ()(_S_value (__x));
    }
    static _Link_type
    _S_left (_Base_ptr __x)
    {
      return static_cast<_Link_type> (__x->_M_left);
    }
    static _Const_Link_type
    _S_left (_Const_Base_ptr __x)
    {
      return static_cast<_Const_Link_type> (__x->_M_left);
    }
    static _Link_type
    _S_right (_Base_ptr __x)
    {
      return static_cast<_Link_type> (__x->_M_right);
    }
    static _Const_Link_type
    _S_right (_Const_Base_ptr __x)
    {
      return static_cast<_Const_Link_type> (__x->_M_right);
    }
    static const_reference
    _S_value (_Const_Base_ptr __x)
    {
      return *static_cast<_Const_Link_type> (__x)->_M_valptr ();
    }
    static const _Key &
    _S_key (_Const_Base_ptr __x)
    {
      return _KeyOfValue ()(_S_value (__x));
    }
    static _Base_ptr
    _S_minimum (_Base_ptr __x)
    {
      return _Rb_tree_node_base::_S_minimum (__x);
    }
    static _Base_ptr
    _S_maximum (_Base_ptr __x)
    {
      return _Rb_tree_node_base::_S_maximum (__x);
    }

  public:
    typedef _Rb_tree_iterator<value_type> iterator;
    typedef _Rb_tree_const_iterator<value_type> const_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  private:
    pair<_Base_ptr, _Base_ptr> _M_get_insert_unique_pos (const key_type &__k);
    ;
    pair<_Base_ptr, _Base_ptr>
    _M_get_insert_hint_unique_pos (const_iterator __pos, const key_type &__k);
    ;
    iterator _M_insert_ (_Base_ptr __x, _Base_ptr __y, const value_type &__v);
    ;
    ;
    _Link_type _M_copy (_Const_Link_type __x, _Link_type __p);
    void _M_erase (_Link_type __x);
    iterator _M_lower_bound (_Link_type __x, _Link_type __y, const _Key &__k);
    const_iterator _M_lower_bound (_Const_Link_type __x, _Const_Link_type __y,
                                   const _Key &__k) const;
    iterator _M_upper_bound (_Link_type __x, _Link_type __y, const _Key &__k);
    const_iterator _M_upper_bound (_Const_Link_type __x, _Const_Link_type __y,
                                   const _Key &__k) const;

  public:
    _Rb_tree () {}
    _Rb_tree (const _Rb_tree &__x)
        : _M_impl (
              __x._M_impl._M_key_compare,
              _Alloc_traits::_S_select_on_copy (__x._M_get_Node_allocator ()))
    {
      if (__x._M_root () != 0)
        {
          _M_root () = _M_copy (__x._M_begin (), _M_end ());
          _M_leftmost () = _S_minimum (_M_root ());
          _M_rightmost () = _S_maximum (_M_root ());
          _M_impl._M_node_count = __x._M_impl._M_node_count;
        }
    }
    ~_Rb_tree () { _M_erase (_M_begin ()); };
    _Compare
    key_comp () const
    {
      return _M_impl._M_key_compare;
    }
    iterator
    begin ()
    {
      return iterator (
          static_cast<_Link_type> (this->_M_impl._M_header._M_left));
    }
    const_iterator
    begin () const
    {
      return const_iterator (
          static_cast<_Const_Link_type> (this->_M_impl._M_header._M_left));
    }
    iterator
    end ()
    {
      return iterator (static_cast<_Link_type> (&this->_M_impl._M_header));
    }
    const_iterator
    end () const
    {
      return const_iterator (
          static_cast<_Const_Link_type> (&this->_M_impl._M_header));
    }
    const_reverse_iterator
    rbegin () const
    {
      return const_reverse_iterator (end ());
    }
    const_reverse_iterator
    rend () const
    {
      return const_reverse_iterator (begin ());
    }
    bool
    empty () const
    {
      return _M_impl._M_node_count == 0;
    }
    size_type
    size () const
    {
      return _M_impl._M_node_count;
    };
    pair<iterator, bool> _M_insert_unique (const value_type &__x);
    ;
    iterator _M_insert_unique_ (const_iterator __position,
                                const value_type &__x);
    ;
    template <typename _InputIterator>
    void _M_insert_unique (_InputIterator __first, _InputIterator __last);
    ;

  private:
    void _M_erase_aux (const_iterator __position);
    void _M_erase_aux (const_iterator __first, const_iterator __last);

  public:
    void
    erase (iterator __position)
    {
      _M_erase_aux (__position);
    }
    void
    erase (const_iterator __position)
    {
      _M_erase_aux (__position);
    }
    size_type erase (const key_type &__x);
    void
    erase (iterator __first, iterator __last)
    {
      _M_erase_aux (__first, __last);
    };
    void
    clear ()
    {
      _M_erase (_M_begin ());
      _M_leftmost () = _M_end ();
      _M_root () = 0;
      _M_rightmost () = _M_end ();
      _M_impl._M_node_count = 0;
    }
    iterator find (const key_type &__k);
    ;
    ;
    iterator
    lower_bound (const key_type &__k)
    {
      return _M_lower_bound (_M_begin (), _M_end (), __k);
    }
    const_iterator
    lower_bound (const key_type &__k) const
    {
      return _M_lower_bound (_M_begin (), _M_end (), __k);
    }
    iterator
    upper_bound (const key_type &__k)
    {
      return _M_upper_bound (_M_begin (), _M_end (), __k);
    }
    const_iterator
    upper_bound (const key_type &__k) const
    {
      return _M_upper_bound (_M_begin (), _M_end (), __k);
    }
    pair<iterator, iterator> equal_range (const key_type &__k);
    ;
    ;
  };
  template <typename _Key, typename _Val, typename _KeyOfValue,
            typename _Compare, typename _Alloc>
  typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_ (
      _Base_ptr __x, _Base_ptr __p, const _Val &__v)
  {
    bool __insert_left
        = (__x != 0 || __p == _M_end ()
           || _M_impl._M_key_compare (_KeyOfValue ()(__v), _S_key (__p)));
    _Link_type __z = _M_create_node ((__v));
    _Rb_tree_insert_and_rebalance (__insert_left, __z, __p,
                                   this->_M_impl._M_header);
    ++_M_impl._M_node_count;
    return iterator (__z);
  }
  template <typename _Key, typename _Val, typename _KoV, typename _Compare,
            typename _Alloc>
  typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
  _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_M_copy (_Const_Link_type __x,
                                                         _Link_type __p)
  {
    _Link_type __top = _M_clone_node (__x);
    __top->_M_parent = __p;
    try
      {
        if (__x->_M_right)
          __top->_M_right = _M_copy (_S_right (__x), __top);
        __p = __top;
        __x = _S_left (__x);
        while (__x != 0)
          {
            _Link_type __y = _M_clone_node (__x);
            __p->_M_left = __y;
            __y->_M_parent = __p;
            if (__x->_M_right)
              __y->_M_right = _M_copy (_S_right (__x), __y);
            __p = __y;
            __x = _S_left (__x);
          }
      }
    catch (...)
      {
        _M_erase (__top);
        throw;
      }
    return __top;
  }
  template <typename _Key, typename _Val, typename _KeyOfValue,
            typename _Compare, typename _Alloc>
  void _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_erase (
      _Link_type __x)
  {
    while (__x != 0)
      {
        _M_erase (_S_right (__x));
        _Link_type __y = _S_left (__x);
        _M_destroy_node (__x);
        __x = __y;
      }
  }
  template <typename _Key, typename _Val, typename _KeyOfValue,
            typename _Compare, typename _Alloc>
  typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_lower_bound (
      _Link_type __x, _Link_type __y, const _Key &__k)
  {
    while (__x != 0)
      if (!_M_impl._M_key_compare (_S_key (__x), __k))
        __y = __x, __x = _S_left (__x);
      else
        __x = _S_right (__x);
    return iterator (__y);
  }
  template <typename _Key, typename _Val, typename _KeyOfValue,
            typename _Compare, typename _Alloc>
  typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_lower_bound (
      _Const_Link_type __x, _Const_Link_type __y, const _Key &__k) const
  {
    while (__x != 0)
      if (!_M_impl._M_key_compare (_S_key (__x), __k))
        __y = __x, __x = _S_left (__x);
      else
        __x = _S_right (__x);
    return const_iterator (__y);
  }
  template <typename _Key, typename _Val, typename _KeyOfValue,
            typename _Compare, typename _Alloc>
  typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_upper_bound (
      _Link_type __x, _Link_type __y, const _Key &__k)
  {
    while (__x != 0)
      if (_M_impl._M_key_compare (__k, _S_key (__x)))
        __y = __x, __x = _S_left (__x);
      else
        __x = _S_right (__x);
    return iterator (__y);
  }
  template <typename _Key, typename _Val, typename _KeyOfValue,
            typename _Compare, typename _Alloc>
  typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_upper_bound (
      _Const_Link_type __x, _Const_Link_type __y, const _Key &__k) const
  {
    while (__x != 0)
      if (_M_impl._M_key_compare (__k, _S_key (__x)))
        __y = __x, __x = _S_left (__x);
      else
        __x = _S_right (__x);
    return const_iterator (__y);
  }
  template <typename _Key, typename _Val, typename _KeyOfValue,
            typename _Compare, typename _Alloc>
  pair<typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator,
       typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator>
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::equal_range (
      const _Key &__k)
  {
    _Link_type __x = _M_begin ();
    _Link_type __y = _M_end ();
    while (__x != 0)
      {
        if (_M_impl._M_key_compare (_S_key (__x), __k))
          __x = _S_right (__x);
        else if (_M_impl._M_key_compare (__k, _S_key (__x)))
          __y = __x, __x = _S_left (__x);
        else
          {
            _Link_type __xu (__x), __yu (__y);
            __y = __x, __x = _S_left (__x);
            __xu = _S_right (__xu);
            return pair<iterator, iterator> (_M_lower_bound (__x, __y, __k),
                                             _M_upper_bound (__xu, __yu, __k));
          }
      }
    return pair<iterator, iterator> (iterator (__y), iterator (__y));
  }
  template <typename _Key, typename _Val, typename _KeyOfValue,
            typename _Compare, typename _Alloc>
  pair<typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr,
       typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr>
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare,
           _Alloc>::_M_get_insert_unique_pos (const key_type &__k)
  {
    typedef pair<_Base_ptr, _Base_ptr> _Res;
    _Link_type __x = _M_begin ();
    _Link_type __y = _M_end ();
    bool __comp = true;
    while (__x != 0)
      {
        __y = __x;
        __comp = _M_impl._M_key_compare (__k, _S_key (__x));
        __x = __comp ? _S_left (__x) : _S_right (__x);
      }
    iterator __j = iterator (__y);
    if (__comp)
      {
        if (__j == begin ())
          return _Res (__x, __y);
        else
          --__j;
      }
    if (_M_impl._M_key_compare (_S_key (__j._M_node), __k))
      return _Res (__x, __y);
    return _Res (__j._M_node, 0);
  }
  template <typename _Key, typename _Val, typename _KeyOfValue,
            typename _Compare, typename _Alloc>
  pair<typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator,
       bool>
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_unique (
      const _Val &__v)
  {
    typedef pair<iterator, bool> _Res;
    pair<_Base_ptr, _Base_ptr> __res
        = _M_get_insert_unique_pos (_KeyOfValue ()(__v));
    if (__res.second)
      return _Res (_M_insert_ (__res.first, __res.second, (__v)), true);
    return _Res (iterator (static_cast<_Link_type> (__res.first)), false);
  }
  template <typename _Key, typename _Val, typename _KeyOfValue,
            typename _Compare, typename _Alloc>
  pair<typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr,
       typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr>
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare,
           _Alloc>::_M_get_insert_hint_unique_pos (const_iterator __position,
                                                   const key_type &__k)
  {
    iterator __pos = __position._M_const_cast ();
    typedef pair<_Base_ptr, _Base_ptr> _Res;
    if (__pos._M_node == _M_end ())
      {
        if (size () > 0
            && _M_impl._M_key_compare (_S_key (_M_rightmost ()), __k))
          return _Res (0, _M_rightmost ());
        else
          return _M_get_insert_unique_pos (__k);
      }
    else if (_M_impl._M_key_compare (__k, _S_key (__pos._M_node)))
      {
        iterator __before = __pos;
        if (__pos._M_node == _M_leftmost ())
          return _Res (_M_leftmost (), _M_leftmost ());
        else if (_M_impl._M_key_compare (_S_key ((--__before)._M_node), __k))
          {
            if (_S_right (__before._M_node) == 0)
              return _Res (0, __before._M_node);
            else
              return _Res (__pos._M_node, __pos._M_node);
          }
        else
          return _M_get_insert_unique_pos (__k);
      }
    else if (_M_impl._M_key_compare (_S_key (__pos._M_node), __k))
      {
        iterator __after = __pos;
        if (__pos._M_node == _M_rightmost ())
          return _Res (0, _M_rightmost ());
        else if (_M_impl._M_key_compare (__k, _S_key ((++__after)._M_node)))
          {
            if (_S_right (__pos._M_node) == 0)
              return _Res (0, __pos._M_node);
            else
              return _Res (__after._M_node, __after._M_node);
          }
        else
          return _M_get_insert_unique_pos (__k);
      }
    else
      return _Res (__pos._M_node, 0);
  }
  template <typename _Key, typename _Val, typename _KeyOfValue,
            typename _Compare, typename _Alloc>
  typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_unique_ (
      const_iterator __position, const _Val &__v)
  {
    pair<_Base_ptr, _Base_ptr> __res
        = _M_get_insert_hint_unique_pos (__position, _KeyOfValue ()(__v));
    if (__res.second)
      return _M_insert_ (__res.first, __res.second, (__v));
    return iterator (static_cast<_Link_type> (__res.first));
  }
  template <typename _Key, typename _Val, typename _KoV, typename _Cmp,
            typename _Alloc>
  template <class _II>
  void _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::_M_insert_unique (_II __first,
                                                                   _II __last)
  {
    for (; __first != __last; ++__first)
      _M_insert_unique_ (end (), *__first);
  }
  template <typename _Key, typename _Val, typename _KeyOfValue,
            typename _Compare, typename _Alloc>
  void _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_erase_aux (
      const_iterator __position)
  {
    _Link_type __y = static_cast<_Link_type> (_Rb_tree_rebalance_for_erase (
        const_cast<_Base_ptr> (__position._M_node), this->_M_impl._M_header));
    _M_destroy_node (__y);
    --_M_impl._M_node_count;
  }
  template <typename _Key, typename _Val, typename _KeyOfValue,
            typename _Compare, typename _Alloc>
  void _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_erase_aux (
      const_iterator __first, const_iterator __last)
  {
    if (__first == begin () && __last == end ())
      clear ();
    else
      while (__first != __last)
        erase (__first++);
  }
  template <typename _Key, typename _Val, typename _KeyOfValue,
            typename _Compare, typename _Alloc>
  typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::erase (const _Key &__x)
  {
    pair<iterator, iterator> __p = equal_range (__x);
    const size_type __old_size = size ();
    erase (__p.first, __p.second);
    return __old_size - size ();
  }
  template <typename _Key, typename _Val, typename _KeyOfValue,
            typename _Compare, typename _Alloc>
  typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::find (const _Key &__k)
  {
    iterator __j = _M_lower_bound (_M_begin (), _M_end (), __k);
    return (__j == end ()
            || _M_impl._M_key_compare (__k, _S_key (__j._M_node)))
               ? end ()
               : __j;
  }
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
  class map
  {
  public:
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef std::pair<const _Key, _Tp> value_type;
    typedef _Compare key_compare;
    typedef _Alloc allocator_type;

  private:
    typedef typename _Alloc::value_type _Alloc_value_type;

  public:
    class value_compare
        : public std::binary_function<value_type, value_type, bool>
    {
      friend class map<_Key, _Tp, _Compare, _Alloc>;
    protected:
      _Compare comp;
    public:
    };

  private:
    typedef typename __gnu_cxx::__alloc_traits<_Alloc>::
        template rebind<value_type>::other _Pair_alloc_type;
    typedef _Rb_tree<key_type, value_type, _Select1st<value_type>, key_compare,
                     _Pair_alloc_type> _Rep_type;
    _Rep_type _M_t;
    typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;

  public:
    typedef typename _Alloc_traits::pointer pointer;
    typedef typename _Alloc_traits::const_pointer const_pointer;
    typedef typename _Alloc_traits::reference reference;
    typedef typename _Alloc_traits::const_reference const_reference;
    typedef typename _Rep_type::iterator iterator;
    typedef typename _Rep_type::const_iterator const_iterator;
    typedef typename _Rep_type::size_type size_type;
    typedef typename _Rep_type::difference_type difference_type;
    typedef typename _Rep_type::reverse_iterator reverse_iterator;
    typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
    map () : _M_t () {}
    map (const map &__x) : _M_t (__x._M_t) {}
    template <typename _InputIterator>
    map (_InputIterator __first, _InputIterator __last)
        : _M_t ()
    {
      _M_t._M_insert_unique (__first, __last);
    }
    iterator
    begin ()
    {
      return _M_t.begin ();
    }
    const_iterator
    begin () const
    {
      return _M_t.begin ();
    }
    iterator
    end ()
    {
      return _M_t.end ();
    }
    const_iterator
    end () const
    {
      return _M_t.end ();
    }
    const_reverse_iterator
    rbegin () const
    {
      return _M_t.rbegin ();
    }
    const_reverse_iterator
    rend () const
    {
      return _M_t.rend ();
    }
    bool
    empty () const
    {
      return _M_t.empty ();
    }
    size_type
    size () const
    {
      return _M_t.size ();
    }
    mapped_type &operator[](const key_type &__k)
    {
      iterator __i = lower_bound (__k);
      if (__i == end () || key_comp ()(__k, (*__i).first))
        __i = insert (__i, value_type (__k, mapped_type ()));
      return (*__i).second;
    }
    std::pair<iterator, bool>
    insert (const value_type &__x)
    {
      return _M_t._M_insert_unique (__x);
    }
    iterator
    insert (iterator __position, const value_type &__x)
    {
      return _M_t._M_insert_unique_ (__position, __x);
    }
    void
    erase (iterator __position)
    {
      _M_t.erase (__position);
    }
    size_type
    erase (const key_type &__x)
    {
      return _M_t.erase (__x);
    }
    void
    clear ()
    {
      _M_t.clear ();
    }
    key_compare
    key_comp () const
    {
      return _M_t.key_comp ();
    }
    iterator
    find (const key_type &__x)
    {
      return _M_t.find (__x);
    }
    iterator
    lower_bound (const key_type &__x)
    {
      return _M_t.lower_bound (__x);
    }
    const_iterator
    lower_bound (const key_type &__x) const
    {
      return _M_t.lower_bound (__x);
    }
    iterator
    upper_bound (const key_type &__x)
    {
      return _M_t.upper_bound (__x);
    }
    const_iterator
    upper_bound (const key_type &__x) const
    {
      return _M_t.upper_bound (__x);
    };
    ;
    ;
    ;
  };
  template <typename _Tp, typename _Alloc> struct _Vector_base
  {
    typedef
        typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<_Tp>::other
            _Tp_alloc_type;
    typedef
        typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer pointer;
    struct _Vector_impl : public _Tp_alloc_type
    {
      pointer _M_start;
      pointer _M_finish;
      pointer _M_end_of_storage;
      ;
      ;
      ;
    };

  public:
    typedef _Alloc allocator_type;

  private:
    ;
  };
  template <typename _Tp, typename _Alloc = std::allocator<_Tp> >
  class vector : protected _Vector_base<_Tp, _Alloc>
  {
    typedef typename _Alloc::value_type _Alloc_value_type;
    typedef _Vector_base<_Tp, _Alloc> _Base;
    typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
    typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

  public:
    typedef _Tp value_type;
  };
  template <typename _Key, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<_Key> >
  class set
  {
    typedef typename _Alloc::value_type _Alloc_value_type;

  public:
    typedef _Key key_type;
    ;
    ;
  };
  class logic_error : public exception
  {
    string _M_msg;

  public:
    explicit logic_error (const string &__arg);
    virtual ~logic_error () throw ();
    virtual const char *what () const throw ();
  };
}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
  namespace typelist
  {
  struct null_type
  {
  };
  template <typename Root> struct node
  {
    typedef Root root;
  };
  template <typename Hd, typename Typelist> struct chain
  {
    typedef Hd head;
    typedef Typelist tail;
  };
  template <typename Fn, typename Typelist> void apply (Fn &, Typelist);
  ;
  ;
  template <typename Typelist0, typename Typelist1> struct append;
  template <typename Typelist_Typelist> struct append_typelist;
  template <typename T1, typename T2, typename T3, typename T4, typename T5,
            typename T6>
  struct create6;
  }
  namespace typelist
  {
  namespace detail
  {
  template <typename Fn, typename Typelist_Chain> struct apply_;
  template <typename Fn, typename Hd, typename Tl>
  struct apply_<Fn, chain<Hd, Tl> >
  {
    void operator()(Fn &f)
    {
      f.operator()(Hd ());
      apply_<Fn, Tl> next;
      next (f);
    }
  };
  template <typename Fn> struct apply_<Fn, null_type>
  {
    void operator()(Fn &) {}
  };
  template <typename Gn, typename Typelist_Chain> struct apply_generator1_;
  template <typename Gn, typename Hd, typename Tl>
  struct apply_generator1_<Gn, chain<Hd, Tl> >
  {
  };
  template <typename Gn> struct apply_generator1_<Gn, null_type>
  {
  };
  template <typename Gn, typename TypelistT_Chain, typename TypelistV_Chain>
  struct apply_generator2_;
  template <typename Gn, typename Hd1, typename TlT, typename Hd2,
            typename TlV>
  struct apply_generator2_<Gn, chain<Hd1, TlT>, chain<Hd2, TlV> >
  {
  };
  template <typename Gn> struct apply_generator2_<Gn, null_type, null_type>
  {
  };
  template <typename Typelist_Chain0, typename Typelist_Chain1> struct append_;
  template <typename Hd, typename Tl, typename Typelist_Chain>
  struct append_<chain<Hd, Tl>, Typelist_Chain>
  {
  private:
    typedef append_<Tl, Typelist_Chain> append_type;
  public:
    typedef chain<Hd, typename append_type::type> type;
  };
  template <typename Typelist_Chain> struct append_<null_type, Typelist_Chain>
  {
    typedef Typelist_Chain type;
  };
  template <typename Typelist_Chain> struct append_<Typelist_Chain, null_type>
  {
    typedef Typelist_Chain type;
  };
  template <> struct append_<null_type, null_type>
  {
    typedef null_type type;
  };
  template <typename Typelist_Typelist_Chain> struct append_typelist_;
  template <typename Hd> struct append_typelist_<chain<Hd, null_type> >
  {
    typedef chain<Hd, null_type> type;
  };
  template <typename Hd, typename Tl> struct append_typelist_<chain<Hd, Tl> >
  {
  private:
    typedef typename append_typelist_<Tl>::type rest_type;
  public:
    typedef typename append<Hd, node<rest_type> >::type::root type;
  };
  template <typename Typelist_Chain, typename T> struct contains_;
  template <typename T> struct contains_<null_type, T>
  {
    enum
    {
      value = false
    };
  };
  template <typename Hd, typename Tl, typename T>
  struct contains_<chain<Hd, Tl>, T>
  {
    enum
    {
      value = contains_<Tl, T>::value
    };
  };
  template <typename Tl, typename T> struct contains_<chain<T, Tl>, T>
  {
    enum
    {
      value = true
    };
  };
  template <typename Typelist_Chain, template <typename T> class Pred>
  struct chain_filter_;
  template <template <typename T> class Pred>
  struct chain_filter_<null_type, Pred>
  {
    typedef null_type type;
  };
  template <typename Hd, typename Tl, template <typename T> class Pred>
  struct chain_filter_<chain<Hd, Tl>, Pred>
  {
  private:
    enum
    {
      include_hd = Pred<Hd>::value
    };
    typedef typename chain_filter_<Tl, Pred>::type rest_type;
    typedef chain<Hd, rest_type> chain_type;
  public:
    typedef typename __conditional_type<include_hd, chain_type,
                                        rest_type>::__type type;
  };
  template <typename Typelist_Chain, int i> struct chain_at_index_;
  template <typename Hd, typename Tl> struct chain_at_index_<chain<Hd, Tl>, 0>
  {
    typedef Hd type;
  };
  template <typename Hd, typename Tl, int i>
  struct chain_at_index_<chain<Hd, Tl>, i>
  {
    typedef typename chain_at_index_<Tl, i - 1>::type type;
  };
  template <class Typelist_Chain, template <typename T> class Transform>
  struct chain_transform_;
  template <template <typename T> class Transform>
  struct chain_transform_<null_type, Transform>
  {
    typedef null_type type;
  };
  template <class Hd, class Tl, template <typename T> class Transform>
  struct chain_transform_<chain<Hd, Tl>, Transform>
  {
  private:
    typedef typename chain_transform_<Tl, Transform>::type rest_type;
    typedef typename Transform<Hd>::type transform_type;
  public:
    typedef chain<transform_type, rest_type> type;
  };
  template <typename Typelist_Typelist_Chain> struct chain_flatten_;
  template <typename Hd_Tl> struct chain_flatten_<chain<Hd_Tl, null_type> >
  {
    typedef typename Hd_Tl::root type;
  };
  template <typename Hd_Typelist, class Tl_Typelist>
  struct chain_flatten_<chain<Hd_Typelist, Tl_Typelist> >
  {
  private:
    typedef typename chain_flatten_<Tl_Typelist>::type rest_type;
    typedef append<Hd_Typelist, node<rest_type> > append_type;
  public:
    typedef typename append_type::type::root type;
  };
  }
  }
  namespace typelist
  {
  template <typename Fn, typename Typelist>
  void
  apply (Fn &fn, Typelist)
  {
    detail::apply_<Fn, typename Typelist::root> a;
    a (fn);
  }
  template <typename Typelist0, typename Typelist1> struct append
  {
  private:
    typedef typename Typelist0::root root0_type;
    typedef typename Typelist1::root root1_type;
    typedef detail::append_<root0_type, root1_type> append_type;
  public:
    typedef node<typename append_type::type> type;
  };
  template <typename Typelist_Typelist> struct append_typelist
  {
  private:
    typedef typename Typelist_Typelist::root root_type;
    typedef detail::append_typelist_<root_type> append_type;
  public:
    typedef node<typename append_type::type> type;
  };
  template <typename Typelist, typename T> struct contains
  {
  private:
    typedef typename Typelist::root root_type;
  public:
    enum
    {
      value = detail::contains_<root_type, T>::value
    };
  };
  template <typename Typelist, template <typename T> class Pred> struct filter
  {
  private:
    typedef typename Typelist::root root_type;
    typedef detail::chain_filter_<root_type, Pred> filter_type;
  public:
    typedef node<typename filter_type::type> type;
  };
  template <typename Typelist, int i> struct at_index
  {
  private:
    typedef typename Typelist::root root_type;
    typedef detail::chain_at_index_<root_type, i> index_type;
  public:
    typedef typename index_type::type type;
  };
  template <typename Typelist, template <typename T> class Transform>
  struct transform
  {
  private:
    typedef typename Typelist::root root_type;
    typedef detail::chain_transform_<root_type, Transform> transform_type;
  public:
    typedef node<typename transform_type::type> type;
  };
  template <typename Typelist_Typelist> struct flatten
  {
  private:
    typedef typename Typelist_Typelist::root root_type;
    typedef typename detail::chain_flatten_<root_type>::type flatten_type;
  public:
    typedef node<flatten_type> type;
  };
  template <typename Typelist> struct from_first
  {
  private:
    typedef typename at_index<Typelist, 0>::type first_type;
  public:
    typedef node<chain<first_type, null_type> > type;
  };
  template <typename T1> struct create1
  {
    typedef node<__gnu_cxx::typelist::chain<T1,
                                            __gnu_cxx::typelist::null_type> >
        type;
  };
  template <typename T1, typename T2> struct create2
  {
    typedef node<__gnu_cxx::typelist::
                     chain<T1,
                           __gnu_cxx::typelist::
                               chain<T2, __gnu_cxx::typelist::null_type> > >
        type;
  };
  template <typename T1, typename T2, typename T3> struct create3
  {
    typedef node<__gnu_cxx::typelist::
                     chain<T1,
                           __gnu_cxx::typelist::
                               chain<T2, __gnu_cxx::typelist::
                                             chain<T3, __gnu_cxx::typelist::
                                                           null_type> > > >
        type;
  };
  template <typename T1, typename T2, typename T3, typename T4> struct create4
  {
    typedef node<__gnu_cxx::typelist::
                     chain<T1,
                           __gnu_cxx::typelist::
                               chain<T2,
                                     __gnu_cxx::typelist::
                                         chain<T3,
                                               __gnu_cxx::typelist::
                                                   chain<T4,
                                                         __gnu_cxx::typelist::
                                                             null_type> > > > >
        type;
  };
  template <typename T1, typename T2, typename T3, typename T4, typename T5>
  struct create5
  {
    typedef node<__gnu_cxx::typelist::
                     chain<T1,
                           __gnu_cxx::typelist::
                               chain<T2,
                                     __gnu_cxx::typelist::
                                         chain<T3,
                                               __gnu_cxx::typelist::
                                                   chain<T4,
                                                         __gnu_cxx::typelist::
                                                             chain<T5,
                                                                   __gnu_cxx::typelist::
                                                                       null_type> > > > > >
        type;
  };
  template <typename T1, typename T2, typename T3, typename T4, typename T5,
            typename T6>
  struct create6
  {
    typedef node<__gnu_cxx::typelist::
                     chain<T1,
                           __gnu_cxx::typelist::
                               chain<T2,
                                     __gnu_cxx::typelist::
                                         chain<T3,
                                               __gnu_cxx::typelist::
                                                   chain<T4,
                                                         __gnu_cxx::typelist::
                                                             chain<T5,
                                                                   __gnu_cxx::typelist::
                                                                       chain<T6,
                                                                             __gnu_cxx::typelist::
                                                                                 null_type> > > > > > >
        type;
  };
  }
}
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace tr1
  {
  struct __sfinae_types
  {
    typedef char __one;
    typedef struct
    {
      char __arr[2];
    } __two;
  };
  template <typename _Tp, _Tp __v> struct integral_constant
  {
    static const _Tp value = __v;
    typedef _Tp value_type;
    typedef integral_constant<_Tp, __v> type;
  };
  typedef integral_constant<bool, true> true_type;
  typedef integral_constant<bool, false> false_type;
  template <typename _Tp, _Tp __v>
  const _Tp integral_constant<_Tp, __v>::value;
  template <typename> struct remove_cv;
  template <typename> struct __is_void_helper : public false_type
  {
  };
  template <>
  struct __is_void_helper<void> : public integral_constant<bool, true>
  {
  };
  template <typename _Tp>
  struct is_void
      : public integral_constant<bool,
                                 (__is_void_helper<
                                     typename remove_cv<_Tp>::type>::value)>
  {
  };
  template <typename> struct __is_integral_helper : public false_type
  {
  };
  template <>
  struct __is_integral_helper<bool> : public integral_constant<bool, true>
  {
  };
  template <>
  struct __is_integral_helper<short> : public integral_constant<bool, true>
  {
  };
  template <>
  struct __is_integral_helper<unsigned short>
      : public integral_constant<bool, true>
  {
  };
  template <>
  struct __is_integral_helper<int> : public integral_constant<bool, true>
  {
  };
  template <>
  struct __is_integral_helper<unsigned int>
      : public integral_constant<bool, true>
  {
  };
  template <typename _Tp>
  struct is_integral
      : public integral_constant<bool,
                                 (__is_integral_helper<
                                     typename remove_cv<_Tp>::type>::value)>
  {
  };
  template <typename> struct __is_floating_point_helper : public false_type
  {
  };
  template <>
  struct __is_floating_point_helper<float>
      : public integral_constant<bool, true>
  {
  };
  template <>
  struct __is_floating_point_helper<double>
      : public integral_constant<bool, true>
  {
  };
  template <>
  struct __is_floating_point_helper<long double>
      : public integral_constant<bool, true>
  {
  };
  template <typename _Tp>
  struct is_floating_point
      : public integral_constant<bool,
                                 (__is_floating_point_helper<
                                     typename remove_cv<_Tp>::type>::value)>
  {
  };
  template <typename> struct is_array : public false_type
  {
  };
  template <typename _Tp, std::size_t _Size>
  struct is_array<_Tp[_Size]> : public true_type
  {
  };
  template <typename _Tp> struct is_array<_Tp[]> : public true_type
  {
  };
  template <typename> struct __is_pointer_helper : public false_type
  {
  };
  template <typename _Tp>
  struct __is_pointer_helper<_Tp *> : public integral_constant<bool, true>
  {
  };
  template <typename _Tp>
  struct is_pointer
      : public integral_constant<bool,
                                 (__is_pointer_helper<
                                     typename remove_cv<_Tp>::type>::value)>
  {
  };
  template <typename _Tp> struct is_reference;
  template <typename _Tp> struct is_function;
  template <typename>
  struct __is_member_object_pointer_helper : public false_type
  {
  };
  template <typename _Tp, typename _Cp>
  struct __is_member_object_pointer_helper<_Tp _Cp::*>
      : public integral_constant<bool, !is_function<_Tp>::value>
  {
  };
  template <typename _Tp>
  struct is_member_object_pointer
      : public integral_constant<bool,
                                 (__is_member_object_pointer_helper<
                                     typename remove_cv<_Tp>::type>::value)>
  {
  };
  template <typename>
  struct __is_member_function_pointer_helper : public false_type
  {
  };
  template <typename _Tp, typename _Cp>
  struct __is_member_function_pointer_helper<_Tp _Cp::*>
      : public integral_constant<bool, is_function<_Tp>::value>
  {
  };
  template <typename _Tp>
  struct is_member_function_pointer
      : public integral_constant<bool,
                                 (__is_member_function_pointer_helper<
                                     typename remove_cv<_Tp>::type>::value)>
  {
  };
  template <typename _Tp>
  struct is_enum : public integral_constant<bool, __is_enum(_Tp)>
  {
  };
  template <typename _Res, typename... _ArgTypes>
  struct is_function<_Res (_ArgTypes...) volatile> : public true_type
  {
  };
  template <typename _Res, typename... _ArgTypes>
  struct is_function<_Res (_ArgTypes......) volatile> : public true_type
  {
  };
  template <typename _Res, typename... _ArgTypes>
  struct is_function<_Res (_ArgTypes...) const volatile> : public true_type
  {
  };
  template <typename _Res, typename... _ArgTypes>
  struct is_function<_Res (_ArgTypes......) const volatile> : public true_type
  {
  };
  template <typename _Tp>
  struct is_arithmetic
      : public integral_constant<bool, (is_integral<_Tp>::value
                                        || is_floating_point<_Tp>::value)>
  {
  };
  template <typename _Tp>
  struct is_fundamental
      : public integral_constant<bool, (is_arithmetic<_Tp>::value
                                        || is_void<_Tp>::value)>
  {
  };
  template <typename _Tp>
  struct is_object
      : public integral_constant<bool, !(is_function<_Tp>::value
                                         || is_reference<_Tp>::value
                                         || is_void<_Tp>::value)>
  {
  };
  template <typename _Tp> struct is_member_pointer;
  template <typename _Tp>
  struct is_scalar
      : public integral_constant<bool, (is_arithmetic<_Tp>::value
                                        || is_enum<_Tp>::value
                                        || is_pointer<_Tp>::value
                                        || is_member_pointer<_Tp>::value)>
  {
  };
  template <typename _Tp>
  struct is_compound
      : public integral_constant<bool, !is_fundamental<_Tp>::value>
  {
  };
  template <typename _Tp> struct __is_member_pointer_helper : public false_type
  {
  };
  template <typename _Tp, typename _Cp>
  struct __is_member_pointer_helper<_Tp _Cp::*>
      : public integral_constant<bool, true>
  {
  };
  template <typename _Tp>
  struct is_member_pointer
      : public integral_constant<bool,
                                 (__is_member_pointer_helper<
                                     typename remove_cv<_Tp>::type>::value)>
  {
  };
  template <typename> struct is_const : public false_type
  {
  };
  template <typename _Tp> struct is_const<_Tp const> : public true_type
  {
  };
  template <typename> struct is_volatile : public false_type
  {
  };
  template <typename _Tp> struct is_volatile<_Tp volatile> : public true_type
  {
  };
  template <typename _Tp>
  struct is_empty : public integral_constant<bool, __is_empty(_Tp)>
  {
  };
  template <typename _Tp>
  struct is_polymorphic : public integral_constant<bool, __is_polymorphic(_Tp)>
  {
  };
  template <typename _Tp>
  struct is_abstract : public integral_constant<bool, __is_abstract(_Tp)>
  {
  };
  template <typename _Tp>
  struct has_virtual_destructor
      : public integral_constant<bool, __has_virtual_destructor(_Tp)>
  {
  };
  template <typename, typename> struct is_same : public false_type
  {
  };
  template <typename _Tp> struct is_same<_Tp, _Tp> : public true_type
  {
  };
  template <typename _Tp> struct remove_const
  {
    typedef _Tp type;
  };
  template <typename _Tp> struct remove_const<_Tp const>
  {
    typedef _Tp type;
  };
  template <typename _Tp> struct remove_volatile
  {
    typedef _Tp type;
  };
  template <typename _Tp> struct remove_volatile<_Tp volatile>
  {
    typedef _Tp type;
  };
  template <typename _Tp> struct remove_cv
  {
    typedef
        typename remove_const<typename remove_volatile<_Tp>::type>::type type;
  };
  template <typename _Tp> struct add_const
  {
    typedef _Tp const type;
  };
  template <typename _Tp> struct add_volatile
  {
    typedef _Tp volatile type;
  };
  template <typename _Tp> struct add_cv
  {
    typedef typename add_const<typename add_volatile<_Tp>::type>::type type;
  };
  template <typename _Tp> struct remove_extent
  {
    typedef _Tp type;
  };
  template <typename _Tp, std::size_t _Size> struct remove_extent<_Tp[_Size]>
  {
    typedef _Tp type;
  };
  template <typename _Tp> struct remove_extent<_Tp[]>
  {
    typedef _Tp type;
  };
  template <typename _Tp> struct remove_all_extents
  {
    typedef _Tp type;
  };
  template <typename _Tp, std::size_t _Size>
  struct remove_all_extents<_Tp[_Size]>
  {
    typedef typename remove_all_extents<_Tp>::type type;
  };
  template <typename _Tp> struct remove_all_extents<_Tp[]>
  {
    typedef typename remove_all_extents<_Tp>::type type;
  };
  template <typename _Tp, typename> struct __remove_pointer_helper
  {
    typedef _Tp type;
  };
  template <typename _Tp, typename _Up>
  struct __remove_pointer_helper<_Tp, _Up *>
  {
    typedef _Up type;
  };
  template <typename _Tp>
  struct remove_pointer
      : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
  {
  };
  template <typename> struct remove_reference;
  template <typename _Tp> struct add_pointer
  {
    typedef typename remove_reference<_Tp>::type *type;
  };
  template <typename> struct is_reference : public false_type
  {
  };
  template <typename _Tp> struct is_reference<_Tp &> : public true_type
  {
  };
  template <typename _Tp>
  struct is_pod
      : public integral_constant<bool, __is_pod(_Tp) || is_void<_Tp>::value>
  {
  };
  template <typename _Tp>
  struct has_trivial_constructor
      : public integral_constant<bool, is_pod<_Tp>::value>
  {
  };
  template <typename _Tp>
  struct has_trivial_copy : public integral_constant<bool, is_pod<_Tp>::value>
  {
  };
  template <typename _Tp>
  struct has_nothrow_assign
      : public integral_constant<bool, is_pod<_Tp>::value>
  {
  };
  template <typename> struct __is_signed_helper : public false_type
  {
  };
  template <>
  struct __is_signed_helper<signed char> : public integral_constant<bool, true>
  {
  };
  template <>
  struct __is_signed_helper<short> : public integral_constant<bool, true>
  {
  };
  template <typename> struct __is_unsigned_helper : public false_type
  {
  };
  template <>
  struct __is_unsigned_helper<unsigned char>
      : public integral_constant<bool, true>
  {
  };
  template <>
  struct __is_unsigned_helper<unsigned short>
      : public integral_constant<bool, true>
  {
  };
  template <>
  struct __is_unsigned_helper<unsigned int>
      : public integral_constant<bool, true>
  {
  };
  template <>
  struct __is_unsigned_helper<unsigned long>
      : public integral_constant<bool, true>
  {
  };
  template <>
  struct __is_unsigned_helper<unsigned long long>
      : public integral_constant<bool, true>
  {
  };
  template <typename _Tp>
  struct is_unsigned
      : public integral_constant<bool,
                                 (__is_unsigned_helper<
                                     typename remove_cv<_Tp>::type>::value)>
  {
  };
  template <typename _Base, typename _Derived> struct __is_base_of_helper
  {
    typedef typename remove_cv<_Base>::type _NoCv_Base;
    typedef typename remove_cv<_Derived>::type _NoCv_Derived;
    static const bool __value
        = (is_same<_Base, _Derived>::value
           || (__is_base_of(_Base, _Derived)
               && !is_same<_NoCv_Base, _NoCv_Derived>::value));
  };
  template <typename _Base, typename _Derived>
  struct is_base_of
      : public integral_constant<bool,
                                 __is_base_of_helper<_Base, _Derived>::__value>
  {
  };
  template <typename _From, typename _To>
  struct __is_convertible_simple : public __sfinae_types
  {
  private:
    ;
    ;
    static _From __makeFrom ();
  public:
    static const bool __value = sizeof (__test (__makeFrom ())) == 1;
  };
  template <typename _Tp> struct add_reference;
  template <typename _Tp> struct __is_int_or_cref
  {
    typedef typename remove_reference<_Tp>::type __rr_Tp;
    static const bool __value
        = (is_integral<_Tp>::value
           || (is_integral<__rr_Tp>::value && is_const<__rr_Tp>::value
               && !is_volatile<__rr_Tp>::value));
  };
  template <
      typename _From, typename _To,
      bool
      = (is_void<_From>::value || is_void<_To>::value
         || is_function<_To>::value || is_array<_To>::value
         || (is_floating_point<typename remove_reference<_From>::type>::value
             && __is_int_or_cref<_To>::__value))>
  struct __is_convertible_helper
  {
    static const bool __value
        = (__is_convertible_simple<typename add_reference<_From>::type,
                                   _To>::__value);
  };
  template <typename _From, typename _To>
  struct __is_convertible_helper<_From, _To, true>
  {
    static const bool __value
        = (is_void<_To>::value
           || (__is_int_or_cref<_To>::__value && !is_void<_From>::value));
  };
  template <typename _From, typename _To>
  struct is_convertible
      : public integral_constant<bool,
                                 __is_convertible_helper<_From, _To>::__value>
  {
  };
  template <typename _Tp> struct remove_reference
  {
    typedef _Tp type;
  };
  template <std::size_t _Len, std::size_t _Align> struct aligned_storage
  {
    union type
    {
      unsigned char __data[_Len];
      struct __attribute__ ((__aligned__ ((_Align))))
      {
      } __align;
    };
  };
  }
}
namespace __gnu_pbds
{
namespace detail
{
using std::tr1::is_same;
using std::tr1::is_const;
using std::tr1::is_pointer;
using std::tr1::is_reference;
using std::tr1::is_fundamental;
using std::tr1::is_member_object_pointer;
using std::tr1::is_member_pointer;
using std::tr1::is_base_of;
using std::tr1::remove_const;
using std::tr1::remove_reference;
using std::tr1::integral_constant;
typedef std::tr1::integral_constant<int, 1> true_type;
typedef std::tr1::integral_constant<int, 0> false_type;
using __gnu_cxx::__conditional_type;
using __gnu_cxx::__numeric_traits;
template <typename T> struct is_const_pointer
{
  enum
  {
    value = is_const<T>::value && is_pointer<T>::value
  };
};
template <typename T> struct is_const_reference
{
  enum
  {
    value = is_const<T>::value && is_reference<T>::value
  };
};
template <typename T> struct is_simple
{
  enum
  {
    value = is_fundamental<typename remove_const<T>::type>::value
            || is_pointer<typename remove_const<T>::type>::value
            || is_member_pointer<T>::value
  };
};
template <typename T> class is_pair
{
private:
  template <typename U> struct is_pair_imp
  {
    enum
    {
      value = 0
    };
  };
  template <typename U, typename V> struct is_pair_imp<std::pair<U, V> >
  {
    enum
    {
      value = 1
    };
  };
public:
  enum
  {
    value = is_pair_imp<T>::value
  };
};
template <bool> struct __static_assert;
template <> struct __static_assert<true>
{
};
template <int> struct __static_assert_dumclass
{
  enum
  {
    v = 1
  };
};
template <typename Type> struct type_to_type
{
  typedef Type type;
};
}
struct trivial_iterator_tag
{
};
typedef void trivial_iterator_difference_type;
struct basic_invalidation_guarantee
{
};
struct point_invalidation_guarantee : public basic_invalidation_guarantee
{
};
struct range_invalidation_guarantee : public point_invalidation_guarantee
{
};
struct container_tag
{
};
struct sequence_tag : public container_tag
{
};
struct associative_tag : public container_tag
{
};
struct basic_hash_tag : public associative_tag
{
};
struct cc_hash_tag : public basic_hash_tag
{
};
struct gp_hash_tag : public basic_hash_tag
{
};
struct basic_branch_tag : public associative_tag
{
};
struct tree_tag : public basic_branch_tag
{
};
struct rb_tree_tag : public tree_tag
{
};
struct splay_tree_tag : public tree_tag
{
};
struct ov_tree_tag : public tree_tag
{
};
struct trie_tag : public basic_branch_tag
{
};
struct pat_trie_tag : public trie_tag
{
};
struct list_update_tag : public associative_tag
{
};
struct priority_queue_tag : public container_tag
{
};
struct pairing_heap_tag : public priority_queue_tag
{
};
struct binomial_heap_tag : public priority_queue_tag
{
};
struct rc_binomial_heap_tag : public priority_queue_tag
{
};
struct binary_heap_tag : public priority_queue_tag
{
};
struct thin_heap_tag : public priority_queue_tag
{
};
struct null_type
{
};
template <typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>
struct null_node_update : public null_type
{
};
template <typename _Tag> struct container_traits_base;
template <> struct container_traits_base<rb_tree_tag>
{
  typedef rb_tree_tag container_category;
  typedef range_invalidation_guarantee invalidation_guarantee;
  enum
  {
    order_preserving = true,
    erase_can_throw = false,
    split_join_can_throw = false,
    reverse_iteration = true
  };
};
template <> struct container_traits_base<splay_tree_tag>
{
  typedef splay_tree_tag container_category;
  typedef range_invalidation_guarantee invalidation_guarantee;
  enum
  {
    order_preserving = true,
    erase_can_throw = false,
    split_join_can_throw = false,
    reverse_iteration = true
  };
};
template <> struct container_traits_base<ov_tree_tag>
{
  typedef ov_tree_tag container_category;
  typedef basic_invalidation_guarantee invalidation_guarantee;
  enum
  {
    order_preserving = true,
    erase_can_throw = true,
    split_join_can_throw = true,
    reverse_iteration = false
  };
};
template <typename Cntnr>
struct container_traits
    : public container_traits_base<typename Cntnr::container_category>
{
  typedef Cntnr container_type;
};
namespace detail
{
template <typename Key, typename Mapped, typename _Alloc, typename Tag,
          typename Policy_Tl = null_type>
struct container_base_dispatch;
}
struct container_error : public std::logic_error
{
  container_error () : std::logic_error (("__gnu_pbds::container_error")) {}
};
struct insert_error : public container_error
{
};
struct join_error : public container_error
{
};
inline void
__throw_join_error ()
{
  (throw (join_error ()));
}
namespace detail
{
template <typename Size_Type> class mask_based_range_hashing
{
protected:
  typedef Size_Type size_type;
  ;
private:
  size_type m_mask;
  const static size_type s_num_bits_in_size_type;
  const static size_type s_highest_bit_1;
};
template <typename Size_Type> class mod_based_range_hashing
{
protected:
  typedef Size_Type size_type;
  ;
  ;
  ;
private:
  size_type m_size;
};
}
namespace detail
{
template <typename Size_Type, bool Hold_Size>
class hash_load_check_resize_trigger_size_base;
template <typename Size_Type>
class hash_load_check_resize_trigger_size_base<Size_Type, true>
{
protected:
  typedef Size_Type size_type;
  ;
  ;
  ;
  ;
private:
  size_type m_size;
};
template <typename Size_Type>
class hash_load_check_resize_trigger_size_base<Size_Type, false>
{
protected:
  typedef Size_Type size_type;
protected:
  ;
  ;
};
}
template <typename Size_Type = std::size_t> class linear_probe_fn
{
public:
  typedef Size_Type size_type;
  ;

protected:
  ;
};
template <typename Size_Type = std::size_t> class quadratic_probe_fn
{
public:
  typedef Size_Type size_type;
  ;

protected:
  ;
};
template <typename Size_Type = std::size_t>
class direct_mask_range_hashing
    : public detail::mask_based_range_hashing<Size_Type>
{
private:
  typedef detail::mask_based_range_hashing<Size_Type> mask_based_base;

public:
  typedef Size_Type size_type;
  ;

protected:
  ;
  ;
};
template <typename Size_Type = std::size_t>
class direct_mod_range_hashing
    : public detail::mod_based_range_hashing<Size_Type>
{
public:
  typedef Size_Type size_type;
  ;

protected:
  ;
  ;

private:
  typedef detail::mod_based_range_hashing<size_type> mod_based_base;
};
template <bool External_Load_Access = false, typename Size_Type = std::size_t>
class hash_load_check_resize_trigger
    : private detail::
          hash_load_check_resize_trigger_size_base<Size_Type,
                                                   External_Load_Access>
{
  bool m_resize_needed;
};
template <bool External_Load_Access = false, typename Size_Type = std::size_t>
class cc_hash_max_collision_check_resize_trigger
{
public:
  typedef Size_Type size_type;
};
template <typename Size_Type = std::size_t> class hash_exponential_size_policy
{
public:
  typedef Size_Type size_type;
  ;
  size_type m_grow_factor;
};
class hash_prime_size_policy
{
public:
  typedef std::size_t size_type;

private:
  size_type m_start_size;
};
template <typename Size_Policy = hash_exponential_size_policy<>,
          typename Trigger_Policy = hash_load_check_resize_trigger<>,
          bool External_Size_Access = false, typename Size_Type = std::size_t>
class hash_standard_resize_policy : public Size_Policy, public Trigger_Policy
{
public:
  typedef Size_Type size_type;
  typedef Size_Policy size_policy_base;
  size_type m_size;
};
namespace detail
{
template <typename Size_Type> class lu_counter_policy_base;
template <typename Size_Type = std::size_t> class lu_counter_metadata
{
public:
  typedef Size_Type size_type;
private:
  ;
  friend class lu_counter_policy_base<size_type>;
  mutable size_type m_count;
};
template <typename Size_Type> class lu_counter_policy_base
{
protected:
  typedef Size_Type size_type;
  ;
  ;
};
}
template <typename _Alloc = std::allocator<char> >
class lu_move_to_front_policy
{
public:
  typedef _Alloc allocator_type;
  typedef null_type metadata_type;

private:
  typedef typename _Alloc::template rebind<metadata_type> __rebind_m;
};
template <std::size_t Max_Count = 5, typename _Alloc = std::allocator<char> >
class lu_counter_policy
    : private detail::lu_counter_policy_base<typename _Alloc::size_type>
{
public:
  typedef _Alloc allocator_type;
  ;
};
namespace detail
{
template <typename Key, typename Mapped> struct no_throw_copies
{
  static const bool __simple = is_simple<Key>::value
                               && is_simple<Mapped>::value;
  typedef integral_constant<int, __simple> indicator;
};
template <typename Key> struct no_throw_copies<Key, null_type>
{
  typedef integral_constant<int, is_simple<Key>::value> indicator;
};
template <typename _Tv> struct stored_value
{
  typedef _Tv value_type;
  value_type m_value;
};
template <typename _Th> struct stored_hash
{
  typedef _Th hash_type;
  hash_type m_hash;
};
template <typename _Tv, typename _Th>
struct stored_data : public stored_value<_Tv>, public stored_hash<_Th>
{
};
template <typename _Tv>
struct stored_data<_Tv, null_type> : public stored_value<_Tv>
{
};
template <typename Key, typename Mapped, typename _Alloc, bool Store_Hash>
struct type_base;
template <typename Key, typename Mapped, typename _Alloc>
struct type_base<Key, Mapped, _Alloc, false>
{
public:
  typedef typename _Alloc::size_type size_type;
private:
  typedef typename _Alloc::template rebind<Mapped> __rebind_m;
  typedef typename __rebind_m::other __rebind_ma;
  typedef std::pair<const Key, Mapped> __value_type;
  typedef typename _Alloc::template rebind<__value_type> __rebind_v;
  typedef typename __rebind_v::other __rebind_va;
public:
  typedef typename __rebind_ma::value_type mapped_type;
  typedef typename __rebind_ma::pointer mapped_pointer;
  typedef typename __rebind_ma::const_pointer mapped_const_pointer;
  typedef typename __rebind_ma::reference mapped_reference;
  typedef typename __rebind_ma::const_reference mapped_const_reference;
  typedef typename __rebind_va::value_type value_type;
  typedef typename __rebind_va::pointer pointer;
  typedef typename __rebind_va::const_pointer const_pointer;
  typedef typename __rebind_va::reference reference;
  typedef typename __rebind_va::const_reference const_reference;
  typedef stored_data<value_type, null_type> stored_data_type;
};
template <typename Key, typename Mapped, typename _Alloc>
struct type_base<Key, Mapped, _Alloc, true>
{
public:
  typedef typename _Alloc::size_type size_type;
private:
  typedef typename _Alloc::template rebind<Mapped> __rebind_m;
  typedef typename __rebind_m::other __rebind_ma;
  typedef std::pair<const Key, Mapped> __value_type;
  typedef typename _Alloc::template rebind<__value_type> __rebind_v;
  typedef typename __rebind_v::other __rebind_va;
public:
  typedef typename __rebind_ma::value_type mapped_type;
  typedef typename __rebind_ma::pointer mapped_pointer;
  typedef typename __rebind_ma::const_pointer mapped_const_pointer;
  typedef typename __rebind_ma::reference mapped_reference;
  typedef typename __rebind_ma::const_reference mapped_const_reference;
  typedef typename __rebind_va::value_type value_type;
  typedef typename __rebind_va::pointer pointer;
  typedef typename __rebind_va::const_pointer const_pointer;
  typedef typename __rebind_va::reference reference;
  typedef typename __rebind_va::const_reference const_reference;
  typedef stored_data<value_type, size_type> stored_data_type;
};
template <typename Key, typename _Alloc>
struct type_base<Key, null_type, _Alloc, false>
{
public:
  typedef typename _Alloc::size_type size_type;
  typedef Key value_type;
private:
  typedef typename _Alloc::template rebind<null_type> __rebind_m;
  typedef typename __rebind_m::other __rebind_ma;
  typedef typename _Alloc::template rebind<value_type> __rebind_v;
  typedef typename __rebind_v::other __rebind_va;
public:
  typedef typename __rebind_ma::value_type mapped_type;
  typedef typename __rebind_ma::pointer mapped_pointer;
  typedef typename __rebind_ma::const_pointer mapped_const_pointer;
  typedef typename __rebind_ma::reference mapped_reference;
  typedef typename __rebind_ma::const_reference mapped_const_reference;
  typedef typename __rebind_va::pointer pointer;
  typedef typename __rebind_va::const_pointer const_pointer;
  typedef typename __rebind_va::reference reference;
  typedef typename __rebind_va::const_reference const_reference;
  typedef stored_data<value_type, null_type> stored_data_type;
  static null_type s_null_type;
};
template <typename Key, typename _Alloc>
null_type type_base<Key, null_type, _Alloc, false>::s_null_type;
template <typename Key, typename _Alloc>
struct type_base<Key, null_type, _Alloc, true>
{
public:
  typedef typename _Alloc::size_type size_type;
  typedef Key value_type;
private:
  typedef typename _Alloc::template rebind<null_type> __rebind_m;
  typedef typename __rebind_m::other __rebind_ma;
  typedef typename _Alloc::template rebind<value_type> __rebind_v;
  typedef typename __rebind_v::other __rebind_va;
public:
  typedef typename __rebind_ma::value_type mapped_type;
  typedef typename __rebind_ma::pointer mapped_pointer;
  typedef typename __rebind_ma::const_pointer mapped_const_pointer;
  typedef typename __rebind_ma::reference mapped_reference;
  typedef typename __rebind_ma::const_reference mapped_const_reference;
  typedef typename __rebind_va::pointer pointer;
  typedef typename __rebind_va::const_pointer const_pointer;
  typedef typename __rebind_va::reference reference;
  typedef typename __rebind_va::const_reference const_reference;
  typedef stored_data<value_type, size_type> stored_data_type;
  static null_type s_null_type;
};
template <typename Key, typename _Alloc>
null_type type_base<Key, null_type, _Alloc, true>::s_null_type;
template <typename Key, typename Mapped, typename _Alloc, bool Store_Hash>
struct type_dispatch
{
  typedef type_base<Key, Mapped, _Alloc, Store_Hash> type;
};
template <typename Key, typename Mapped, typename _Alloc, bool Store_Hash>
struct types_traits
    : public type_dispatch<Key, Mapped, _Alloc, Store_Hash>::type
{
private:
  typedef no_throw_copies<Key, Mapped> __nothrowcopy;
  typedef typename _Alloc::template rebind<Key>::other __rebind_a;
public:
  typedef typename _Alloc::size_type size_type;
  typedef typename __rebind_a::value_type key_type;
  typedef typename __rebind_a::pointer key_pointer;
  typedef typename __rebind_a::const_pointer key_const_pointer;
  typedef typename __rebind_a::reference key_reference;
  typedef typename __rebind_a::const_reference key_const_reference;
  typedef std::pair<size_type, size_type> comp_hash;
  typedef integral_constant<int, Store_Hash> store_extra;
  typedef typename __nothrowcopy::indicator no_throw_indicator;
  store_extra m_store_extra_indicator;
  no_throw_indicator m_no_throw_copies_indicator;
};
}
namespace detail
{
template <typename Key, typename Data, typename _Alloc>
struct dumnode_const_iterator
{
private:
  typedef types_traits<Key, Data, _Alloc, false> __traits_type;
  typedef typename __traits_type::pointer const_iterator;
public:
  typedef const_iterator value_type;
  typedef const_iterator const_reference;
  typedef const_reference reference;
};
}
namespace detail
{
template <typename Node_CItr, typename Node_Itr, typename _Alloc>
struct branch_policy
{
protected:
  typedef typename Node_Itr::value_type it_type;
  typedef typename std::iterator_traits<it_type>::value_type value_type;
  typedef typename value_type::first_type key_type;
  typedef typename remove_const<value_type>::type rcvalue_type;
  typedef typename remove_const<key_type>::type rckey_type;
  typedef typename _Alloc::template rebind<rcvalue_type>::other rebind_v;
  typedef typename _Alloc::template rebind<rckey_type>::other rebind_k;
  typedef typename rebind_v::reference reference;
  typedef typename rebind_v::const_reference const_reference;
  typedef typename rebind_v::const_pointer const_pointer;
  typedef typename rebind_k::const_reference key_const_reference;
  static inline key_const_reference
  extract_key (const_reference r_val)
  {
    return r_val.first;
  }
  virtual it_type end () = 0;
  it_type
  end_iterator () const
  {
    return const_cast<branch_policy *> (this)->end ();
  }
  virtual ~branch_policy () {}
};
template <typename Node_CItr, typename _Alloc>
struct branch_policy<Node_CItr, Node_CItr, _Alloc>
{
protected:
  typedef typename Node_CItr::value_type it_type;
  typedef typename std::iterator_traits<it_type>::value_type value_type;
  typedef typename remove_const<value_type>::type rcvalue_type;
  typedef typename _Alloc::template rebind<rcvalue_type>::other rebind_v;
  typedef typename rebind_v::reference reference;
  typedef typename rebind_v::const_reference const_reference;
  typedef typename rebind_v::const_pointer const_pointer;
  typedef value_type key_type;
  typedef typename rebind_v::const_reference key_const_reference;
  virtual it_type end () const = 0;
};
}
template <typename Node_CItr, typename Node_Itr, typename Cmp_Fn,
          typename _Alloc>
class tree_order_statistics_node_update
    : private detail::branch_policy<Node_CItr, Node_Itr, _Alloc>
{
private:
  typedef detail::branch_policy<Node_CItr, Node_Itr, _Alloc> base_type;

public:
  typedef Cmp_Fn cmp_fn;
  typedef _Alloc allocator_type;
  typedef typename allocator_type::size_type size_type;
  typedef typename base_type::key_type key_type;
  typedef typename base_type::key_const_reference key_const_reference;
  typedef size_type metadata_type;
  typedef Node_CItr node_const_iterator;
  typedef Node_Itr node_iterator;
  typedef typename node_const_iterator::value_type const_iterator;
  typedef typename node_iterator::value_type iterator;
  inline const_iterator find_by_order (size_type) const;
  inline iterator find_by_order (size_type);
  inline size_type order_of_key (key_const_reference) const;

private:
  typedef typename base_type::const_reference const_reference;
  typedef typename base_type::const_pointer const_pointer;
  typedef typename _Alloc::template rebind<metadata_type>::other __rebind_m;
  typedef typename __rebind_m::const_reference metadata_const_reference;
  typedef typename __rebind_m::reference metadata_reference;
  virtual node_const_iterator node_begin () const = 0;
  virtual node_iterator node_begin () = 0;
  virtual node_const_iterator node_end () const = 0;
  virtual node_iterator node_end () = 0;
  virtual cmp_fn &get_cmp_fn () = 0;

protected:
  inline void operator()(node_iterator, node_const_iterator) const;
  virtual ~tree_order_statistics_node_update ();
};
template <typename Node_CItr, typename Node_Itr, typename Cmp_Fn,
          typename _Alloc>
inline typename tree_order_statistics_node_update<Node_CItr, Node_Itr, Cmp_Fn,
                                                  _Alloc>::iterator
tree_order_statistics_node_update<Node_CItr, Node_Itr, Cmp_Fn,
                                  _Alloc>::find_by_order (size_type order)
{
  node_iterator it = node_begin ();
  node_iterator end_it = node_end ();
  while (it != end_it)
    {
      node_iterator l_it = it.get_l_child ();
      const size_type o = (l_it == end_it) ? 0 : l_it.get_metadata ();
      if (order == o)
        return *it;
      else if (order < o)
        it = l_it;
      else
        {
          order -= o + 1;
          it = it.get_r_child ();
        }
    }
  return base_type::end_iterator ();
}
template <typename Node_CItr, typename Node_Itr, typename Cmp_Fn,
          typename _Alloc>
inline typename tree_order_statistics_node_update<Node_CItr, Node_Itr, Cmp_Fn,
                                                  _Alloc>::const_iterator
tree_order_statistics_node_update<Node_CItr, Node_Itr, Cmp_Fn,
                                  _Alloc>::find_by_order (size_type order)
    const
{
  return const_cast<tree_order_statistics_node_update<Node_CItr, Node_Itr,
                                                      Cmp_Fn, _Alloc> *> (this)
      ->find_by_order (order);
}
template <typename Node_CItr, typename Node_Itr, typename Cmp_Fn,
          typename _Alloc>
inline typename tree_order_statistics_node_update<Node_CItr, Node_Itr, Cmp_Fn,
                                                  _Alloc>::size_type
tree_order_statistics_node_update<Node_CItr, Node_Itr, Cmp_Fn,
                                  _Alloc>::order_of_key (key_const_reference
                                                             r_key) const
{
  node_const_iterator it = node_begin ();
  node_const_iterator end_it = node_end ();
  const cmp_fn &r_cmp_fn
      = const_cast<tree_order_statistics_node_update<Node_CItr, Node_Itr,
                                                     Cmp_Fn, _Alloc> *> (this)
            ->get_cmp_fn ();
  size_type ord = 0;
  while (it != end_it)
    {
      node_const_iterator l_it = it.get_l_child ();
      if (r_cmp_fn (r_key, this->extract_key (*(*it))))
        it = l_it;
      else if (r_cmp_fn (this->extract_key (*(*it)), r_key))
        {
          ord += (l_it == end_it) ? 1 : 1 + l_it.get_metadata ();
          it = it.get_r_child ();
        }
      else
        {
          ord += (l_it == end_it) ? 0 : l_it.get_metadata ();
          it = end_it;
        }
    }
  return ord;
}
template <typename Node_CItr, typename Node_Itr, typename Cmp_Fn,
          typename _Alloc>
inline void
    tree_order_statistics_node_update<Node_CItr, Node_Itr, Cmp_Fn, _Alloc>::
    operator()(node_iterator node_it, node_const_iterator end_nd_it) const
{
  node_iterator l_it = node_it.get_l_child ();
}
template <typename Node_CItr, typename Node_Itr, typename Cmp_Fn,
          typename _Alloc>
tree_order_statistics_node_update<Node_CItr, Node_Itr, Cmp_Fn, _Alloc>::
    ~tree_order_statistics_node_update ()
{
}
namespace detail
{
template <typename Node_CItr, typename Node_Itr, typename _ATraits,
          typename _Alloc>
class trie_policy_base : public branch_policy<Node_CItr, Node_Itr, _Alloc>
{
  typedef branch_policy<Node_CItr, Node_Itr, _Alloc> base_type;
public:
  typedef _ATraits access_traits;
  typedef _Alloc allocator_type;
  typedef typename allocator_type::size_type size_type;
  typedef null_type metadata_type;
  typedef Node_CItr node_const_iterator;
  typedef Node_Itr node_iterator;
  typedef typename node_const_iterator::value_type const_iterator;
  typedef typename node_iterator::value_type iterator;
  typedef typename base_type::key_type key_type;
  typedef typename base_type::key_const_reference key_const_reference;
protected:
  ;
  ;
  ;
  ;
  ;
  ;
  ;
private:
  typedef typename access_traits::const_iterator e_const_iterator;
  typedef std::pair<e_const_iterator, e_const_iterator> prefix_range_t;
protected:
  ;
  static iterator leftmost_it (node_iterator);
  static iterator rightmost_it (node_iterator);
  ;
};
template <typename Node_CItr, typename Node_Itr, typename _ATraits,
          typename _Alloc>
typename trie_policy_base<Node_CItr, Node_Itr, _ATraits, _Alloc>::iterator
trie_policy_base<Node_CItr, Node_Itr, _ATraits, _Alloc>::leftmost_it (
    node_iterator nd_it)
{
  if (nd_it.num_children () == 0)
    return *nd_it;
  return leftmost_it (nd_it.get_child (0));
}
template <typename Node_CItr, typename Node_Itr, typename _ATraits,
          typename _Alloc>
typename trie_policy_base<Node_CItr, Node_Itr, _ATraits, _Alloc>::iterator
trie_policy_base<Node_CItr, Node_Itr, _ATraits, _Alloc>::rightmost_it (
    node_iterator nd_it)
{
  const size_type num_children = nd_it.num_children ();
  if (num_children == 0)
    return *nd_it;
  return rightmost_it (nd_it.get_child (num_children - 1));
}
}
template <typename String = std::string,
          typename String::value_type Min_E_Val
          = detail::__numeric_traits<typename String::value_type>::__min,
          typename String::value_type Max_E_Val
          = detail::__numeric_traits<typename String::value_type>::__max,
          bool Reverse = false, typename _Alloc = std::allocator<char> >
struct trie_string_access_traits
{
public:
  typedef typename _Alloc::size_type size_type;
  typedef String key_type;
  typedef typename _Alloc::template rebind<key_type> __rebind_k;
  ;
  ;
  static detail::integral_constant<int, Reverse> s_rev_ind;
};
template <typename Node_CItr, typename Node_Itr, typename _ATraits,
          typename _Alloc>
class trie_prefix_search_node_update
    : private detail::trie_policy_base<Node_CItr, Node_Itr, _ATraits, _Alloc>
{
  ;
  ;
  ;
  ;
  ;
};
template <typename Node_CItr, typename Node_Itr, typename _ATraits,
          typename _Alloc>
class trie_order_statistics_node_update
    : private detail::trie_policy_base<Node_CItr, Node_Itr, _ATraits, _Alloc>
{
private:
  typedef detail::trie_policy_base<Node_CItr, Node_Itr, _ATraits, _Alloc>
      base_type;

public:
  typedef _ATraits access_traits;
  typedef typename access_traits::const_iterator a_const_iterator;
  typedef _Alloc allocator_type;
  ;

protected:
  ;
  ;
};
}
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace tr1
  {
  template <typename _Tp> struct hash : public std::unary_function<_Tp, size_t>
  {
    size_t operator()(_Tp __val) const;
  };
  template <>
  __attribute__ ((__pure__)) size_t hash<wstring>::operator()(wstring) const;
  template <>
  __attribute__ ((__pure__)) size_t hash<const wstring &>::
  operator()(const wstring &) const;
  }
}
namespace __gnu_pbds
{
namespace detail
{
template <typename Key> struct default_hash_fn
{
  typedef std::tr1::hash<Key> type;
};
template <typename Key> struct default_eq_fn
{
  typedef std::equal_to<Key> type;
};
enum
{
  default_store_hash = false
};
struct default_comb_hash_fn
{
  typedef direct_mask_range_hashing<> type;
};
template <typename Comb_Hash_Fn> struct default_resize_policy
{
private:
  typedef typename Comb_Hash_Fn::size_type size_type;
  typedef direct_mask_range_hashing<size_type> default_fn;
  typedef is_same<default_fn, Comb_Hash_Fn> same_type;
  typedef hash_exponential_size_policy<size_type> iftrue;
  typedef hash_prime_size_policy iffalse;
  typedef __conditional_type<same_type::value, iftrue, iffalse> cond_type;
  typedef typename cond_type::__type size_policy_type;
  typedef hash_load_check_resize_trigger<false, size_type> trigger;
public:
  typedef hash_standard_resize_policy<size_policy_type, trigger, false,
                                      size_type> type;
};
struct default_update_policy
{
  typedef lu_move_to_front_policy<> type;
};
template <typename Comb_Probe_Fn> struct default_probe_fn
{
private:
  typedef typename Comb_Probe_Fn::size_type size_type;
  typedef direct_mask_range_hashing<size_type> default_fn;
  typedef is_same<default_fn, Comb_Probe_Fn> same_type;
  typedef linear_probe_fn<size_type> iftrue;
  typedef quadratic_probe_fn<size_type> iffalse;
  typedef __conditional_type<same_type::value, iftrue, iffalse> cond_type;
public:
  typedef typename cond_type::__type type;
};
template <typename Key> struct default_trie_access_traits;
template <typename Char, typename Char_Traits>
struct default_trie_access_traits<std::basic_string<Char, Char_Traits,
                                                    std::allocator<char> > >
{
private:
  typedef std::basic_string<Char, Char_Traits, std::allocator<char> >
      string_type;
public:
  typedef trie_string_access_traits<string_type> type;
};
}
namespace detail
{
template <typename Entry, typename _Alloc> class cond_dealtor
{
  typedef typename _Alloc::template rebind<Entry> __rebind_e;
public:
  typedef typename __rebind_e::other entry_allocator;
  typedef typename entry_allocator::pointer entry_pointer;
  cond_dealtor (entry_pointer p_e)
      : m_p_e (p_e), m_no_action_destructor (false)
  {
  }
  ~cond_dealtor ()
  {
    if (m_no_action_destructor)
      return;
    s_alloc.deallocate (m_p_e, 1);
  }
  void
  set_no_action ()
  {
    m_no_action_destructor = true;
  }
private:
  entry_pointer m_p_e;
  bool m_no_action_destructor;
  static entry_allocator s_alloc;
};
template <typename Entry, class _Alloc>
typename cond_dealtor<Entry, _Alloc>::entry_allocator
    cond_dealtor<Entry, _Alloc>::s_alloc;
}
namespace detail
{
template <typename Metadata> struct lu_map_entry_metadata_base
{
  Metadata m_update_metadata;
};
template <> struct lu_map_entry_metadata_base<null_type>
{
};
}
namespace detail
{
template <typename Key, typename Mapped, typename Eq_Fn, typename _Alloc,
          typename Update_Policy>
class lu_map : public types_traits<Key, Mapped, _Alloc, false>
{
private:
  typedef types_traits<Key, Mapped, _Alloc, false> traits_base;
  struct entry : public lu_map_entry_metadata_base<
                     typename Update_Policy::metadata_type>
  {
    typename traits_base::value_type m_value;
    typename _Alloc::template rebind<entry>::other::pointer m_p_next;
  };
  typedef typename _Alloc::template rebind<entry>::other entry_allocator;
  typedef typename entry_allocator::pointer entry_pointer;
  typedef typename entry_allocator::const_pointer const_entry_pointer;
  typedef typename entry_allocator::reference entry_reference;
  typedef typename entry_allocator::const_reference const_entry_reference;
  typedef typename _Alloc::template rebind<entry_pointer>::other
      entry_pointer_allocator;
  typedef typename entry_pointer_allocator::pointer entry_pointer_array;
  typedef typename traits_base::value_type value_type_;
  typedef typename traits_base::pointer pointer_;
  typedef typename traits_base::const_pointer const_pointer_;
  typedef typename traits_base::reference reference_;
  typedef typename traits_base::const_reference const_reference_;
  class point_iterator_;
  class point_const_iterator_
  {
  public:
    typedef trivial_iterator_tag iterator_category;
    typedef trivial_iterator_difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    const_pointer m_p_value;
    friend class point_iterator_;
    friend class lu_map<Key, Mapped, Eq_Fn, _Alloc, Update_Policy>;
  };
  class point_iterator_
  {
  public:
    typedef trivial_iterator_tag iterator_category;
    typedef trivial_iterator_difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    friend class point_const_iterator_;
    friend class lu_map<Key, Mapped, Eq_Fn, _Alloc, Update_Policy>;
  protected:
    pointer m_p_value;
  };
  class const_iterator_ : public point_const_iterator_
  {
  public:
    typedef std::forward_iterator_tag iterator_category;
    typedef typename _Alloc::difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
  protected:
    typedef point_const_iterator_ base_type;
    ;
    const lu_map<Key, Mapped, Eq_Fn, _Alloc, Update_Policy> *m_p_tbl;
    entry_pointer m_pos;
    friend class lu_map<Key, Mapped, Eq_Fn, _Alloc, Update_Policy>;
  };
  class iterator_ : public const_iterator_
  {
  public:
    typedef std::forward_iterator_tag iterator_category;
    typedef typename _Alloc::difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    typedef const_iterator_ base_type;
    ;
    friend class lu_map<Key, Mapped, Eq_Fn, _Alloc, Update_Policy>;
  };
  typedef cond_dealtor<entry, _Alloc> cond_dealtor_t;
public:
  typedef _Alloc allocator_type;
  typedef typename _Alloc::size_type size_type;
  typedef typename _Alloc::difference_type difference_type;
  typedef Eq_Fn eq_fn;
  typedef Update_Policy update_policy;
  typedef typename Update_Policy::metadata_type update_metadata;
  typedef typename traits_base::key_type key_type;
  typedef typename traits_base::key_pointer key_pointer;
  typedef typename traits_base::key_const_pointer key_const_pointer;
  typedef typename traits_base::key_reference key_reference;
  typedef typename traits_base::key_const_reference key_const_reference;
  typedef typename traits_base::mapped_type mapped_type;
  typedef typename traits_base::mapped_pointer mapped_pointer;
  typedef typename traits_base::mapped_const_pointer mapped_const_pointer;
  typedef typename traits_base::mapped_reference mapped_reference;
  typedef typename traits_base::mapped_const_reference mapped_const_reference;
  typedef typename traits_base::value_type value_type;
  typedef typename traits_base::pointer pointer;
  typedef typename traits_base::const_pointer const_pointer;
  typedef typename traits_base::reference reference;
  typedef typename traits_base::const_reference const_reference;
  typedef point_iterator_ point_iterator;
  typedef point_const_iterator_ point_const_iterator;
  typedef iterator_ iterator;
  typedef const_iterator_ const_iterator;
public:
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
protected:
  ;
private:
  friend class iterator_;
  friend class const_iterator_;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  static entry_allocator s_entry_allocator;
  static Eq_Fn s_eq_fn;
  static Update_Policy s_update_policy;
  static type_to_type<update_metadata> s_metadata_type_indicator;
  static null_type s_null_type;
  mutable entry_pointer m_p_l;
};
template <typename Key, typename Mapped, typename Eq_Fn, typename _Alloc,
          typename Update_Policy>
typename lu_map<Key, Mapped, Eq_Fn, _Alloc, Update_Policy>::entry_allocator
    lu_map<Key, Mapped, Eq_Fn, _Alloc, Update_Policy>::s_entry_allocator;
template <typename Key, typename Mapped, typename Eq_Fn, typename _Alloc,
          typename Update_Policy>
Eq_Fn lu_map<Key, Mapped, Eq_Fn, _Alloc, Update_Policy>::s_eq_fn;
template <typename Key, typename Mapped, typename Eq_Fn, typename _Alloc,
          typename Update_Policy>
null_type lu_map<Key, Mapped, Eq_Fn, _Alloc, Update_Policy>::s_null_type;
template <typename Key, typename Mapped, typename Eq_Fn, typename _Alloc,
          typename Update_Policy>
Update_Policy
    lu_map<Key, Mapped, Eq_Fn, _Alloc, Update_Policy>::s_update_policy;
template <typename Key, typename Mapped, typename Eq_Fn, typename _Alloc,
          typename Update_Policy>
type_to_type<typename lu_map<Key, Mapped, Eq_Fn, _Alloc,
                             Update_Policy>::update_metadata>
    lu_map<Key, Mapped, Eq_Fn, _Alloc,
           Update_Policy>::s_metadata_type_indicator;
}
namespace detail
{
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
class bin_search_tree_map : public Cmp_Fn,
                            public types_traits<Key, Mapped, _Alloc, false>,
                            public Node_And_It_Traits::node_update
{
  typedef Node_And_It_Traits traits_type;
protected:
  typedef types_traits<Key, Mapped, _Alloc, false> traits_base;
  typedef typename _Alloc::template rebind<typename traits_type::node>::other
      node_allocator;
  typedef typename node_allocator::value_type node;
  typedef typename node_allocator::pointer node_pointer;
  typedef
      typename traits_type::null_node_update_pointer null_node_update_pointer;
private:
  typedef cond_dealtor<node, _Alloc> cond_dealtor_t;
public:
  typedef typename _Alloc::size_type size_type;
  typedef typename _Alloc::difference_type difference_type;
  typedef typename traits_base::key_type key_type;
  typedef typename traits_base::key_pointer key_pointer;
  typedef typename traits_base::key_const_pointer key_const_pointer;
  typedef typename traits_base::key_reference key_reference;
  typedef typename traits_base::key_const_reference key_const_reference;
  typedef typename traits_base::mapped_type mapped_type;
  typedef typename traits_base::mapped_pointer mapped_pointer;
  typedef typename traits_base::mapped_const_pointer mapped_const_pointer;
  typedef typename traits_base::mapped_reference mapped_reference;
  typedef typename traits_base::mapped_const_reference mapped_const_reference;
  typedef typename traits_base::value_type value_type;
  typedef typename traits_base::pointer pointer;
  typedef typename traits_base::const_pointer const_pointer;
  typedef typename traits_base::reference reference;
  typedef typename traits_base::const_reference const_reference;
  typedef typename traits_type::point_const_iterator point_const_iterator;
  typedef point_const_iterator const_iterator;
  typedef typename traits_type::point_iterator point_iterator;
  typedef point_iterator iterator;
  typedef typename traits_type::const_reverse_iterator const_reverse_iterator;
  typedef typename traits_type::reverse_iterator reverse_iterator;
  typedef typename traits_type::node_const_iterator node_const_iterator;
  typedef typename traits_type::node_iterator node_iterator;
  typedef typename traits_type::node_update node_update;
  typedef Cmp_Fn cmp_fn;
  typedef _Alloc allocator_type;
  bin_search_tree_map ();
  bin_search_tree_map (const Cmp_Fn &);
  ;
  bin_search_tree_map (
      const bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                _Alloc> &);
  void swap (
      bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
  ~bin_search_tree_map ();
  inline bool empty () const;
  inline size_type size () const;
  ;
  Cmp_Fn &get_cmp_fn ();
  const Cmp_Fn &get_cmp_fn () const;
  ;
  inline point_const_iterator lower_bound (key_const_reference) const;
  inline point_iterator upper_bound (key_const_reference);
  inline point_const_iterator upper_bound (key_const_reference) const;
  inline point_iterator find (key_const_reference);
  inline point_const_iterator find (key_const_reference) const;
  inline iterator begin ();
  inline const_iterator begin () const;
  inline iterator end ();
  inline const_iterator end () const;
  ;
  inline const_reverse_iterator rbegin () const;
  ;
  inline const_reverse_iterator rend () const;
  inline node_const_iterator node_begin () const;
  inline node_iterator node_begin ();
  inline node_const_iterator node_end () const;
  inline node_iterator node_end ();
  void clear ();
protected:
  void value_swap (
      bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
  void initialize_min_max ();
  inline iterator insert_imp_empty (const_reference);
  inline iterator insert_leaf_new (const_reference, node_pointer, bool);
  inline node_pointer get_new_node_for_leaf_insert (const_reference,
                                                    false_type);
  ;
  inline void actual_erase_node (node_pointer);
  ;
  inline void update_min_max_for_erased_node (node_pointer);
  static void clear_imp (node_pointer);
  inline std::pair<point_iterator, bool> insert_leaf (const_reference);
  inline void rotate_left (node_pointer);
  inline void rotate_right (node_pointer);
  inline void rotate_parent (node_pointer);
  inline void apply_update (node_pointer, null_node_update_pointer);
  template <typename Node_Update_>
  inline void apply_update (node_pointer, Node_Update_ *);
  inline void update_to_top (node_pointer, null_node_update_pointer);
  template <typename Node_Update_>
  inline void update_to_top (node_pointer, Node_Update_ *);
  bool join_prep (
      bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
  void join_finish (
      bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
  bool split_prep (
      key_const_reference,
      bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
  void split_finish (
      bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
  size_type recursive_count (node_pointer) const;
private:
  void initialize ();
  node_pointer recursive_copy_node (const node_pointer);
protected:
  node_pointer m_p_head;
  size_type m_size;
  static node_allocator s_node_allocator;
};
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                             _Alloc>::node_allocator
    bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                        _Alloc>::s_node_allocator;
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::bin_search_tree_map ()
    : m_p_head (s_node_allocator.allocate (1)), m_size (0)
{
  initialize ();
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::bin_search_tree_map (const Cmp_Fn &r_cmp_fn)
    : Cmp_Fn (r_cmp_fn), m_p_head (s_node_allocator.allocate (1)), m_size (0)
{
  initialize ();
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::
    bin_search_tree_map (
        const bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                  _Alloc> &other)
    : Cmp_Fn (other), node_update (other),
      m_p_head (s_node_allocator.allocate (1)), m_size (0)
{
  initialize ();
  m_size = other.m_size;
  ;
  try
    {
      m_p_head->m_p_parent = recursive_copy_node (other.m_p_head->m_p_parent);
      if (m_p_head->m_p_parent != 0)
        m_p_head->m_p_parent->m_p_parent = m_p_head;
      m_size = other.m_size;
      initialize_min_max ();
    }
  catch (...)
    {
      ;
      s_node_allocator.deallocate (m_p_head, 1);
      throw;
    };
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::swap (
    bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &
        other)
{
  ;
  ;
  value_swap (other);
  std::swap ((Cmp_Fn &)(*this), (Cmp_Fn &)other);
  ;
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::
    value_swap (bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc> &other)
{
  ;
  std::swap (m_p_head, other.m_p_head);
  std::swap (m_size, other.m_size);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::~bin_search_tree_map ()
{
  clear ();
  s_node_allocator.deallocate (m_p_head, 1);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::initialize ()
{
  m_p_head->m_p_parent = 0;
  m_p_head->m_p_left = m_p_head;
  m_p_head->m_p_right = m_p_head;
  m_size = 0;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                             _Alloc>::node_pointer
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::recursive_copy_node (const node_pointer p_nd)
{
  if (p_nd == 0)
    return (0);
  node_pointer p_ret = s_node_allocator.allocate (1);
  try
    {
      new (p_ret) node (*p_nd);
    }
  catch (...)
    {
      s_node_allocator.deallocate (p_ret, 1);
      throw;
    }
  p_ret->m_p_left = p_ret->m_p_right = 0;
  try
    {
      p_ret->m_p_left = recursive_copy_node (p_nd->m_p_left);
      p_ret->m_p_right = recursive_copy_node (p_nd->m_p_right);
    }
  catch (...)
    {
      clear_imp (p_ret);
      throw;
    }
  if (p_ret->m_p_left != 0)
    p_ret->m_p_left->m_p_parent = p_ret;
  if (p_ret->m_p_right != 0)
    p_ret->m_p_right->m_p_parent = p_ret;
  ;
  return p_ret;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::initialize_min_max ()
{
  if (m_p_head->m_p_parent == 0)
    {
      m_p_head->m_p_left = m_p_head->m_p_right = m_p_head;
      return;
    }
  {
    node_pointer p_min = m_p_head->m_p_parent;
    while (p_min->m_p_left != 0)
      p_min = p_min->m_p_left;
    m_p_head->m_p_left = p_min;
  }
  {
    node_pointer p_max = m_p_head->m_p_parent;
    while (p_max->m_p_right != 0)
      p_max = p_max->m_p_right;
    m_p_head->m_p_right = p_max;
  }
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::iterator
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::begin ()
{
  return (iterator (m_p_head->m_p_left));
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::const_iterator
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::begin ()
    const
{
  return (const_iterator (m_p_head->m_p_left));
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::iterator
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::end ()
{
  return (iterator (m_p_head));
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::const_iterator
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::end ()
    const
{
  return (const_iterator (m_p_head));
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::const_reverse_iterator
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::rbegin ()
    const
{
  return (const_reverse_iterator (m_p_head->m_p_right));
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::const_reverse_iterator
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::rend ()
    const
{
  return (const_reverse_iterator (m_p_head));
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::node_const_iterator
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::node_begin () const
{
  return (node_const_iterator (m_p_head->m_p_parent));
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::node_iterator
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::node_begin ()
{
  return (node_iterator (m_p_head->m_p_parent));
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::node_const_iterator
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::node_end () const
{
  return (node_const_iterator (0));
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::node_iterator
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::node_end ()
{
  return (node_iterator (0));
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline std::pair<
    typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                 _Alloc>::point_iterator,
    bool>
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::insert_leaf (const_reference r_value)
{
  ;
  if (m_size == 0)
    return std::make_pair (insert_imp_empty (r_value), true);
  node_pointer p_nd = m_p_head->m_p_parent;
  node_pointer p_pot = m_p_head;
  while (p_nd != 0)
    if (!Cmp_Fn::operator()((p_nd->m_value).first, (r_value).first))
      {
        p_pot = p_nd;
        p_nd = p_nd->m_p_left;
      }
    else
      p_nd = p_nd->m_p_right;
  if (p_pot == m_p_head)
    return std::make_pair (
        insert_leaf_new (r_value, m_p_head->m_p_right, false), true);
  if (!Cmp_Fn::operator()((r_value).first, (p_pot->m_value).first))
    {
      ;
      ;
      return std::make_pair (p_pot, false);
    };
  p_nd = p_pot->m_p_left;
  if (p_nd == 0)
    return std::make_pair (insert_leaf_new (r_value, p_pot, true), true);
  while (p_nd->m_p_right != 0)
    p_nd = p_nd->m_p_right;
  return std::make_pair (insert_leaf_new (r_value, p_nd, false), true);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::iterator
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::insert_leaf_new (const_reference r_value,
                                              node_pointer p_nd, bool left_nd)
{
  node_pointer p_new_nd = get_new_node_for_leaf_insert (
      r_value, traits_base::m_no_throw_copies_indicator);
  if (left_nd)
    {
      ;
      ;
      p_nd->m_p_left = p_new_nd;
      if (m_p_head->m_p_left == p_nd)
        m_p_head->m_p_left = p_new_nd;
    }
  else
    {
      ;
      ;
      p_nd->m_p_right = p_new_nd;
      if (m_p_head->m_p_right == p_nd)
        m_p_head->m_p_right = p_new_nd;
    }
  p_new_nd->m_p_parent = p_nd;
  p_new_nd->m_p_left = p_new_nd->m_p_right = 0;
  ;
  update_to_top (p_new_nd, (node_update *)this);
  ;
  return iterator (p_new_nd);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::iterator
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::insert_imp_empty (const_reference r_value)
{
  node_pointer p_new_node = get_new_node_for_leaf_insert (
      r_value, traits_base::m_no_throw_copies_indicator);
  m_p_head->m_p_left = m_p_head->m_p_right = m_p_head->m_p_parent = p_new_node;
  p_new_node->m_p_parent = m_p_head;
  p_new_node->m_p_left = p_new_node->m_p_right = 0;
  ;
  update_to_top (m_p_head->m_p_parent, (node_update *)this);
  return iterator (p_new_node);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::node_pointer
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::
    get_new_node_for_leaf_insert (const_reference r_val, false_type)
{
  node_pointer p_new_nd = s_node_allocator.allocate (1);
  cond_dealtor_t cond (p_new_nd);
  new (const_cast<void *> (static_cast<const void *> (&p_new_nd->m_value)))
      typename node::value_type (r_val);
  cond.set_no_action ();
  p_new_nd->m_p_left = p_new_nd->m_p_right = 0;
  ++m_size;
  return p_new_nd;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline void
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::actual_erase_node (node_pointer p_z)
{
  ;
  --m_size;
  ;
  p_z->~node ();
  s_node_allocator.deallocate (p_z, 1);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline void
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::update_min_max_for_erased_node (node_pointer p_z)
{
  if (m_size == 1)
    {
      m_p_head->m_p_left = m_p_head->m_p_right = m_p_head;
      return;
    }
  if (m_p_head->m_p_left == p_z)
    {
      iterator it (p_z);
      ++it;
      m_p_head->m_p_left = it.m_p_nd;
    }
  else if (m_p_head->m_p_right == p_z)
    {
      iterator it (p_z);
      --it;
      m_p_head->m_p_right = it.m_p_nd;
    }
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::clear ()
{
  ;
  clear_imp (m_p_head->m_p_parent);
  m_size = 0;
  initialize ();
  ;
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::clear_imp (node_pointer p_nd)
{
  if (p_nd == 0)
    return;
  clear_imp (p_nd->m_p_left);
  clear_imp (p_nd->m_p_right);
  p_nd->~node ();
  s_node_allocator.deallocate (p_nd, 1);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::point_const_iterator
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::lower_bound (key_const_reference r_key) const
{
  node_pointer p_pot = m_p_head;
  node_pointer p_nd = m_p_head->m_p_parent;
  while (p_nd != 0)
    if (Cmp_Fn::operator()((p_nd->m_value).first, r_key))
      p_nd = p_nd->m_p_right;
    else
      {
        p_pot = p_nd;
        p_nd = p_nd->m_p_left;
      }
  return iterator (p_pot);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::point_const_iterator
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::upper_bound (key_const_reference r_key) const
{
  node_pointer p_pot = m_p_head;
  node_pointer p_nd = m_p_head->m_p_parent;
  while (p_nd != 0)
    if (Cmp_Fn::operator()(r_key, (p_nd->m_value).first))
      {
        p_pot = p_nd;
        p_nd = p_nd->m_p_left;
      }
    else
      p_nd = p_nd->m_p_right;
  return const_iterator (p_pot);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::point_iterator
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::upper_bound (key_const_reference r_key)
{
  node_pointer p_pot = m_p_head;
  node_pointer p_nd = m_p_head->m_p_parent;
  while (p_nd != 0)
    if (Cmp_Fn::operator()(r_key, (p_nd->m_value).first))
      {
        p_pot = p_nd;
        p_nd = p_nd->m_p_left;
      }
    else
      p_nd = p_nd->m_p_right;
  return point_iterator (p_pot);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::point_iterator
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::find (
    key_const_reference r_key)
{
  ;
  node_pointer p_pot = m_p_head;
  node_pointer p_nd = m_p_head->m_p_parent;
  while (p_nd != 0)
    if (!Cmp_Fn::operator()((p_nd->m_value).first, r_key))
      {
        p_pot = p_nd;
        p_nd = p_nd->m_p_left;
      }
    else
      p_nd = p_nd->m_p_right;
  node_pointer ret = p_pot;
  if (p_pot != m_p_head)
    {
      const bool __cmp = Cmp_Fn::operator()(r_key, (p_pot->m_value).first);
      if (__cmp)
        ret = m_p_head;
    }
  return point_iterator (ret);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::point_const_iterator
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::find (
    key_const_reference r_key) const
{
  ;
  node_pointer p_pot = m_p_head;
  node_pointer p_nd = m_p_head->m_p_parent;
  while (p_nd != 0)
    if (!Cmp_Fn::operator()((p_nd->m_value).first, r_key))
      {
        p_pot = p_nd;
        p_nd = p_nd->m_p_left;
      }
    else
      p_nd = p_nd->m_p_right;
  node_pointer ret = p_pot;
  if (p_pot != m_p_head)
    {
      const bool __cmp = Cmp_Fn::operator()(r_key, (p_pot->m_value).first);
      if (__cmp)
        ret = m_p_head;
    }
  return point_const_iterator (ret);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline bool
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::empty ()
    const
{
  return (m_size == 0);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc>::size_type
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::size ()
    const
{
  return (m_size);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
bool
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::
    join_prep (bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                   _Alloc> &other)
{
  ;
  ;
  if (other.m_size == 0)
    return false;
  if (m_size == 0)
    {
      value_swap (other);
      return false;
    }
  const bool greater
      = Cmp_Fn::operator()((m_p_head->m_p_right->m_value).first,
                           (other.m_p_head->m_p_left->m_value).first);
  const bool lesser
      = Cmp_Fn::operator()((other.m_p_head->m_p_right->m_value).first,
                           (m_p_head->m_p_left->m_value).first);
  if (!greater && !lesser)
    __throw_join_error ();
  if (lesser)
    value_swap (other);
  m_size += other.m_size;
  ;
  return true;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::
    join_finish (bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                     _Alloc> &other)
{
  initialize_min_max ();
  other.initialize ();
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
bool
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::
    split_prep (key_const_reference r_key,
                bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                    _Alloc> &other)
{
  ;
  ;
  other.clear ();
  if (m_size == 0)
    {
      ;
      ;
      return false;
    }
  if (Cmp_Fn::operator()(r_key, (m_p_head->m_p_left->m_value).first))
    {
      value_swap (other);
      ;
      ;
      return false;
    }
  if (!Cmp_Fn::operator()(r_key, (m_p_head->m_p_right->m_value).first))
    {
      ;
      ;
      return false;
    }
  if (m_size == 1)
    {
      value_swap (other);
      ;
      ;
      return false;
    };
  return true;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::
    split_finish (bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                      _Alloc> &other)
{
  other.initialize_min_max ();
  other.m_size = std::distance (other.begin (), other.end ());
  m_size -= other.m_size;
  initialize_min_max ();
  ;
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
typename bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                             _Alloc>::size_type
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::recursive_count (node_pointer p) const
{
  if (p == 0)
    return 0;
  return 1 + recursive_count (p->m_p_left) + recursive_count (p->m_p_right);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline void
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::rotate_left (node_pointer p_x)
{
  node_pointer p_y = p_x->m_p_right;
  p_x->m_p_right = p_y->m_p_left;
  if (p_y->m_p_left != 0)
    p_y->m_p_left->m_p_parent = p_x;
  p_y->m_p_parent = p_x->m_p_parent;
  if (p_x == m_p_head->m_p_parent)
    m_p_head->m_p_parent = p_y;
  else if (p_x == p_x->m_p_parent->m_p_left)
    p_x->m_p_parent->m_p_left = p_y;
  else
    p_x->m_p_parent->m_p_right = p_y;
  p_y->m_p_left = p_x;
  p_x->m_p_parent = p_y;
  ;
  ;
  apply_update (p_x, (node_update *)this);
  apply_update (p_x->m_p_parent, (node_update *)this);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline void
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::rotate_right (node_pointer p_x)
{
  node_pointer p_y = p_x->m_p_left;
  p_x->m_p_left = p_y->m_p_right;
  if (p_y->m_p_right != 0)
    p_y->m_p_right->m_p_parent = p_x;
  p_y->m_p_parent = p_x->m_p_parent;
  if (p_x == m_p_head->m_p_parent)
    m_p_head->m_p_parent = p_y;
  else if (p_x == p_x->m_p_parent->m_p_right)
    p_x->m_p_parent->m_p_right = p_y;
  else
    p_x->m_p_parent->m_p_left = p_y;
  p_y->m_p_right = p_x;
  p_x->m_p_parent = p_y;
  ;
  ;
  apply_update (p_x, (node_update *)this);
  apply_update (p_x->m_p_parent, (node_update *)this);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline void
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::rotate_parent (node_pointer p_nd)
{
  node_pointer p_parent = p_nd->m_p_parent;
  if (p_nd == p_parent->m_p_left)
    rotate_right (p_parent);
  else
    {
      rotate_left (p_parent);
    };
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline void
    bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                        _Alloc>::apply_update (node_pointer,
                                               null_node_update_pointer)
{
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
template <typename Node_Update_>
inline void
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::apply_update (node_pointer p_nd, Node_Update_ *)
{
  node_update::operator()(node_iterator (p_nd),
                          node_const_iterator (static_cast<node_pointer> (0)));
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
template <typename Node_Update_>
inline void
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::update_to_top (node_pointer p_nd,
                                            Node_Update_ *p_update)
{
  while (p_nd != m_p_head)
    {
      apply_update (p_nd, p_update);
      p_nd = p_nd->m_p_parent;
    }
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline void
    bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                        _Alloc>::update_to_top (node_pointer,
                                                null_node_update_pointer)
{
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
Cmp_Fn &
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::get_cmp_fn ()
{
  return (*this);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
const Cmp_Fn &
bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                    _Alloc>::get_cmp_fn () const
{
  return (*this);
}
}
namespace detail
{
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
class rb_tree_map : public bin_search_tree_map<Key, Mapped, Cmp_Fn,
                                               Node_And_It_Traits, _Alloc>
{
private:
  typedef bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>
      base_type;
  typedef typename base_type::node_pointer node_pointer;
public:
  typedef rb_tree_tag container_category;
  typedef Cmp_Fn cmp_fn;
  typedef _Alloc allocator_type;
  typedef typename _Alloc::size_type size_type;
  typedef typename _Alloc::difference_type difference_type;
  typedef typename base_type::key_type key_type;
  typedef typename base_type::key_pointer key_pointer;
  typedef typename base_type::key_const_pointer key_const_pointer;
  typedef typename base_type::key_reference key_reference;
  typedef typename base_type::key_const_reference key_const_reference;
  typedef typename base_type::mapped_type mapped_type;
  typedef typename base_type::mapped_pointer mapped_pointer;
  typedef typename base_type::mapped_const_pointer mapped_const_pointer;
  typedef typename base_type::mapped_reference mapped_reference;
  typedef typename base_type::mapped_const_reference mapped_const_reference;
  typedef typename base_type::value_type value_type;
  typedef typename base_type::pointer pointer;
  typedef typename base_type::const_pointer const_pointer;
  typedef typename base_type::reference reference;
  typedef typename base_type::const_reference const_reference;
  typedef typename base_type::point_iterator point_iterator;
  typedef typename base_type::const_iterator point_const_iterator;
  typedef typename base_type::iterator iterator;
  typedef typename base_type::const_iterator const_iterator;
  typedef typename base_type::reverse_iterator reverse_iterator;
  typedef typename base_type::const_reverse_iterator const_reverse_iterator;
  typedef typename base_type::node_update node_update;
  rb_tree_map ();
  rb_tree_map (const Cmp_Fn &);
  ;
  rb_tree_map (
      const rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
  void swap (rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
  template <typename It> void copy_from_range (It, It);
  inline std::pair<point_iterator, bool> insert (const_reference);
  inline mapped_reference operator[](key_const_reference r_key)
  {
    ;
    std::pair<point_iterator, bool> ins_pair
        = base_type::insert_leaf (value_type (r_key, mapped_type ()));
    if (ins_pair.second == true)
      {
        ins_pair.first.m_p_nd->m_red = true;
        ;
        insert_fixup (ins_pair.first.m_p_nd);
      };
    return ins_pair.first.m_p_nd->m_value.second;
  }
  inline bool erase (key_const_reference);
  inline iterator erase (iterator);
  inline reverse_iterator erase (reverse_iterator);
  template <typename Pred> inline size_type erase_if (Pred);
  void join (rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
  void split (key_const_reference,
              rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
private:
  inline static bool is_effectively_black (const node_pointer);
  void initialize ();
  void insert_fixup (node_pointer);
  void erase_node (node_pointer);
  void remove_node (node_pointer);
  void remove_fixup (node_pointer, node_pointer);
  ;
  inline node_pointer split_min ();
  ;
  void join_imp (node_pointer, node_pointer);
  std::pair<node_pointer, node_pointer>
      find_join_pos_right (node_pointer, size_type, size_type);
  std::pair<node_pointer, node_pointer>
      find_join_pos_left (node_pointer, size_type, size_type);
  inline size_type black_height (node_pointer);
  void split_at_node (
      node_pointer,
      rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
};
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
template <typename It>
void
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::copy_from_range (
    It first_it, It last_it)
{
  while (first_it != last_it)
    insert (*(first_it++));
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::rb_tree_map ()
{
  initialize ();
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::rb_tree_map (
    const Cmp_Fn &r_cmp_fn)
    : base_type (r_cmp_fn)
{
  initialize ();
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::rb_tree_map (
    const rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &other)
    : base_type (other)
{
  initialize ();
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::swap (
    rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &other)
{
  ;
  base_type::swap (other);
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::initialize ()
{
  base_type::m_p_head->m_red = true;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline std::pair<typename rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                      _Alloc>::point_iterator,
                 bool>
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::insert (
    const_reference r_value)
{
  ;
  std::pair<point_iterator, bool> ins_pair = base_type::insert_leaf (r_value);
  if (ins_pair.second == true)
    {
      ins_pair.first.m_p_nd->m_red = true;
      ;
      insert_fixup (ins_pair.first.m_p_nd);
    };
  return ins_pair;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline void
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::insert_fixup (
    node_pointer p_nd)
{
  ;
  while (p_nd != base_type::m_p_head->m_p_parent && p_nd->m_p_parent->m_red)
    {
      if (p_nd->m_p_parent == p_nd->m_p_parent->m_p_parent->m_p_left)
        {
          node_pointer p_y = p_nd->m_p_parent->m_p_parent->m_p_right;
          if (p_y != 0 && p_y->m_red)
            {
              p_nd->m_p_parent->m_red = false;
              p_y->m_red = false;
              p_nd->m_p_parent->m_p_parent->m_red = true;
              p_nd = p_nd->m_p_parent->m_p_parent;
            }
          else
            {
              if (p_nd == p_nd->m_p_parent->m_p_right)
                {
                  p_nd = p_nd->m_p_parent;
                  base_type::rotate_left (p_nd);
                }
              p_nd->m_p_parent->m_red = false;
              p_nd->m_p_parent->m_p_parent->m_red = true;
              base_type::rotate_right (p_nd->m_p_parent->m_p_parent);
            }
        }
      else
        {
          node_pointer p_y = p_nd->m_p_parent->m_p_parent->m_p_left;
          if (p_y != 0 && p_y->m_red)
            {
              p_nd->m_p_parent->m_red = false;
              p_y->m_red = false;
              p_nd->m_p_parent->m_p_parent->m_red = true;
              p_nd = p_nd->m_p_parent->m_p_parent;
            }
          else
            {
              if (p_nd == p_nd->m_p_parent->m_p_left)
                {
                  p_nd = p_nd->m_p_parent;
                  base_type::rotate_right (p_nd);
                }
              p_nd->m_p_parent->m_red = false;
              p_nd->m_p_parent->m_p_parent->m_red = true;
              base_type::rotate_left (p_nd->m_p_parent->m_p_parent);
            }
        }
    }
  base_type::update_to_top (p_nd, (node_update *)this);
  base_type::m_p_head->m_p_parent->m_red = false;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline bool
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::erase (
    key_const_reference r_key)
{
  point_iterator it = this->find (r_key);
  if (it == base_type::end ())
    return false;
  erase (it);
  return true;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                            _Alloc>::iterator
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::erase (
    iterator it)
{
  ;
  if (it == base_type::end ())
    return it;
  iterator ret_it = it;
  ++ret_it;
  erase_node (it.m_p_nd);
  ;
  return ret_it;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                            _Alloc>::reverse_iterator
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::erase (
    reverse_iterator it)
{
  ;
  if (it.m_p_nd == base_type::m_p_head)
    return it;
  reverse_iterator ret_it = it;
  ++ret_it;
  erase_node (it.m_p_nd);
  ;
  return ret_it;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
template <typename Pred>
inline typename rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                            _Alloc>::size_type
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::erase_if (
    Pred pred)
{
  ;
  size_type num_ersd = 0;
  iterator it = base_type::begin ();
  while (it != base_type::end ())
    {
      if (pred (*it))
        {
          ++num_ersd;
          it = erase (it);
        }
      else
        ++it;
    };
  return num_ersd;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::erase_node (
    node_pointer p_nd)
{
  remove_node (p_nd);
  base_type::actual_erase_node (p_nd);
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::remove_node (
    node_pointer p_z)
{
  this->update_min_max_for_erased_node (p_z);
  node_pointer p_y = p_z;
  node_pointer p_x = 0;
  node_pointer p_new_x_parent = 0;
  if (p_y->m_p_left == 0)
    p_x = p_y->m_p_right;
  else if (p_y->m_p_right == 0)
    p_x = p_y->m_p_left;
  else
    {
      p_y = p_y->m_p_right;
      while (p_y->m_p_left != 0)
        p_y = p_y->m_p_left;
      p_x = p_y->m_p_right;
    }
  if (p_y == p_z)
    {
      p_new_x_parent = p_y->m_p_parent;
      if (p_x != 0)
        p_x->m_p_parent = p_y->m_p_parent;
      if (base_type::m_p_head->m_p_parent == p_z)
        base_type::m_p_head->m_p_parent = p_x;
      else if (p_z->m_p_parent->m_p_left == p_z)
        {
          p_y->m_p_left = p_z->m_p_parent;
          p_z->m_p_parent->m_p_left = p_x;
        }
      else
        {
          p_y->m_p_left = 0;
          p_z->m_p_parent->m_p_right = p_x;
        }
    }
  else
    {
      p_z->m_p_left->m_p_parent = p_y;
      p_y->m_p_left = p_z->m_p_left;
      if (p_y != p_z->m_p_right)
        {
          p_new_x_parent = p_y->m_p_parent;
          if (p_x != 0)
            p_x->m_p_parent = p_y->m_p_parent;
          p_y->m_p_parent->m_p_left = p_x;
          p_y->m_p_right = p_z->m_p_right;
          p_z->m_p_right->m_p_parent = p_y;
        }
      else
        p_new_x_parent = p_y;
      if (base_type::m_p_head->m_p_parent == p_z)
        base_type::m_p_head->m_p_parent = p_y;
      else if (p_z->m_p_parent->m_p_left == p_z)
        p_z->m_p_parent->m_p_left = p_y;
      else
        p_z->m_p_parent->m_p_right = p_y;
      p_y->m_p_parent = p_z->m_p_parent;
      std::swap (p_y->m_red, p_z->m_red);
      p_y = p_z;
    }
  this->update_to_top (p_new_x_parent, (node_update *)this);
  if (p_y->m_red)
    return;
  remove_fixup (p_x, p_new_x_parent);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::remove_fixup (
    node_pointer p_x, node_pointer p_new_x_parent)
{
  ;
  while (p_x != base_type::m_p_head->m_p_parent && is_effectively_black (p_x))
    if (p_x == p_new_x_parent->m_p_left)
      {
        node_pointer p_w = p_new_x_parent->m_p_right;
        if (p_w->m_red)
          {
            p_w->m_red = false;
            p_new_x_parent->m_red = true;
            base_type::rotate_left (p_new_x_parent);
            p_w = p_new_x_parent->m_p_right;
          }
        if (is_effectively_black (p_w->m_p_left)
            && is_effectively_black (p_w->m_p_right))
          {
            p_w->m_red = true;
            p_x = p_new_x_parent;
            p_new_x_parent = p_new_x_parent->m_p_parent;
          }
        else
          {
            if (is_effectively_black (p_w->m_p_right))
              {
                if (p_w->m_p_left != 0)
                  p_w->m_p_left->m_red = false;
                p_w->m_red = true;
                base_type::rotate_right (p_w);
                p_w = p_new_x_parent->m_p_right;
              }
            p_w->m_red = p_new_x_parent->m_red;
            p_new_x_parent->m_red = false;
            if (p_w->m_p_right != 0)
              p_w->m_p_right->m_red = false;
            base_type::rotate_left (p_new_x_parent);
            this->update_to_top (p_new_x_parent, (node_update *)this);
            break;
          }
      }
    else
      {
        node_pointer p_w = p_new_x_parent->m_p_left;
        if (p_w->m_red == true)
          {
            p_w->m_red = false;
            p_new_x_parent->m_red = true;
            base_type::rotate_right (p_new_x_parent);
            p_w = p_new_x_parent->m_p_left;
          }
        if (is_effectively_black (p_w->m_p_right)
            && is_effectively_black (p_w->m_p_left))
          {
            p_w->m_red = true;
            p_x = p_new_x_parent;
            p_new_x_parent = p_new_x_parent->m_p_parent;
          }
        else
          {
            if (is_effectively_black (p_w->m_p_left))
              {
                if (p_w->m_p_right != 0)
                  p_w->m_p_right->m_red = false;
                p_w->m_red = true;
                base_type::rotate_left (p_w);
                p_w = p_new_x_parent->m_p_left;
              }
            p_w->m_red = p_new_x_parent->m_red;
            p_new_x_parent->m_red = false;
            if (p_w->m_p_left != 0)
              p_w->m_p_left->m_red = false;
            base_type::rotate_right (p_new_x_parent);
            this->update_to_top (p_new_x_parent, (node_update *)this);
            break;
          }
      }
  if (p_x != 0)
    p_x->m_red = false;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline void
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::join (
    rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &other)
{
  ;
  ;
  if (base_type::join_prep (other) == false)
    {
      ;
      ;
      return;
    }
  const node_pointer p_x = other.split_min ();
  join_imp (p_x, other.m_p_head->m_p_parent);
  base_type::join_finish (other);
  ;
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::join_imp (
    node_pointer p_x, node_pointer p_r)
{
  ;
  if (p_r != 0)
    p_r->m_red = false;
  const size_type h = black_height (base_type::m_p_head->m_p_parent);
  const size_type other_h = black_height (p_r);
  node_pointer p_x_l;
  node_pointer p_x_r;
  std::pair<node_pointer, node_pointer> join_pos;
  const bool right_join = h >= other_h;
  if (right_join)
    {
      join_pos
          = find_join_pos_right (base_type::m_p_head->m_p_parent, h, other_h);
      p_x_l = join_pos.first;
      p_x_r = p_r;
    }
  else
    {
      p_x_l = base_type::m_p_head->m_p_parent;
      base_type::m_p_head->m_p_parent = p_r;
      if (p_r != 0)
        p_r->m_p_parent = base_type::m_p_head;
      join_pos
          = find_join_pos_left (base_type::m_p_head->m_p_parent, h, other_h);
      p_x_r = join_pos.first;
    }
  node_pointer p_parent = join_pos.second;
  if (p_parent == base_type::m_p_head)
    {
      base_type::m_p_head->m_p_parent = p_x;
      p_x->m_p_parent = base_type::m_p_head;
    }
  else
    {
      p_x->m_p_parent = p_parent;
      if (right_join)
        p_x->m_p_parent->m_p_right = p_x;
      else
        p_x->m_p_parent->m_p_left = p_x;
    }
  p_x->m_p_left = p_x_l;
  if (p_x_l != 0)
    p_x_l->m_p_parent = p_x;
  p_x->m_p_right = p_x_r;
  if (p_x_r != 0)
    p_x_r->m_p_parent = p_x;
  p_x->m_red = true;
  base_type::initialize_min_max ();
  ;
  base_type::update_to_top (p_x, (node_update *)this);
  insert_fixup (p_x);
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                            _Alloc>::node_pointer
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::split_min ()
{
  node_pointer p_min = base_type::m_p_head->m_p_left;
  remove_node (p_min);
  return p_min;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
std::pair<typename rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                               _Alloc>::node_pointer,
          typename rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                               _Alloc>::node_pointer>
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
            _Alloc>::find_join_pos_right (node_pointer p_l, size_type h_l,
                                          size_type h_r)
{
  ;
  if (base_type::m_p_head->m_p_parent == 0)
    return (std::make_pair ((node_pointer)0, base_type::m_p_head));
  node_pointer p_l_parent = base_type::m_p_head;
  while (h_l > h_r)
    {
      if (p_l->m_red == false)
        {
          ;
          --h_l;
        }
      p_l_parent = p_l;
      p_l = p_l->m_p_right;
    }
  if (!is_effectively_black (p_l))
    {
      p_l_parent = p_l;
      p_l = p_l->m_p_right;
    };
  ;
  ;
  return std::make_pair (p_l, p_l_parent);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
std::pair<typename rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                               _Alloc>::node_pointer,
          typename rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                               _Alloc>::node_pointer>
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
            _Alloc>::find_join_pos_left (node_pointer p_r, size_type h_l,
                                         size_type h_r)
{
  ;
  if (base_type::m_p_head->m_p_parent == 0)
    return (std::make_pair ((node_pointer)0, base_type::m_p_head));
  node_pointer p_r_parent = base_type::m_p_head;
  while (h_r > h_l)
    {
      if (p_r->m_red == false)
        {
          ;
          --h_r;
        }
      p_r_parent = p_r;
      p_r = p_r->m_p_left;
    }
  if (!is_effectively_black (p_r))
    {
      p_r_parent = p_r;
      p_r = p_r->m_p_left;
    };
  ;
  ;
  return std::make_pair (p_r, p_r_parent);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                            _Alloc>::size_type
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::black_height (
    node_pointer p_nd)
{
  size_type h = 1;
  while (p_nd != 0)
    {
      if (p_nd->m_red == false)
        ++h;
      p_nd = p_nd->m_p_left;
    }
  return h;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::split (
    key_const_reference r_key,
    rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &other)
{
  ;
  ;
  if (base_type::split_prep (r_key, other) == false)
    {
      ;
      ;
      return;
    };
  ;
  node_pointer p_nd = this->upper_bound (r_key).m_p_nd;
  do
    {
      node_pointer p_next_nd = p_nd->m_p_parent;
      if (Cmp_Fn::operator()(r_key, (p_nd->m_value).first))
        split_at_node (p_nd, other);
      ;
      ;
      p_nd = p_next_nd;
    }
  while (p_nd != base_type::m_p_head);
  base_type::split_finish (other);
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::split_at_node (
    node_pointer p_nd,
    rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &other)
{
  ;
  node_pointer p_l = p_nd->m_p_left;
  node_pointer p_r = p_nd->m_p_right;
  node_pointer p_parent = p_nd->m_p_parent;
  if (p_parent == base_type::m_p_head)
    {
      base_type::m_p_head->m_p_parent = p_l;
      if (p_l != 0)
        {
          p_l->m_p_parent = base_type::m_p_head;
          p_l->m_red = false;
        }
    }
  else
    {
      if (p_parent->m_p_left == p_nd)
        p_parent->m_p_left = p_l;
      else
        p_parent->m_p_right = p_l;
      if (p_l != 0)
        p_l->m_p_parent = p_parent;
      this->update_to_top (p_parent, (node_update *)this);
      if (!p_nd->m_red)
        remove_fixup (p_l, p_parent);
    }
  base_type::initialize_min_max ();
  other.join_imp (p_nd, p_r);
  ;
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline bool
rb_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
            _Alloc>::is_effectively_black (const node_pointer p_nd)
{
  return (p_nd == 0 || !p_nd->m_red);
}
}
namespace detail
{
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
class splay_tree_map : public bin_search_tree_map<Key, Mapped, Cmp_Fn,
                                                  Node_And_It_Traits, _Alloc>
{
private:
  typedef bin_search_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>
      base_type;
  typedef typename base_type::node_pointer node_pointer;
public:
  typedef splay_tree_tag container_category;
  typedef _Alloc allocator_type;
  typedef typename _Alloc::size_type size_type;
  typedef typename _Alloc::difference_type difference_type;
  typedef Cmp_Fn cmp_fn;
  typedef typename base_type::key_type key_type;
  typedef typename base_type::key_pointer key_pointer;
  typedef typename base_type::key_const_pointer key_const_pointer;
  typedef typename base_type::key_reference key_reference;
  typedef typename base_type::key_const_reference key_const_reference;
  typedef typename base_type::mapped_type mapped_type;
  typedef typename base_type::mapped_pointer mapped_pointer;
  typedef typename base_type::mapped_const_pointer mapped_const_pointer;
  typedef typename base_type::mapped_reference mapped_reference;
  typedef typename base_type::mapped_const_reference mapped_const_reference;
  typedef typename base_type::value_type value_type;
  typedef typename base_type::pointer pointer;
  typedef typename base_type::const_pointer const_pointer;
  typedef typename base_type::reference reference;
  typedef typename base_type::const_reference const_reference;
  typedef typename base_type::point_iterator point_iterator;
  typedef typename base_type::const_iterator point_const_iterator;
  typedef typename base_type::iterator iterator;
  typedef typename base_type::const_iterator const_iterator;
  typedef typename base_type::reverse_iterator reverse_iterator;
  typedef typename base_type::const_reverse_iterator const_reverse_iterator;
  typedef typename base_type::node_update node_update;
  splay_tree_map ();
  splay_tree_map (const Cmp_Fn &);
  ;
  splay_tree_map (
      const splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
  void
  swap (splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
  template <typename It> void copy_from_range (It, It);
  void initialize ();
  inline std::pair<point_iterator, bool> insert (const_reference r_value);
  inline mapped_reference operator[](key_const_reference r_key)
  {
    ;
    std::pair<point_iterator, bool> ins_pair
        = insert_leaf_imp (value_type (r_key, mapped_type ()));
    ins_pair.first.m_p_nd->m_special = false;
    ;
    ;
    splay (ins_pair.first.m_p_nd);
    ;
    return ins_pair.first.m_p_nd->m_value.second;
  }
  inline point_iterator find (key_const_reference);
  inline point_const_iterator find (key_const_reference) const;
  inline bool erase (key_const_reference);
  inline iterator erase (iterator it);
  inline reverse_iterator erase (reverse_iterator);
  template <typename Pred> inline size_type erase_if (Pred);
  void
  join (splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
  void
  split (key_const_reference,
         splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
private:
  inline std::pair<point_iterator, bool> insert_leaf_imp (const_reference);
  inline node_pointer find_imp (key_const_reference);
  inline const node_pointer find_imp (key_const_reference) const;
  void dump_subtree (node_pointer, int);
  void splay (node_pointer);
  inline void splay_zig_zag_left (node_pointer, node_pointer, node_pointer);
  inline void splay_zig_zag_right (node_pointer, node_pointer, node_pointer);
  inline void splay_zig_zig_left (node_pointer, node_pointer, node_pointer);
  inline void splay_zig_zig_right (node_pointer, node_pointer, node_pointer);
  inline void splay_zz_start (node_pointer, node_pointer, node_pointer);
  inline void splay_zz_end (node_pointer, node_pointer, node_pointer);
  inline node_pointer leftmost (node_pointer);
  void erase_node (node_pointer);
};
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
template <typename It>
void
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
               _Alloc>::copy_from_range (It first_it, It last_it)
{
  while (first_it != last_it)
    insert (*(first_it++));
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
               _Alloc>::splay_tree_map ()
{
  initialize ();
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
               _Alloc>::splay_tree_map (const Cmp_Fn &r_cmp_fn)
    : base_type (r_cmp_fn)
{
  initialize ();
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::
    splay_tree_map (const splay_tree_map<Key, Mapped, Cmp_Fn,
                                         Node_And_It_Traits, _Alloc> &other)
    : base_type (other)
{
  initialize ();
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::swap (
    splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &other)
{
  ;
  ;
  base_type::swap (other);
  ;
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::initialize ()
{
  base_type::m_p_head->m_special = true;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline std::pair<
    typename splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                            _Alloc>::point_iterator,
    bool>
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::insert (
    const_reference r_value)
{
  ;
  std::pair<point_iterator, bool> ins_pair = insert_leaf_imp (r_value);
  ins_pair.first.m_p_nd->m_special = false;
  ;
  splay (ins_pair.first.m_p_nd);
  ;
  return ins_pair;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline std::pair<
    typename splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                            _Alloc>::point_iterator,
    bool>
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
               _Alloc>::insert_leaf_imp (const_reference r_value)
{
  ;
  if (base_type::m_size == 0)
    return std::make_pair (base_type::insert_imp_empty (r_value), true);
  node_pointer p_nd = base_type::m_p_head->m_p_parent;
  node_pointer p_pot = base_type::m_p_head;
  while (p_nd != 0)
    if (!Cmp_Fn::operator()((p_nd->m_value).first, (r_value).first))
      {
        if (!Cmp_Fn::operator()((r_value).first, (p_nd->m_value).first))
          {
            return std::make_pair (point_iterator (p_nd), false);
          }
        p_pot = p_nd;
        p_nd = p_nd->m_p_left;
      }
    else
      p_nd = p_nd->m_p_right;
  if (p_pot == base_type::m_p_head)
    return std::make_pair (base_type::insert_leaf_new (
                               r_value, base_type::m_p_head->m_p_right, false),
                           true);
  ;
  p_nd = p_pot->m_p_left;
  if (p_nd == 0)
    return (std::make_pair (base_type::insert_leaf_new (r_value, p_pot, true),
                            true));
  while (p_nd->m_p_right != 0)
    p_nd = p_nd->m_p_right;
  return std::make_pair (this->insert_leaf_new (r_value, p_nd, false), true);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::dump_subtree (
    node_pointer p_nd, int indentation)
{
  fprintf (stderr, "%*snode: %p\n", indentation, "", p_nd);
  fprintf (stderr, "%*sL: %p\n", indentation, "", p_nd->m_p_left);
  if (p_nd->m_p_left)
    dump_subtree (p_nd->m_p_left, indentation + 1);
  fprintf (stderr, "%*sR: %p\n", indentation, "", p_nd->m_p_right);
  if (p_nd->m_p_right)
    dump_subtree (p_nd->m_p_right, indentation + 1);
  if (indentation == 0)
    fprintf (stderr, "\n");
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::splay (
    node_pointer p_nd)
{
  while (p_nd->m_p_parent != base_type::m_p_head)
    {
      dump_subtree (p_nd, 0);
      ;
      if (p_nd->m_p_parent->m_p_parent == base_type::m_p_head)
        {
          base_type::rotate_parent (p_nd);
          ;
        }
      else
        {
          const node_pointer p_parent = p_nd->m_p_parent;
          const node_pointer p_grandparent = p_parent->m_p_parent;
          if (p_parent->m_p_left == p_nd
              && p_grandparent->m_p_right == p_parent)
            splay_zig_zag_left (p_nd, p_parent, p_grandparent);
          else if (p_parent->m_p_right == p_nd
                   && p_grandparent->m_p_left == p_parent)
            splay_zig_zag_right (p_nd, p_parent, p_grandparent);
          else if (p_parent->m_p_left == p_nd
                   && p_grandparent->m_p_left == p_parent)
            splay_zig_zig_left (p_nd, p_parent, p_grandparent);
          else
            splay_zig_zig_right (p_nd, p_parent, p_grandparent);
          ;
        };
    }
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline void
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
               _Alloc>::splay_zig_zag_left (node_pointer p_nd,
                                            node_pointer p_parent,
                                            node_pointer p_grandparent)
{
  ;
  ;
  ;
  ;
  splay_zz_start (p_nd, p_parent, p_grandparent);
  node_pointer p_b = p_nd->m_p_right;
  node_pointer p_c = p_nd->m_p_left;
  p_nd->m_p_right = p_parent;
  p_parent->m_p_parent = p_nd;
  p_nd->m_p_left = p_grandparent;
  p_grandparent->m_p_parent = p_nd;
  p_parent->m_p_left = p_b;
  if (p_b != 0)
    p_b->m_p_parent = p_parent;
  p_grandparent->m_p_right = p_c;
  if (p_c != 0)
    p_c->m_p_parent = p_grandparent;
  splay_zz_end (p_nd, p_parent, p_grandparent);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline void
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
               _Alloc>::splay_zig_zag_right (node_pointer p_nd,
                                             node_pointer p_parent,
                                             node_pointer p_grandparent)
{
  ;
  ;
  ;
  ;
  splay_zz_start (p_nd, p_parent, p_grandparent);
  node_pointer p_b = p_nd->m_p_left;
  node_pointer p_c = p_nd->m_p_right;
  p_nd->m_p_left = p_parent;
  p_parent->m_p_parent = p_nd;
  p_nd->m_p_right = p_grandparent;
  p_grandparent->m_p_parent = p_nd;
  p_parent->m_p_right = p_b;
  if (p_b != 0)
    p_b->m_p_parent = p_parent;
  p_grandparent->m_p_left = p_c;
  if (p_c != 0)
    p_c->m_p_parent = p_grandparent;
  splay_zz_end (p_nd, p_parent, p_grandparent);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline void
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
               _Alloc>::splay_zig_zig_left (node_pointer p_nd,
                                            node_pointer p_parent,
                                            node_pointer p_grandparent)
{
  ;
  ;
  ;
  ;
  splay_zz_start (p_nd, p_parent, p_grandparent);
  node_pointer p_b = p_nd->m_p_right;
  node_pointer p_c = p_parent->m_p_right;
  p_nd->m_p_right = p_parent;
  p_parent->m_p_parent = p_nd;
  p_parent->m_p_right = p_grandparent;
  p_grandparent->m_p_parent = p_parent;
  p_parent->m_p_left = p_b;
  if (p_b != 0)
    p_b->m_p_parent = p_parent;
  p_grandparent->m_p_left = p_c;
  if (p_c != 0)
    p_c->m_p_parent = p_grandparent;
  splay_zz_end (p_nd, p_parent, p_grandparent);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline void
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
               _Alloc>::splay_zig_zig_right (node_pointer p_nd,
                                             node_pointer p_parent,
                                             node_pointer p_grandparent)
{
  ;
  ;
  ;
  ;
  splay_zz_start (p_nd, p_parent, p_grandparent);
  node_pointer p_b = p_nd->m_p_left;
  node_pointer p_c = p_parent->m_p_left;
  p_nd->m_p_left = p_parent;
  p_parent->m_p_parent = p_nd;
  p_parent->m_p_left = p_grandparent;
  p_grandparent->m_p_parent = p_parent;
  p_parent->m_p_right = p_b;
  if (p_b != 0)
    p_b->m_p_parent = p_parent;
  p_grandparent->m_p_right = p_c;
  if (p_c != 0)
    p_c->m_p_parent = p_grandparent;
  base_type::update_to_top (p_grandparent, (node_update *)this);
  splay_zz_end (p_nd, p_parent, p_grandparent);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline void
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
               _Alloc>::splay_zz_start (node_pointer p_nd, node_pointer,
                                        node_pointer p_grandparent)
{
  ;
  ;
  ;
  const bool grandparent_head = p_grandparent->m_p_parent
                                == base_type::m_p_head;
  if (grandparent_head)
    {
      base_type::m_p_head->m_p_parent = base_type::m_p_head->m_p_parent;
      p_nd->m_p_parent = base_type::m_p_head;
      return;
    }
  node_pointer p_greatgrandparent = p_grandparent->m_p_parent;
  p_nd->m_p_parent = p_greatgrandparent;
  if (p_grandparent == p_greatgrandparent->m_p_left)
    p_greatgrandparent->m_p_left = p_nd;
  else
    p_greatgrandparent->m_p_right = p_nd;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline void
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::splay_zz_end (
    node_pointer p_nd, node_pointer p_parent, node_pointer p_grandparent)
{
  if (p_nd->m_p_parent == base_type::m_p_head)
    base_type::m_p_head->m_p_parent = p_nd;
  this->apply_update (p_grandparent, (node_update *)this);
  this->apply_update (p_parent, (node_update *)this);
  this->apply_update (p_nd, (node_update *)this);
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline bool
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::erase (
    key_const_reference r_key)
{
  point_iterator it = find (r_key);
  if (it == base_type::end ())
    return false;
  erase (it);
  return true;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                               _Alloc>::iterator
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::erase (
    iterator it)
{
  ;
  if (it == base_type::end ())
    return it;
  iterator ret_it = it;
  ++ret_it;
  erase_node (it.m_p_nd);
  ;
  return ret_it;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                               _Alloc>::reverse_iterator
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::erase (
    reverse_iterator it)
{
  ;
  if (it.m_p_nd == base_type::m_p_head)
    return (it);
  reverse_iterator ret_it = it;
  ++ret_it;
  erase_node (it.m_p_nd);
  ;
  return ret_it;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
template <typename Pred>
inline typename splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                               _Alloc>::size_type
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::erase_if (
    Pred pred)
{
  ;
  size_type num_ersd = 0;
  iterator it = base_type::begin ();
  while (it != base_type::end ())
    {
      if (pred (*it))
        {
          ++num_ersd;
          it = erase (it);
        }
      else
        ++it;
    };
  return num_ersd;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::erase_node (
    node_pointer p_nd)
{
  ;
  splay (p_nd);
  ;
  ;
  node_pointer p_l = p_nd->m_p_left;
  node_pointer p_r = p_nd->m_p_right;
  base_type::update_min_max_for_erased_node (p_nd);
  base_type::actual_erase_node (p_nd);
  if (p_r == 0)
    {
      base_type::m_p_head->m_p_parent = p_l;
      if (p_l != 0)
        p_l->m_p_parent = base_type::m_p_head;
      ;
      return;
    }
  node_pointer p_target_r = leftmost (p_r);
  ;
  p_r->m_p_parent = base_type::m_p_head;
  base_type::m_p_head->m_p_parent = p_r;
  splay (p_target_r);
  ;
  ;
  ;
  ;
  p_target_r->m_p_left = p_l;
  if (p_l != 0)
    p_l->m_p_parent = p_target_r;
  ;
  this->apply_update (p_target_r, (node_update *)this);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                               _Alloc>::node_pointer
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::leftmost (
    node_pointer p_nd)
{
  ;
  while (p_nd->m_p_left != 0)
    p_nd = p_nd->m_p_left;
  return p_nd;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                               _Alloc>::point_iterator
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::find (
    key_const_reference r_key)
{
  node_pointer p_found = find_imp (r_key);
  if (p_found != base_type::m_p_head)
    splay (p_found);
  return point_iterator (p_found);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                               _Alloc>::point_const_iterator
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::find (
    key_const_reference r_key) const
{
  const node_pointer p_found = find_imp (r_key);
  if (p_found != base_type::m_p_head)
    const_cast<splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                              _Alloc> *> (this)->splay (p_found);
  return point_iterator (p_found);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                               _Alloc>::node_pointer
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::find_imp (
    key_const_reference r_key)
{
  ;
  node_pointer p_nd = base_type::m_p_head->m_p_parent;
  while (p_nd != 0)
    if (!Cmp_Fn::operator()((p_nd->m_value).first, r_key))
      {
        if (!Cmp_Fn::operator()(r_key, (p_nd->m_value).first))
          return p_nd;
        p_nd = p_nd->m_p_left;
      }
    else
      p_nd = p_nd->m_p_right;
  return base_type::m_p_head;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline const typename splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                     _Alloc>::node_pointer
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::find_imp (
    key_const_reference r_key) const
{
  ;
  node_pointer p_nd = base_type::m_p_head->m_p_parent;
  while (p_nd != 0)
    if (!Cmp_Fn::operator()((p_nd->m_value).first, r_key))
      {
        if (!Cmp_Fn::operator()(r_key, (p_nd->m_value).first))
          return p_nd;
        p_nd = p_nd->m_p_left;
      }
    else
      p_nd = p_nd->m_p_right;
  return base_type::m_p_head;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline void
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::join (
    splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &other)
{
  ;
  ;
  if (base_type::join_prep (other) == false)
    {
      ;
      ;
      return;
    }
  node_pointer p_target_r = other.leftmost (other.m_p_head);
  ;
  other.splay (p_target_r);
  ;
  ;
  p_target_r->m_p_left = base_type::m_p_head->m_p_parent;
  ;
  p_target_r->m_p_left->m_p_parent = p_target_r;
  base_type::m_p_head->m_p_parent = p_target_r;
  p_target_r->m_p_parent = base_type::m_p_head;
  this->apply_update (p_target_r, (node_update *)this);
  base_type::join_finish (other);
  ;
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::split (
    key_const_reference r_key,
    splay_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &other)
{
  ;
  ;
  if (base_type::split_prep (r_key, other) == false)
    {
      ;
      ;
      return;
    }
  node_pointer p_upper_bound = this->upper_bound (r_key).m_p_nd;
  ;
  splay (p_upper_bound);
  ;
  node_pointer p_new_root = p_upper_bound->m_p_left;
  ;
  base_type::m_p_head->m_p_parent = p_new_root;
  p_new_root->m_p_parent = base_type::m_p_head;
  other.m_p_head->m_p_parent = p_upper_bound;
  p_upper_bound->m_p_parent = other.m_p_head;
  p_upper_bound->m_p_left = 0;
  this->apply_update (p_upper_bound, (node_update *)this);
  base_type::split_finish (other);
  ;
  ;
}
}
namespace detail
{
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
class ov_tree_map : public Cmp_Fn,
                    public Node_And_It_Traits::node_update,
                    public types_traits<Key, Mapped, _Alloc, false>
{
private:
  typedef types_traits<Key, Mapped, _Alloc, false> traits_base;
  typedef Node_And_It_Traits traits_type;
  typedef typename remove_const<typename traits_base::value_type>::type
      non_const_value_type;
  typedef typename _Alloc::template rebind<non_const_value_type>::other
      value_allocator;
  typedef typename value_allocator::pointer value_vector;
  typedef typename traits_base::pointer mapped_pointer_;
  typedef typename traits_base::const_pointer mapped_const_pointer_;
  typedef typename traits_type::metadata_type metadata_type;
  typedef typename _Alloc::template rebind<metadata_type>::other
      metadata_allocator;
  typedef typename metadata_allocator::pointer metadata_pointer;
  typedef
      typename metadata_allocator::const_reference metadata_const_reference;
  typedef typename metadata_allocator::reference metadata_reference;
  typedef
      typename traits_type::null_node_update_pointer null_node_update_pointer;
public:
  typedef ov_tree_tag container_category;
  typedef _Alloc allocator_type;
  typedef typename _Alloc::size_type size_type;
  typedef typename _Alloc::difference_type difference_type;
  typedef Cmp_Fn cmp_fn;
  typedef typename traits_base::key_type key_type;
  typedef typename traits_base::key_pointer key_pointer;
  typedef typename traits_base::key_const_pointer key_const_pointer;
  typedef typename traits_base::key_reference key_reference;
  typedef typename traits_base::key_const_reference key_const_reference;
  typedef typename traits_base::mapped_type mapped_type;
  typedef typename traits_base::mapped_pointer mapped_pointer;
  typedef typename traits_base::mapped_const_pointer mapped_const_pointer;
  typedef typename traits_base::mapped_reference mapped_reference;
  typedef typename traits_base::mapped_const_reference mapped_const_reference;
  typedef typename traits_base::value_type value_type;
  typedef typename traits_base::pointer pointer;
  typedef typename traits_base::const_pointer const_pointer;
  typedef typename traits_base::reference reference;
  typedef typename traits_base::const_reference const_reference;
  typedef const_pointer point_const_iterator;
  typedef pointer point_iterator;
  typedef point_iterator iterator;
  typedef point_const_iterator const_iterator;
  template <typename Size_Type> class cond_dtor
  {
  public:
    cond_dtor (value_vector a_vec, iterator &r_last_it, Size_Type total_size)
        : m_a_vec (a_vec), m_r_last_it (r_last_it), m_max_size (total_size),
          m_no_action (false)
    {
    }
    ~cond_dtor ()
    {
      if (m_no_action)
        return;
      iterator it = m_a_vec;
      while (it != m_r_last_it)
        {
          it->~value_type ();
          ++it;
        }
      if (m_max_size > 0)
        value_allocator ().deallocate (m_a_vec, m_max_size);
    }
    inline void
    set_no_action ()
    {
      m_no_action = true;
    }
  protected:
    value_vector m_a_vec;
    iterator &m_r_last_it;
    const Size_Type m_max_size;
    bool m_no_action;
  };
  typedef typename traits_type::node_update node_update;
  typedef typename traits_type::node_iterator node_iterator;
  typedef typename traits_type::node_const_iterator node_const_iterator;
  ov_tree_map ();
  ov_tree_map (const Cmp_Fn &);
  ov_tree_map (const Cmp_Fn &, const node_update &);
  ov_tree_map (
      const ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
  ~ov_tree_map ();
  void swap (ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
  template <typename It> void copy_from_range (It, It);
  ;
  inline bool empty () const;
  inline size_type size () const;
  Cmp_Fn &get_cmp_fn ();
  const Cmp_Fn &get_cmp_fn () const;
  inline mapped_reference operator[](key_const_reference r_key)
  {
    ;
    point_iterator it = lower_bound (r_key);
    if (it != end () && !Cmp_Fn::operator()(r_key, (*it).first))
      {
        ;
        ;
        return it->second;
      }
    return insert_new_val (it, std::make_pair (r_key, mapped_type ()))->second;
  }
  inline std::pair<point_iterator, bool>
  insert (const_reference r_value)
  {
    ;
    key_const_reference r_key = (r_value).first;
    point_iterator it = lower_bound (r_key);
    if (it != end () && !Cmp_Fn::operator()(r_key, (*it).first))
      {
        ;
        ;
        return std::make_pair (it, false);
      }
    return std::make_pair (insert_new_val (it, r_value), true);
  }
  inline point_iterator
  lower_bound (key_const_reference r_key)
  {
    pointer it = m_a_values;
    pointer e_it = m_a_values + m_size;
    while (it != e_it)
      {
        pointer mid_it = it + ((e_it - it) >> 1);
        if (cmp_fn::operator()((*mid_it).first, r_key))
          it = ++mid_it;
        else
          e_it = mid_it;
      }
    return it;
  }
  inline point_const_iterator
  lower_bound (key_const_reference r_key) const
  {
    return const_cast<ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                  _Alloc> &> (*this).lower_bound (r_key);
  }
  inline point_iterator
  upper_bound (key_const_reference r_key)
  {
    iterator pot_it = lower_bound (r_key);
    if (pot_it != end () && !Cmp_Fn::operator()(r_key, (*pot_it).first))
      {
        ;
        return ++pot_it;
      };
    return pot_it;
  }
  inline point_const_iterator
  upper_bound (key_const_reference r_key) const
  {
    return const_cast<ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                  _Alloc> &> (*this).upper_bound (r_key);
  }
  inline point_iterator
  find (key_const_reference r_key)
  {
    ;
    iterator pot_it = lower_bound (r_key);
    if (pot_it != end () && !Cmp_Fn::operator()(r_key, (*pot_it).first))
      {
        ;
        return pot_it;
      };
    return end ();
  }
  inline point_const_iterator
  find (key_const_reference r_key) const
  {
    return (const_cast<ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                                   _Alloc> &> (*this).find (r_key));
  }
  bool erase (key_const_reference);
  template <typename Pred> inline size_type erase_if (Pred);
  inline iterator
  erase (iterator it)
  {
    return erase_imp<iterator> (it);
  }
  void clear ();
  void join (ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
  void split (key_const_reference,
              ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
  inline iterator
  begin ()
  {
    return m_a_values;
  }
  inline const_iterator
  begin () const
  {
    return m_a_values;
  }
  inline iterator
  end ()
  {
    return m_end_it;
  }
  inline const_iterator
  end () const
  {
    return m_end_it;
  }
  inline node_const_iterator node_begin () const;
  inline node_iterator node_begin ();
  inline node_const_iterator node_end () const;
  inline node_iterator node_end ();
private:
  inline void update (node_iterator, null_node_update_pointer);
  template <typename Node_Update> void update (node_iterator, Node_Update *);
  void reallocate_metadata (null_node_update_pointer, size_type);
  template <typename Node_Update_>
  void reallocate_metadata (Node_Update_ *, size_type);
  template <typename It> void copy_from_ordered_range (It, It);
  void
  value_swap (ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &);
  template <typename It> void copy_from_ordered_range (It, It, It, It);
  template <typename Ptr>
  inline static Ptr
  mid_pointer (Ptr p_begin, Ptr p_end)
  {
    ;
    return (p_begin + (p_end - p_begin) / 2);
  }
  inline iterator
  insert_new_val (iterator it, const_reference r_value)
  {
    typename _Alloc::group_adjustor adjust (m_size);
    ;
    value_vector a_values = s_value_alloc.allocate (m_size + 1);
    iterator source_it = begin ();
    iterator source_end_it = end ();
    iterator target_it = a_values;
    iterator ret_it;
    cond_dtor<size_type> cd (a_values, target_it, m_size + 1);
    while (source_it != it)
      {
        new (const_cast<void *> (static_cast<const void *> (target_it)))
            value_type (*source_it++);
        ++target_it;
      }
    new (const_cast<void *> (static_cast<const void *> (ret_it = target_it)))
        value_type (r_value);
    ++target_it;
    while (source_it != source_end_it)
      {
        new (const_cast<void *> (static_cast<const void *> (target_it)))
            value_type (*source_it++);
        ++target_it;
      }
    reallocate_metadata ((node_update *)this, m_size + 1);
    cd.set_no_action ();
    if (m_size != 0)
      {
        cond_dtor<size_type> cd1 (m_a_values, m_end_it, m_size);
      }
    ++m_size;
    m_a_values = a_values;
    m_end_it = m_a_values + m_size;
    ;
    ;
    update (node_begin (), (node_update *)this);
    ;
    return ret_it;
  }
  template <typename It> It erase_imp (It);
  inline node_const_iterator PB_DS_node_begin_imp () const;
  inline node_const_iterator PB_DS_node_end_imp () const;
  inline node_iterator PB_DS_node_begin_imp ();
  inline node_iterator PB_DS_node_end_imp ();
private:
  static value_allocator s_value_alloc;
  static metadata_allocator s_metadata_alloc;
  value_vector m_a_values;
  metadata_pointer m_a_metadata;
  iterator m_end_it;
  size_type m_size;
};
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
typename ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                     _Alloc>::value_allocator
    ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                _Alloc>::s_value_alloc;
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
typename ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                     _Alloc>::metadata_allocator
    ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                _Alloc>::s_metadata_alloc;
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::ov_tree_map ()
    : m_a_values (0), m_a_metadata (0), m_end_it (0), m_size (0)
{
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::ov_tree_map (
    const Cmp_Fn &r_cmp_fn)
    : cmp_fn (r_cmp_fn), m_a_values (0), m_a_metadata (0), m_end_it (0),
      m_size (0)
{
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::ov_tree_map (
    const Cmp_Fn &r_cmp_fn, const node_update &r_nodeu)
    : cmp_fn (r_cmp_fn), node_update (r_nodeu), m_a_values (0),
      m_a_metadata (0), m_end_it (0), m_size (0)
{
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::ov_tree_map (
    const ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &other)
    : cmp_fn (other), node_update (other), m_a_values (0), m_a_metadata (0),
      m_end_it (0), m_size (0)
{
  copy_from_ordered_range (other.begin (), other.end ());
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
template <typename It>
inline void
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::copy_from_range (
    It first_it, It last_it)
{
  typedef std::map<key_type, mapped_type, Cmp_Fn,
                   typename _Alloc::template rebind<value_type>::other>
      map_type;
  map_type m (first_it, last_it);
  copy_from_ordered_range (m.begin (), m.end ());
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
template <typename It>
void
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
            _Alloc>::copy_from_ordered_range (It first_it, It last_it)
{
  const size_type len = std::distance (first_it, last_it);
  if (len == 0)
    return;
  value_vector a_values = s_value_alloc.allocate (len);
  iterator target_it = a_values;
  It source_it = first_it;
  It source_end_it = last_it;
  cond_dtor<size_type> cd (a_values, target_it, len);
  while (source_it != source_end_it)
    {
      void *__v = const_cast<void *> (static_cast<const void *> (target_it));
      new (__v) value_type (*source_it++);
      ++target_it;
    }
  reallocate_metadata ((node_update *)this, len);
  cd.set_no_action ();
  m_a_values = a_values;
  m_size = len;
  m_end_it = m_a_values + m_size;
  update (PB_DS_node_begin_imp (), (node_update *)this);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
template <typename It>
void
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
            _Alloc>::copy_from_ordered_range (It first_it, It last_it,
                                              It other_first_it,
                                              It other_last_it)
{
  clear ();
  const size_type len = std::distance (first_it, last_it)
                        + std::distance (other_first_it, other_last_it);
  value_vector a_values = s_value_alloc.allocate (len);
  iterator target_it = a_values;
  It source_it = first_it;
  It source_end_it = last_it;
  cond_dtor<size_type> cd (a_values, target_it, len);
  while (source_it != source_end_it)
    {
      new (const_cast<void *> (static_cast<const void *> (target_it)))
          value_type (*source_it++);
      ++target_it;
    }
  source_it = other_first_it;
  source_end_it = other_last_it;
  while (source_it != source_end_it)
    {
      new (const_cast<void *> (static_cast<const void *> (target_it)))
          value_type (*source_it++);
      ++target_it;
    }
  reallocate_metadata ((node_update *)this, len);
  cd.set_no_action ();
  m_a_values = a_values;
  m_size = len;
  m_end_it = m_a_values + m_size;
  update (PB_DS_node_begin_imp (), (node_update *)this);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::swap (
    ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &other)
{
  ;
  ;
  value_swap (other);
  std::swap (static_cast<cmp_fn &> (*this), static_cast<cmp_fn &> (other));
  std::swap (static_cast<traits_base &> (*this),
             static_cast<traits_base &> (other));
  ;
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::value_swap (
    ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &other)
{
  ;
  std::swap (m_a_values, other.m_a_values);
  std::swap (m_a_metadata, other.m_a_metadata);
  std::swap (m_size, other.m_size);
  std::swap (m_end_it, other.m_end_it);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::~ov_tree_map ()
{
  ;
  cond_dtor<size_type> cd (m_a_values, m_end_it, m_size);
  reallocate_metadata ((node_update *)this, 0);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline void
    ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::update (
        node_iterator, null_node_update_pointer)
{
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
template <typename Node_Update>
void
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::update (
    node_iterator nd_it, Node_Update *p_update)
{
  node_const_iterator end_it = PB_DS_node_end_imp ();
  if (nd_it != end_it)
    {
      update (nd_it.get_l_child (), p_update);
      update (nd_it.get_r_child (), p_update);
      node_update::operator()(nd_it, end_it);
    }
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                            _Alloc>::node_const_iterator
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::node_begin ()
    const
{
  return PB_DS_node_begin_imp ();
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                            _Alloc>::node_const_iterator
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::node_end () const
{
  return PB_DS_node_end_imp ();
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                            _Alloc>::node_iterator
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::node_begin ()
{
  return PB_DS_node_begin_imp ();
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                            _Alloc>::node_iterator
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::node_end ()
{
  return PB_DS_node_end_imp ();
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                            _Alloc>::node_const_iterator
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
            _Alloc>::PB_DS_node_begin_imp () const
{
  return node_const_iterator (
      const_cast<pointer> (mid_pointer (begin (), end ())),
      const_cast<pointer> (begin ()), const_cast<pointer> (end ()),
      (m_a_metadata == 0) ? 0
                          : mid_pointer (m_a_metadata, m_a_metadata + m_size));
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                            _Alloc>::node_const_iterator
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
            _Alloc>::PB_DS_node_end_imp () const
{
  return node_const_iterator (end (), end (), end (),
                              (m_a_metadata == 0) ? 0 : m_a_metadata + m_size);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                            _Alloc>::node_iterator
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
            _Alloc>::PB_DS_node_begin_imp ()
{
  return node_iterator (
      mid_pointer (begin (), end ()), begin (), end (),
      (m_a_metadata == 0) ? 0
                          : mid_pointer (m_a_metadata, m_a_metadata + m_size));
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                            _Alloc>::node_iterator
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
            _Alloc>::PB_DS_node_end_imp ()
{
  return node_iterator (end (), end (), end (),
                        (m_a_metadata == 0) ? 0 : m_a_metadata + m_size);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::clear ()
{
  ;
  if (m_size == 0)
    {
      return;
    }
  else
    {
      reallocate_metadata ((node_update *)this, 0);
      cond_dtor<size_type> cd (m_a_values, m_end_it, m_size);
    };
  m_a_values = 0;
  m_size = 0;
  m_end_it = m_a_values;
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
template <typename Pred>
inline typename ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                            _Alloc>::size_type
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::erase_if (
    Pred pred)
{
  ;
  typename _Alloc::group_adjustor adjust (m_size);
  size_type new_size = 0;
  size_type num_val_ersd = 0;
  for (iterator source_it = begin (); source_it != m_end_it; ++source_it)
    if (!pred (*source_it))
      ++new_size;
    else
      ++num_val_ersd;
  if (new_size == 0)
    {
      clear ();
      return num_val_ersd;
    }
  value_vector a_new_values = s_value_alloc.allocate (new_size);
  iterator target_it = a_new_values;
  cond_dtor<size_type> cd (a_new_values, target_it, new_size);
  ;
  ;
  for (iterator source_it = begin (); source_it != m_end_it; ++source_it)
    {
      if (!pred (*source_it))
        {
          new (const_cast<void *> (static_cast<const void *> (target_it)))
              value_type (*source_it);
          ;
          ;
          ++target_it;
        }
    }
  reallocate_metadata ((node_update *)this, new_size);
  cd.set_no_action ();
  {
    cond_dtor<size_type> cd1 (m_a_values, m_end_it, m_size);
  }
  m_a_values = a_new_values;
  m_size = new_size;
  m_end_it = target_it;
  update (node_begin (), (node_update *)this);
  ;
  return num_val_ersd;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
template <typename It>
It
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::erase_imp (It it)
{
  ;
  if (it == end ())
    return end ();
  ;
  typename _Alloc::group_adjustor adjust (m_size);
  ;
  value_vector a_values = s_value_alloc.allocate (m_size - 1);
  iterator source_it = begin ();
  iterator source_end_it = end ();
  iterator target_it = a_values;
  iterator ret_it = end ();
  cond_dtor<size_type> cd (a_values, target_it, m_size - 1);
  ;
  while (source_it != source_end_it)
    {
      if (source_it != it)
        {
          ;
          ;
          new (const_cast<void *> (static_cast<const void *> (target_it)))
              value_type (*source_it);
          ++target_it;
        }
      else
        ret_it = target_it;
      ++source_it;
    };
  reallocate_metadata ((node_update *)this, m_size - 1);
  cd.set_no_action ();
  ;
  {
    cond_dtor<size_type> cd1 (m_a_values, m_end_it, m_size);
  }
  m_a_values = a_values;
  --m_size;
  m_end_it = m_a_values + m_size;
  update (node_begin (), (node_update *)this);
  ;
  return It (ret_it);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
bool
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::erase (
    key_const_reference r_key)
{
  point_iterator it = find (r_key);
  if (it == end ())
    return false;
  erase (it);
  return true;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                 _Alloc>::reallocate_metadata (null_node_update_pointer,
                                               size_type)
{
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
template <typename Node_Update_>
void
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
            _Alloc>::reallocate_metadata (Node_Update_ *, size_type new_size)
{
  metadata_pointer a_new_metadata_vec
      = (new_size == 0) ? 0 : s_metadata_alloc.allocate (new_size);
  if (m_a_metadata != 0)
    {
      for (size_type i = 0; i < m_size; ++i)
        m_a_metadata[i]. ~metadata_type ();
      s_metadata_alloc.deallocate (m_a_metadata, m_size);
    }
  std::swap (m_a_metadata, a_new_metadata_vec);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline typename ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                            _Alloc>::size_type
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::size () const
{
  ;
  return m_size;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
inline bool
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::empty () const
{
  return size () == 0;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::split (
    key_const_reference r_key,
    ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &other)
{
  ;
  ;
  if (m_size == 0)
    {
      other.clear ();
      return;
    }
  if (Cmp_Fn::operator()(r_key, (*begin ()).first))
    {
      value_swap (other);
      ;
      ;
      return;
    }
  if (!Cmp_Fn::operator()(r_key, (*(end () - 1)).first))
    {
      return;
    }
  if (m_size == 1)
    {
      value_swap (other);
      ;
      ;
      return;
    }
  iterator it = upper_bound (r_key);
  ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> new_other (
      other, other);
  new_other.copy_from_ordered_range (it, end ());
  ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> new_this (
      *this, *this);
  new_this.copy_from_ordered_range (begin (), it);
  other.update (other.node_begin (), (node_update *)(&other));
  update (node_begin (), (node_update *)this);
  other.value_swap (new_other);
  value_swap (new_this);
  ;
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
void
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::join (
    ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> &other)
{
  ;
  ;
  if (other.m_size == 0)
    return;
  if (m_size == 0)
    {
      value_swap (other);
      ;
      ;
      return;
    }
  const bool greater
      = Cmp_Fn::operator()((*(end () - 1)).first, (*other.begin ()).first);
  const bool lesser
      = Cmp_Fn::operator()((*(other.end () - 1)).first, (*begin ()).first);
  if (!greater && !lesser)
    __throw_join_error ();
  ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc> new_this (
      *this, *this);
  if (greater)
    new_this.copy_from_ordered_range (begin (), end (), other.begin (),
                                      other.end ());
  else
    new_this.copy_from_ordered_range (other.begin (), other.end (), begin (),
                                      end ());
  value_swap (new_this);
  other.clear ();
  ;
  ;
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
Cmp_Fn &
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::get_cmp_fn ()
{
  return (*this);
}
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
const Cmp_Fn &
ov_tree_map<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>::get_cmp_fn ()
    const
{
  return (*this);
}
}
namespace detail
{
template <typename Key, typename Hash_Fn, typename _Alloc,
          typename Comb_Hash_Fn, bool Store_Hash>
class ranged_hash_fn;
template <typename Key, typename Hash_Fn, typename _Alloc,
          typename Comb_Hash_Fn>
class ranged_hash_fn<Key, Hash_Fn, _Alloc, Comb_Hash_Fn, false>
    : public Hash_Fn, public Comb_Hash_Fn
{
protected:
  typedef typename _Alloc::size_type size_type;
  typedef Hash_Fn hash_fn_base;
  typedef Comb_Hash_Fn comb_hash_fn_base;
  typedef typename _Alloc::template rebind<Key>::other key_allocator;
  typedef typename key_allocator::const_reference key_const_reference;
  ;
  ;
  ;
  ;
  ;
  ;
};
template <typename Key, typename Hash_Fn, typename _Alloc,
          typename Comb_Hash_Fn>
class ranged_hash_fn<Key, Hash_Fn, _Alloc, Comb_Hash_Fn, true>
    : public Hash_Fn, public Comb_Hash_Fn
{
protected:
  typedef typename _Alloc::size_type size_type;
  typedef std::pair<size_type, size_type> comp_hash;
  typedef Hash_Fn hash_fn_base;
  typedef Comb_Hash_Fn comb_hash_fn_base;
  typedef typename _Alloc::template rebind<Key>::other key_allocator;
  typedef typename key_allocator::const_reference key_const_reference;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
};
template <typename Key, typename _Alloc, typename Comb_Hash_Fn>
class ranged_hash_fn<Key, null_type, _Alloc, Comb_Hash_Fn, false>
    : public Comb_Hash_Fn
{
protected:
  typedef typename _Alloc::size_type size_type;
  typedef Comb_Hash_Fn comb_hash_fn_base;
  ;
  ;
  ;
  ;
};
template <typename Key, typename _Alloc, typename Comb_Hash_Fn>
class ranged_hash_fn<Key, null_type, _Alloc, Comb_Hash_Fn, true>
    : public Comb_Hash_Fn
{
protected:
  typedef typename _Alloc::size_type size_type;
  typedef Comb_Hash_Fn comb_hash_fn_base;
  ;
  ;
  ;
  ;
};
}
namespace detail
{
template <typename Key, typename Eq_Fn, typename _Alloc, bool Store_Hash>
struct hash_eq_fn;
template <typename Key, typename Mapped, typename Hash_Fn, typename Eq_Fn,
          typename _Alloc, bool Store_Hash, typename Comb_Hash_Fn,
          typename Resize_Policy>
class cc_ht_map
    : public hash_eq_fn<Key, Eq_Fn, _Alloc, Store_Hash>,
      public Resize_Policy,
      public ranged_hash_fn<Key, Hash_Fn, _Alloc, Comb_Hash_Fn, Store_Hash>,
      public types_traits<Key, Mapped, _Alloc, Store_Hash>
{
private:
  typedef types_traits<Key, Mapped, _Alloc, Store_Hash> traits_base;
  typedef typename traits_base::comp_hash comp_hash;
  typedef typename traits_base::value_type value_type_;
  typedef typename traits_base::pointer pointer_;
  typedef typename traits_base::const_pointer const_pointer_;
  typedef typename traits_base::reference reference_;
  typedef typename traits_base::const_reference const_reference_;
  struct entry : public traits_base::stored_data_type
  {
    typename _Alloc::template rebind<entry>::other::pointer m_p_next;
  };
  typedef cond_dealtor<entry, _Alloc> cond_dealtor_t;
  typedef typename _Alloc::template rebind<entry>::other entry_allocator;
  typedef typename entry_allocator::pointer entry_pointer;
  typedef typename entry_allocator::const_pointer const_entry_pointer;
  typedef typename entry_allocator::reference entry_reference;
  typedef typename entry_allocator::const_reference const_entry_reference;
  typedef typename _Alloc::template rebind<entry_pointer>::other
      entry_pointer_allocator;
  typedef typename entry_pointer_allocator::pointer entry_pointer_array;
  typedef ranged_hash_fn<Key, Hash_Fn, _Alloc, Comb_Hash_Fn, Store_Hash>
      ranged_hash_fn_base;
  typedef hash_eq_fn<Key, Eq_Fn, _Alloc, Store_Hash> hash_eq_fn_base;
  typedef Resize_Policy resize_base;
  class point_iterator_;
  class point_const_iterator_
  {
  public:
    typedef trivial_iterator_tag iterator_category;
    typedef trivial_iterator_difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    const_pointer m_p_value;
    friend class point_iterator_;
    friend class cc_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                           Comb_Hash_Fn, Resize_Policy>;
  };
  class point_iterator_
  {
  public:
    typedef trivial_iterator_tag iterator_category;
    typedef trivial_iterator_difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    friend class point_const_iterator_;
    friend class cc_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                           Comb_Hash_Fn, Resize_Policy>;
  protected:
    pointer m_p_value;
  };
  class const_iterator_ : public point_const_iterator_
  {
  public:
    typedef std::forward_iterator_tag iterator_category;
    typedef typename _Alloc::difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
  protected:
    typedef point_const_iterator_ base_type;
    ;
    const cc_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                    Comb_Hash_Fn, Resize_Policy> *m_p_tbl;
    std::pair<entry_pointer, typename _Alloc::size_type> m_pos;
    friend class cc_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                           Comb_Hash_Fn, Resize_Policy>;
  };
  class iterator_ : public const_iterator_
  {
  public:
    typedef std::forward_iterator_tag iterator_category;
    typedef typename _Alloc::difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    typedef const_iterator_ base_type;
    ;
    friend class cc_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                           Comb_Hash_Fn, Resize_Policy>;
  };
public:
  typedef _Alloc allocator_type;
  typedef typename _Alloc::size_type size_type;
  typedef typename _Alloc::difference_type difference_type;
  typedef Hash_Fn hash_fn;
  typedef Eq_Fn eq_fn;
  typedef Comb_Hash_Fn comb_hash_fn;
  typedef Resize_Policy resize_policy;
  enum
  {
    store_hash = Store_Hash
  };
  typedef typename traits_base::key_type key_type;
  typedef typename traits_base::key_pointer key_pointer;
  typedef typename traits_base::key_const_pointer key_const_pointer;
  typedef typename traits_base::key_reference key_reference;
  typedef typename traits_base::key_const_reference key_const_reference;
  typedef typename traits_base::mapped_type mapped_type;
  typedef typename traits_base::mapped_pointer mapped_pointer;
  typedef typename traits_base::mapped_const_pointer mapped_const_pointer;
  typedef typename traits_base::mapped_reference mapped_reference;
  typedef typename traits_base::mapped_const_reference mapped_const_reference;
  typedef typename traits_base::value_type value_type;
  typedef typename traits_base::pointer pointer;
  typedef typename traits_base::const_pointer const_pointer;
  typedef typename traits_base::reference reference;
  typedef typename traits_base::const_reference const_reference;
  typedef point_iterator_ point_iterator;
  typedef point_const_iterator_ point_const_iterator;
  typedef iterator_ iterator;
  typedef const_iterator_ const_iterator;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
private:
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
private:
  friend class iterator_;
  friend class const_iterator_;
  static entry_allocator s_entry_allocator;
  static entry_pointer_allocator s_entry_pointer_allocator;
  static iterator s_end_it;
  static const_iterator s_const_end_it;
  static point_iterator s_find_end_it;
  static point_const_iterator s_const_find_end_it;
  size_type m_num_e;
  size_type m_num_used_e;
  entry_pointer_array m_entries;
  enum
  {
    store_hash_ok = !Store_Hash
                    || !is_same<Hash_Fn, __gnu_pbds::null_type>::value
  };
  typedef __gnu_pbds::detail::__static_assert_dumclass<sizeof (
      __gnu_pbds::detail::__static_assert<bool(store_hash_ok)>)>
      sth__static_assert_type;
};
template <typename Key, typename Mapped, typename Hash_Fn, typename Eq_Fn,
          typename _Alloc, bool Store_Hash, typename Comb_Hash_Fn,
          typename Resize_Policy>
typename cc_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                   Comb_Hash_Fn, Resize_Policy>::entry_allocator
    cc_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash, Comb_Hash_Fn,
              Resize_Policy>::s_entry_allocator;
template <typename Key, typename Mapped, typename Hash_Fn, typename Eq_Fn,
          typename _Alloc, bool Store_Hash, typename Comb_Hash_Fn,
          typename Resize_Policy>
typename cc_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                   Comb_Hash_Fn, Resize_Policy>::entry_pointer_allocator
    cc_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash, Comb_Hash_Fn,
              Resize_Policy>::s_entry_pointer_allocator;
template <typename Key, typename Mapped, typename Hash_Fn, typename Eq_Fn,
          typename _Alloc, bool Store_Hash, typename Comb_Hash_Fn,
          typename Resize_Policy>
typename cc_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                   Comb_Hash_Fn, Resize_Policy>::iterator
    cc_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash, Comb_Hash_Fn,
              Resize_Policy>::s_end_it;
template <typename Key, typename Mapped, typename Hash_Fn, typename Eq_Fn,
          typename _Alloc, bool Store_Hash, typename Comb_Hash_Fn,
          typename Resize_Policy>
typename cc_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                   Comb_Hash_Fn, Resize_Policy>::const_iterator
    cc_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash, Comb_Hash_Fn,
              Resize_Policy>::s_const_end_it;
}
namespace detail
{
template <typename Key, typename Hash_Fn, typename _Alloc,
          typename Comb_Probe_Fn, typename Probe_Fn, bool Store_Hash>
class ranged_probe_fn;
template <typename Key, typename Hash_Fn, typename _Alloc,
          typename Comb_Probe_Fn, typename Probe_Fn>
class ranged_probe_fn<Key, Hash_Fn, _Alloc, Comb_Probe_Fn, Probe_Fn, false>
    : public Hash_Fn, public Comb_Probe_Fn, public Probe_Fn
{
protected:
  typedef typename _Alloc::size_type size_type;
  typedef Comb_Probe_Fn comb_probe_fn_base;
  typedef Hash_Fn hash_fn_base;
  typedef Probe_Fn probe_fn_base;
  typedef typename _Alloc::template rebind<Key>::other key_allocator;
  typedef typename key_allocator::const_reference key_const_reference;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
};
template <typename Key, typename Hash_Fn, typename _Alloc,
          typename Comb_Probe_Fn, typename Probe_Fn>
class ranged_probe_fn<Key, Hash_Fn, _Alloc, Comb_Probe_Fn, Probe_Fn, true>
    : public Hash_Fn, public Comb_Probe_Fn, public Probe_Fn
{
protected:
  typedef typename _Alloc::size_type size_type;
  typedef std::pair<size_type, size_type> comp_hash;
  typedef Comb_Probe_Fn comb_probe_fn_base;
  typedef Hash_Fn hash_fn_base;
  typedef Probe_Fn probe_fn_base;
  typedef typename _Alloc::template rebind<Key>::other key_allocator;
  typedef typename key_allocator::const_reference key_const_reference;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
};
template <typename Key, typename _Alloc, typename Comb_Probe_Fn>
class ranged_probe_fn<Key, null_type, _Alloc, Comb_Probe_Fn, null_type, false>
    : public Comb_Probe_Fn
{
protected:
  typedef typename _Alloc::size_type size_type;
  typedef Comb_Probe_Fn comb_probe_fn_base;
  typedef typename _Alloc::template rebind<Key>::other key_allocator;
  typedef typename key_allocator::const_reference key_const_reference;
  ;
  ;
  ;
  ;
};
}
namespace detail
{
template <typename Key, typename Mapped, typename Hash_Fn, typename Eq_Fn,
          typename _Alloc, bool Store_Hash, typename Comb_Probe_Fn,
          typename Probe_Fn, typename Resize_Policy>
class gp_ht_map : public hash_eq_fn<Key, Eq_Fn, _Alloc, Store_Hash>,
                  public Resize_Policy,
                  public ranged_probe_fn<Key, Hash_Fn, _Alloc, Comb_Probe_Fn,
                                         Probe_Fn, Store_Hash>,
                  public types_traits<Key, Mapped, _Alloc, Store_Hash>
{
private:
  typedef types_traits<Key, Mapped, _Alloc, Store_Hash> traits_base;
  typedef typename traits_base::value_type value_type_;
  typedef typename traits_base::pointer pointer_;
  typedef typename traits_base::const_pointer const_pointer_;
  typedef typename traits_base::reference reference_;
  typedef typename traits_base::const_reference const_reference_;
  typedef typename traits_base::comp_hash comp_hash;
  enum entry_status
  {
    empty_entry_status,
    valid_entry_status,
    erased_entry_status
  } __attribute__ ((packed));
  struct entry : public traits_base::stored_data_type
  {
    entry_status m_stat;
  };
  typedef typename _Alloc::template rebind<entry>::other entry_allocator;
  typedef typename entry_allocator::pointer entry_pointer;
  typedef typename entry_allocator::const_pointer const_entry_pointer;
  typedef typename entry_allocator::reference entry_reference;
  typedef typename entry_allocator::const_reference const_entry_reference;
  typedef typename entry_allocator::pointer entry_array;
  typedef ranged_probe_fn<Key, Hash_Fn, _Alloc, Comb_Probe_Fn, Probe_Fn,
                          Store_Hash> ranged_probe_fn_base;
  typedef hash_eq_fn<Key, Eq_Fn, _Alloc, Store_Hash> hash_eq_fn_base;
  typedef Resize_Policy resize_base;
  class point_iterator_;
  class point_const_iterator_
  {
  public:
    typedef trivial_iterator_tag iterator_category;
    typedef trivial_iterator_difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    const_pointer m_p_value;
    friend class point_iterator_;
    friend class gp_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                           Comb_Probe_Fn, Probe_Fn, Resize_Policy>;
  };
  class point_iterator_
  {
  public:
    typedef trivial_iterator_tag iterator_category;
    typedef trivial_iterator_difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    friend class point_const_iterator_;
    friend class gp_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                           Comb_Probe_Fn, Probe_Fn, Resize_Policy>;
  protected:
    pointer m_p_value;
  };
  class const_iterator_ : public point_const_iterator_
  {
  public:
    typedef std::forward_iterator_tag iterator_category;
    typedef typename _Alloc::difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
  protected:
    typedef point_const_iterator_ base_type;
    ;
    const gp_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                    Comb_Probe_Fn, Probe_Fn, Resize_Policy> *m_p_tbl;
    typename _Alloc::size_type m_pos;
    friend class gp_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                           Comb_Probe_Fn, Probe_Fn, Resize_Policy>;
  };
  class iterator_ : public const_iterator_
  {
  public:
    typedef std::forward_iterator_tag iterator_category;
    typedef typename _Alloc::difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    typedef const_iterator_ base_type;
    ;
    friend class gp_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                           Comb_Probe_Fn, Probe_Fn, Resize_Policy>;
  };
public:
  typedef _Alloc allocator_type;
  typedef typename _Alloc::size_type size_type;
  typedef typename _Alloc::difference_type difference_type;
  typedef Hash_Fn hash_fn;
  typedef Eq_Fn eq_fn;
  typedef Probe_Fn probe_fn;
  typedef Comb_Probe_Fn comb_probe_fn;
  typedef Resize_Policy resize_policy;
  enum
  {
    store_hash = Store_Hash
  };
  typedef typename traits_base::key_type key_type;
  typedef typename traits_base::key_pointer key_pointer;
  typedef typename traits_base::key_const_pointer key_const_pointer;
  typedef typename traits_base::key_reference key_reference;
  typedef typename traits_base::key_const_reference key_const_reference;
  typedef typename traits_base::mapped_type mapped_type;
  typedef typename traits_base::mapped_pointer mapped_pointer;
  typedef typename traits_base::mapped_const_pointer mapped_const_pointer;
  typedef typename traits_base::mapped_reference mapped_reference;
  typedef typename traits_base::mapped_const_reference mapped_const_reference;
  typedef typename traits_base::value_type value_type;
  typedef typename traits_base::pointer pointer;
  typedef typename traits_base::const_pointer const_pointer;
  typedef typename traits_base::reference reference;
  typedef typename traits_base::const_reference const_reference;
  typedef point_iterator_ point_iterator;
  typedef point_const_iterator_ point_const_iterator;
  typedef iterator_ iterator;
  typedef const_iterator_ const_iterator;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
private:
  friend class iterator_;
  friend class const_iterator_;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  static entry_allocator s_entry_allocator;
  static iterator s_end_it;
  static const_iterator s_const_end_it;
  size_type m_num_e;
  size_type m_num_used_e;
  entry_pointer m_entries;
  enum
  {
    store_hash_ok = !Store_Hash
                    || !is_same<Hash_Fn, __gnu_pbds::null_type>::value
  };
  typedef __gnu_pbds::detail::__static_assert_dumclass<sizeof (
      __gnu_pbds::detail::__static_assert<bool(store_hash_ok)>)>
      sth__static_assert_type;
};
template <typename Key, typename Mapped, typename Hash_Fn, typename Eq_Fn,
          typename _Alloc, bool Store_Hash, typename Comb_Probe_Fn,
          typename Probe_Fn, typename Resize_Policy>
typename gp_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                   Comb_Probe_Fn, Probe_Fn, Resize_Policy>::entry_allocator
    gp_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash, Comb_Probe_Fn,
              Probe_Fn, Resize_Policy>::s_entry_allocator;
template <typename Key, typename Mapped, typename Hash_Fn, typename Eq_Fn,
          typename _Alloc, bool Store_Hash, typename Comb_Probe_Fn,
          typename Probe_Fn, typename Resize_Policy>
typename gp_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                   Comb_Probe_Fn, Probe_Fn, Resize_Policy>::iterator
    gp_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash, Comb_Probe_Fn,
              Probe_Fn, Resize_Policy>::s_end_it;
template <typename Key, typename Mapped, typename Hash_Fn, typename Eq_Fn,
          typename _Alloc, bool Store_Hash, typename Comb_Probe_Fn,
          typename Probe_Fn, typename Resize_Policy>
typename gp_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                   Comb_Probe_Fn, Probe_Fn, Resize_Policy>::const_iterator
    gp_ht_map<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash, Comb_Probe_Fn,
              Probe_Fn, Resize_Policy>::s_const_end_it;
}
namespace detail
{
struct pat_trie_base
{
  enum node_type
  {
    i_node,
    leaf_node,
    head_node
  };
  template <typename Metadata, typename _Alloc> struct _Metadata
  {
    typedef Metadata metadata_type;
    typedef _Alloc allocator_type;
    typedef typename _Alloc::template rebind<Metadata> __rebind_m;
    typedef typename __rebind_m::other::const_reference const_reference;
    ;
    metadata_type m_metadata;
  };
  template <typename _Alloc> struct _Metadata<null_type, _Alloc>
  {
    typedef null_type metadata_type;
    typedef _Alloc allocator_type;
  };
  template <typename _ATraits, typename Metadata>
  struct _Node_base : public Metadata
  {
  private:
    typedef typename Metadata::allocator_type _Alloc;
  public:
    typedef _Alloc allocator_type;
    typedef _ATraits access_traits;
    typedef typename _ATraits::type_traits type_traits;
    typedef typename _Alloc::template rebind<_Node_base> __rebind_n;
    typedef typename __rebind_n::other::pointer node_pointer;
    node_pointer m_p_parent;
    const node_type m_type;
    ;
    typedef typename _Alloc::template rebind<_ATraits> __rebind_at;
    typedef typename __rebind_at::other::const_pointer a_const_pointer;
    typedef typename _ATraits::const_iterator a_const_iterator;
  };
  template <typename _ATraits, typename Metadata>
  struct _Head : public _Node_base<_ATraits, Metadata>
  {
    typedef _Node_base<_ATraits, Metadata> base_type;
    typedef typename base_type::type_traits type_traits;
    typedef typename base_type::node_pointer node_pointer;
    node_pointer m_p_min;
    node_pointer m_p_max;
    ;
  };
  template <typename _ATraits, typename Metadata>
  struct _Leaf : public _Node_base<_ATraits, Metadata>
  {
    typedef _Node_base<_ATraits, Metadata> base_type;
    typedef typename base_type::type_traits type_traits;
    typedef typename type_traits::value_type value_type;
    typedef typename type_traits::reference reference;
    typedef typename type_traits::const_reference const_reference;
  private:
    value_type m_value;
    ;
  public:
    ;
    ;
    ;
  };
  template <typename _ATraits, typename Metadata>
  struct _Inode : public _Node_base<_ATraits, Metadata>
  {
    typedef _Node_base<_ATraits, Metadata> base_type;
    typedef typename base_type::type_traits type_traits;
    typedef typename base_type::access_traits access_traits;
    typedef typename type_traits::value_type value_type;
    typedef typename base_type::allocator_type _Alloc;
    typedef _Alloc allocator_type;
    typedef typename _Alloc::size_type size_type;
  private:
    typedef typename base_type::a_const_pointer a_const_pointer;
    typedef typename base_type::a_const_iterator a_const_iterator;
    typedef typename base_type::node_pointer node_pointer;
    typedef typename _Alloc::template rebind<base_type> __rebind_n;
    typedef typename __rebind_n::other::const_pointer node_const_pointer;
    typedef _Leaf<_ATraits, Metadata> leaf;
    typedef typename _Alloc::template rebind<leaf>::other __rebind_l;
    typedef typename __rebind_l::pointer leaf_pointer;
    typedef typename __rebind_l::const_pointer leaf_const_pointer;
    typedef typename _Alloc::template rebind<_Inode>::other __rebind_in;
    typedef typename __rebind_in::pointer inode_pointer;
    typedef typename __rebind_in::const_pointer inode_const_pointer;
    ;
  public:
    typedef typename _Alloc::template rebind<node_pointer>::other __rebind_np;
    typedef typename __rebind_np::pointer node_pointer_pointer;
    typedef typename __rebind_np::reference node_pointer_reference;
    enum
    {
      arr_size = _ATraits::max_size + 1
    };
    typedef __gnu_pbds::detail::__static_assert_dumclass<sizeof (
        __gnu_pbds::detail::__static_assert<bool(arr_size >= 2)>)>
        min_arr_size__static_assert_type;
    struct const_iterator
    {
      node_pointer_pointer m_p_p_cur;
      node_pointer_pointer m_p_p_end;
      typedef std::forward_iterator_tag iterator_category;
      typedef typename _Alloc::difference_type difference_type;
      typedef node_pointer value_type;
      typedef node_pointer_pointer pointer;
      typedef node_pointer_reference reference;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
    protected:
    };
    struct iterator : public const_iterator
    {
    public:
      typedef std::forward_iterator_tag iterator_category;
      typedef typename _Alloc::difference_type difference_type;
      typedef node_pointer value_type;
      typedef node_pointer_pointer pointer;
      typedef node_pointer_reference reference;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
    };
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  private:
    ;
    ;
    static __rebind_l s_leaf_alloc;
    static __rebind_in s_inode_alloc;
    const size_type m_e_ind;
    a_const_iterator m_pref_b_it;
    a_const_iterator m_pref_e_it;
    node_pointer m_a_p_children[arr_size];
  };
  template <typename Node, typename Leaf, typename Head, typename Inode,
            bool Is_Forward_Iterator>
  class _CIter
  {
  public:
    typedef typename Node::allocator_type allocator_type;
    typedef typename Node::type_traits type_traits;
    typedef std::bidirectional_iterator_tag iterator_category;
    typedef typename allocator_type::difference_type difference_type;
    typedef typename type_traits::value_type value_type;
    typedef typename type_traits::pointer pointer;
    typedef typename type_traits::reference reference;
    typedef typename type_traits::const_pointer const_pointer;
    typedef typename type_traits::const_reference const_reference;
    typedef allocator_type _Alloc;
    typedef typename _Alloc::template rebind<Node> __rebind_n;
    typedef typename __rebind_n::other::pointer node_pointer;
    typedef typename _Alloc::template rebind<Leaf> __rebind_l;
    typedef typename __rebind_l::other::pointer leaf_pointer;
    typedef typename __rebind_l::other::const_pointer leaf_const_pointer;
    typedef typename _Alloc::template rebind<Head> __rebind_h;
    typedef typename __rebind_h::other::pointer head_pointer;
    typedef typename _Alloc::template rebind<Inode> __rebind_in;
    typedef typename __rebind_in::other::pointer inode_pointer;
    typedef typename Inode::iterator inode_iterator;
    node_pointer m_p_nd;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  };
  template <typename Node, typename Leaf, typename Head, typename Inode,
            bool Is_Forward_Iterator>
  class _Iter : public _CIter<Node, Leaf, Head, Inode, Is_Forward_Iterator>
  {
  public:
    typedef _CIter<Node, Leaf, Head, Inode, Is_Forward_Iterator> base_type;
    typedef typename base_type::allocator_type allocator_type;
    typedef typename base_type::type_traits type_traits;
    typedef typename type_traits::value_type value_type;
    typedef typename type_traits::pointer pointer;
    typedef typename type_traits::reference reference;
    typedef typename base_type::node_pointer node_pointer;
    typedef typename base_type::leaf_pointer leaf_pointer;
    typedef typename base_type::leaf_const_pointer leaf_const_pointer;
    typedef typename base_type::head_pointer head_pointer;
    typedef typename base_type::inode_pointer inode_pointer;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  };
  template <typename Node, typename Leaf, typename Head, typename Inode,
            typename _CIterator, typename Iterator, typename _Alloc>
  class _Node_citer
  {
  protected:
    typedef typename _Alloc::template rebind<Node> __rebind_n;
    typedef typename __rebind_n::other::pointer node_pointer;
    typedef typename _Alloc::template rebind<Leaf> __rebind_l;
    typedef typename __rebind_l::other::pointer leaf_pointer;
    typedef typename __rebind_l::other::const_pointer leaf_const_pointer;
    typedef typename _Alloc::template rebind<Inode> __rebind_in;
    typedef typename __rebind_in::other::pointer inode_pointer;
    typedef typename __rebind_in::other::const_pointer inode_const_pointer;
    typedef typename Node::a_const_pointer a_const_pointer;
    typedef typename Node::a_const_iterator a_const_iterator;
  private:
    ;
    ;
  public:
    typedef trivial_iterator_tag iterator_category;
    typedef trivial_iterator_difference_type difference_type;
    typedef typename _Alloc::size_type size_type;
    typedef _CIterator value_type;
    typedef value_type reference;
    typedef value_type const_reference;
    typedef typename Node::metadata_type metadata_type;
    typedef typename _Alloc::template rebind<metadata_type> __rebind_m;
    typedef typename __rebind_m::other __rebind_ma;
    typedef typename __rebind_ma::const_reference metadata_const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    node_pointer m_p_nd;
    a_const_pointer m_p_traits;
  };
  template <typename Node, typename Leaf, typename Head, typename Inode,
            typename _CIterator, typename Iterator, typename _Alloc>
  class _Node_iter : public _Node_citer<Node, Leaf, Head, Inode, _CIterator,
                                        Iterator, _Alloc>
  {
  private:
    typedef _Node_citer<Node, Leaf, Head, Inode, _CIterator, Iterator, _Alloc>
        base_type;
    typedef typename _Alloc::template rebind<Node> __rebind_n;
    typedef typename __rebind_n::other::pointer node_pointer;
    typedef typename base_type::inode_pointer inode_pointer;
    typedef typename base_type::a_const_pointer a_const_pointer;
    typedef Iterator iterator;
  public:
    typedef typename base_type::size_type size_type;
    typedef Iterator value_type;
    typedef value_type reference;
    typedef value_type const_reference;
    ;
    ;
    ;
  };
};
template <typename Key, typename Mapped, typename Node_And_It_Traits,
          typename _Alloc>
class pat_trie_map : public Node_And_It_Traits::synth_access_traits,
                     public Node_And_It_Traits::node_update,
                     public types_traits<Key, Mapped, _Alloc, false>,
                     public pat_trie_base
{
private:
  typedef pat_trie_base base_type;
  typedef types_traits<Key, Mapped, _Alloc, false> traits_base;
  typedef Node_And_It_Traits traits_type;
  typedef typename traits_type::synth_access_traits synth_access_traits;
  typedef typename synth_access_traits::const_iterator a_const_iterator;
  typedef typename traits_type::node node;
  typedef typename _Alloc::template rebind<node> __rebind_n;
  typedef typename __rebind_n::other::const_pointer node_const_pointer;
  typedef typename __rebind_n::other::pointer node_pointer;
  typedef typename traits_type::head head;
  typedef typename _Alloc::template rebind<head> __rebind_h;
  typedef typename __rebind_h::other head_allocator;
  typedef typename head_allocator::pointer head_pointer;
  typedef typename traits_type::leaf leaf;
  typedef typename _Alloc::template rebind<leaf> __rebind_l;
  typedef typename __rebind_l::other leaf_allocator;
  typedef typename leaf_allocator::pointer leaf_pointer;
  typedef typename leaf_allocator::const_pointer leaf_const_pointer;
  typedef typename traits_type::inode inode;
  typedef typename inode::iterator inode_iterator;
  typedef typename _Alloc::template rebind<inode> __rebind_in;
  typedef typename __rebind_in::other __rebind_ina;
  typedef typename __rebind_in::other inode_allocator;
  typedef typename __rebind_ina::pointer inode_pointer;
  typedef typename __rebind_ina::const_pointer inode_const_pointer;
  class cond_dealtor
  {
  protected:
    leaf_pointer m_p_nd;
    bool m_no_action_dtor;
    bool m_call_destructor;
  public:
    ;
    ;
    ;
    ;
  };
  class branch_bag
  {
  private:
    typedef inode_pointer __inp;
    typedef typename _Alloc::template rebind<__inp>::other __rebind_inp;
    typedef std::list<__inp, __rebind_inp> bag_type;
    bag_type m_bag;
  public:
    ;
    ;
    ;
    ;
  };
  typedef
      typename traits_type::null_node_update_pointer null_node_update_pointer;
public:
  typedef pat_trie_tag container_category;
  typedef _Alloc allocator_type;
  typedef typename _Alloc::size_type size_type;
  typedef typename _Alloc::difference_type difference_type;
  typedef typename traits_base::key_type key_type;
  typedef typename traits_base::key_pointer key_pointer;
  typedef typename traits_base::key_const_pointer key_const_pointer;
  typedef typename traits_base::key_reference key_reference;
  typedef typename traits_base::key_const_reference key_const_reference;
  typedef typename traits_base::mapped_type mapped_type;
  typedef typename traits_base::mapped_pointer mapped_pointer;
  typedef typename traits_base::mapped_const_pointer mapped_const_pointer;
  typedef typename traits_base::mapped_reference mapped_reference;
  typedef typename traits_base::mapped_const_reference mapped_const_reference;
  typedef typename traits_base::value_type value_type;
  typedef typename traits_base::pointer pointer;
  typedef typename traits_base::const_pointer const_pointer;
  typedef typename traits_base::reference reference;
  typedef typename traits_base::const_reference const_reference;
  typedef typename traits_type::access_traits access_traits;
  typedef typename traits_type::const_iterator point_const_iterator;
  typedef typename traits_type::iterator point_iterator;
  typedef point_const_iterator const_iterator;
  typedef point_iterator iterator;
  typedef typename traits_type::reverse_iterator reverse_iterator;
  typedef typename traits_type::const_reverse_iterator const_reverse_iterator;
  typedef typename traits_type::node_const_iterator node_const_iterator;
  typedef typename traits_type::node_iterator node_iterator;
  typedef typename traits_type::node_update node_update;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
protected:
  ;
  ;
  ;
private:
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  static head_allocator s_head_allocator;
  static inode_allocator s_inode_allocator;
  static leaf_allocator s_leaf_allocator;
  head_pointer m_p_head;
  size_type m_size;
};
template <typename Key, typename Mapped, typename Node_And_It_Traits,
          typename _Alloc>
typename pat_trie_map<Key, Mapped, Node_And_It_Traits, _Alloc>::head_allocator
    pat_trie_map<Key, Mapped, Node_And_It_Traits, _Alloc>::s_head_allocator;
template <typename Key, typename Mapped, typename Node_And_It_Traits,
          typename _Alloc>
typename pat_trie_map<Key, Mapped, Node_And_It_Traits, _Alloc>::inode_allocator
    pat_trie_map<Key, Mapped, Node_And_It_Traits, _Alloc>::s_inode_allocator;
template <typename Key, typename Mapped, typename Node_And_It_Traits,
          typename _Alloc>
typename pat_trie_map<Key, Mapped, Node_And_It_Traits, _Alloc>::leaf_allocator
    pat_trie_map<Key, Mapped, Node_And_It_Traits, _Alloc>::s_leaf_allocator;
}
namespace detail
{
template <typename Key, typename Mapped, typename Eq_Fn, typename _Alloc,
          typename Update_Policy>
class lu_set : public types_traits<Key, Mapped, _Alloc, false>
{
private:
  typedef types_traits<Key, Mapped, _Alloc, false> traits_base;
  struct entry : public lu_map_entry_metadata_base<
                     typename Update_Policy::metadata_type>
  {
    typename traits_base::value_type m_value;
    typename _Alloc::template rebind<entry>::other::pointer m_p_next;
  };
  typedef typename _Alloc::template rebind<entry>::other entry_allocator;
  typedef typename entry_allocator::pointer entry_pointer;
  typedef typename entry_allocator::const_pointer const_entry_pointer;
  typedef typename entry_allocator::reference entry_reference;
  typedef typename entry_allocator::const_reference const_entry_reference;
  typedef typename _Alloc::template rebind<entry_pointer>::other
      entry_pointer_allocator;
  typedef typename entry_pointer_allocator::pointer entry_pointer_array;
  typedef typename traits_base::value_type value_type_;
  typedef typename traits_base::pointer pointer_;
  typedef typename traits_base::const_pointer const_pointer_;
  typedef typename traits_base::reference reference_;
  typedef typename traits_base::const_reference const_reference_;
  class point_iterator_;
  class point_const_iterator_
  {
  public:
    typedef trivial_iterator_tag iterator_category;
    typedef trivial_iterator_difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    const_pointer m_p_value;
    friend class point_iterator_;
    friend class lu_set<Key, Mapped, Eq_Fn, _Alloc, Update_Policy>;
  };
  class point_iterator_
  {
  public:
    typedef trivial_iterator_tag iterator_category;
    typedef trivial_iterator_difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    friend class point_const_iterator_;
    friend class lu_set<Key, Mapped, Eq_Fn, _Alloc, Update_Policy>;
  protected:
    pointer m_p_value;
  };
  class const_iterator_ : public point_const_iterator_
  {
  public:
    typedef std::forward_iterator_tag iterator_category;
    typedef typename _Alloc::difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
  protected:
    typedef point_const_iterator_ base_type;
    ;
    const lu_set<Key, Mapped, Eq_Fn, _Alloc, Update_Policy> *m_p_tbl;
    entry_pointer m_pos;
    friend class lu_set<Key, Mapped, Eq_Fn, _Alloc, Update_Policy>;
  };
  class iterator_ : public const_iterator_
  {
  public:
    typedef std::forward_iterator_tag iterator_category;
    typedef typename _Alloc::difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    typedef const_iterator_ base_type;
    ;
    friend class lu_set<Key, Mapped, Eq_Fn, _Alloc, Update_Policy>;
  };
  typedef cond_dealtor<entry, _Alloc> cond_dealtor_t;
public:
  typedef _Alloc allocator_type;
  typedef typename _Alloc::size_type size_type;
  typedef typename _Alloc::difference_type difference_type;
  typedef Eq_Fn eq_fn;
  typedef Update_Policy update_policy;
  typedef typename Update_Policy::metadata_type update_metadata;
  typedef typename traits_base::key_type key_type;
  typedef typename traits_base::key_pointer key_pointer;
  typedef typename traits_base::key_const_pointer key_const_pointer;
  typedef typename traits_base::key_reference key_reference;
  typedef typename traits_base::key_const_reference key_const_reference;
  typedef typename traits_base::mapped_type mapped_type;
  typedef typename traits_base::mapped_pointer mapped_pointer;
  typedef typename traits_base::mapped_const_pointer mapped_const_pointer;
  typedef typename traits_base::mapped_reference mapped_reference;
  typedef typename traits_base::mapped_const_reference mapped_const_reference;
  typedef typename traits_base::value_type value_type;
  typedef typename traits_base::pointer pointer;
  typedef typename traits_base::const_pointer const_pointer;
  typedef typename traits_base::reference reference;
  typedef typename traits_base::const_reference const_reference;
  typedef point_const_iterator_ point_iterator;
  typedef point_const_iterator_ point_const_iterator;
  typedef const_iterator_ iterator;
  typedef const_iterator_ const_iterator;
public:
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
protected:
  ;
private:
  friend class const_iterator_;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  static entry_allocator s_entry_allocator;
  static Eq_Fn s_eq_fn;
  static Update_Policy s_update_policy;
  static type_to_type<update_metadata> s_metadata_type_indicator;
  static null_type s_null_type;
  mutable entry_pointer m_p_l;
};
template <typename Key, typename Mapped, typename Eq_Fn, typename _Alloc,
          typename Update_Policy>
typename lu_set<Key, Mapped, Eq_Fn, _Alloc, Update_Policy>::entry_allocator
    lu_set<Key, Mapped, Eq_Fn, _Alloc, Update_Policy>::s_entry_allocator;
}
namespace detail
{
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
class bin_search_tree_set : public Cmp_Fn,
                            public types_traits<Key, Mapped, _Alloc, false>,
                            public Node_And_It_Traits::node_update
{
  typedef Node_And_It_Traits traits_type;
protected:
  typedef types_traits<Key, Mapped, _Alloc, false> traits_base;
  typedef typename _Alloc::template rebind<typename traits_type::node>::other
      node_allocator;
  typedef typename node_allocator::value_type node;
  typedef typename node_allocator::pointer node_pointer;
  typedef
      typename traits_type::null_node_update_pointer null_node_update_pointer;
private:
  typedef cond_dealtor<node, _Alloc> cond_dealtor_t;
public:
  typedef typename _Alloc::size_type size_type;
  typedef typename _Alloc::difference_type difference_type;
  typedef typename traits_base::key_type key_type;
  typedef typename traits_base::key_pointer key_pointer;
  typedef typename traits_base::key_const_pointer key_const_pointer;
  typedef typename traits_base::key_reference key_reference;
  typedef typename traits_base::key_const_reference key_const_reference;
  typedef typename traits_base::value_type value_type;
  typedef typename traits_base::pointer pointer;
  typedef typename traits_base::const_pointer const_pointer;
  typedef typename traits_base::reference reference;
  typedef typename traits_base::const_reference const_reference;
  typedef typename traits_type::point_const_iterator point_const_iterator;
  typedef point_const_iterator const_iterator;
  typedef typename traits_type::point_iterator point_iterator;
  typedef point_iterator iterator;
  typedef typename traits_type::const_reverse_iterator const_reverse_iterator;
  typedef typename traits_type::reverse_iterator reverse_iterator;
  typedef typename traits_type::node_const_iterator node_const_iterator;
  typedef typename traits_type::node_iterator node_iterator;
  typedef typename traits_type::node_update node_update;
  typedef Cmp_Fn cmp_fn;
  typedef _Alloc allocator_type;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
protected:
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
private:
  ;
  ;
protected:
  node_pointer m_p_head;
  size_type m_size;
  static node_allocator s_node_allocator;
};
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
typename bin_search_tree_set<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                             _Alloc>::node_allocator
    bin_search_tree_set<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                        _Alloc>::s_node_allocator;
}
namespace detail
{
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
class rb_tree_set : public bin_search_tree_set<Key, Mapped, Cmp_Fn,
                                               Node_And_It_Traits, _Alloc>
{
private:
  typedef bin_search_tree_set<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>
      base_type;
  typedef typename base_type::node_pointer node_pointer;
public:
  typedef rb_tree_tag container_category;
  typedef Cmp_Fn cmp_fn;
  typedef _Alloc allocator_type;
  typedef typename _Alloc::size_type size_type;
  typedef typename _Alloc::difference_type difference_type;
  typedef typename base_type::key_type key_type;
  typedef typename base_type::key_pointer key_pointer;
  typedef typename base_type::key_const_pointer key_const_pointer;
  typedef typename base_type::key_reference key_reference;
  typedef typename base_type::key_const_reference key_const_reference;
  typedef typename base_type::mapped_type mapped_type;
  typedef typename base_type::mapped_pointer mapped_pointer;
  typedef typename base_type::mapped_const_pointer mapped_const_pointer;
  typedef typename base_type::mapped_reference mapped_reference;
  typedef typename base_type::mapped_const_reference mapped_const_reference;
  typedef typename base_type::value_type value_type;
  typedef typename base_type::pointer pointer;
  typedef typename base_type::const_pointer const_pointer;
  typedef typename base_type::reference reference;
  typedef typename base_type::const_reference const_reference;
  typedef typename base_type::point_iterator point_iterator;
  typedef typename base_type::const_iterator point_const_iterator;
  typedef typename base_type::iterator iterator;
  typedef typename base_type::const_iterator const_iterator;
  typedef typename base_type::reverse_iterator reverse_iterator;
  typedef typename base_type::const_reverse_iterator const_reverse_iterator;
  typedef typename base_type::node_update node_update;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
private:
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
};
}
namespace detail
{
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
class splay_tree_set : public bin_search_tree_set<Key, Mapped, Cmp_Fn,
                                                  Node_And_It_Traits, _Alloc>
{
private:
  typedef bin_search_tree_set<Key, Mapped, Cmp_Fn, Node_And_It_Traits, _Alloc>
      base_type;
  typedef typename base_type::node_pointer node_pointer;
public:
  typedef splay_tree_tag container_category;
  typedef _Alloc allocator_type;
  typedef typename _Alloc::size_type size_type;
  typedef typename _Alloc::difference_type difference_type;
  typedef Cmp_Fn cmp_fn;
  typedef typename base_type::key_type key_type;
  typedef typename base_type::key_pointer key_pointer;
  typedef typename base_type::key_const_pointer key_const_pointer;
  typedef typename base_type::key_reference key_reference;
  typedef typename base_type::key_const_reference key_const_reference;
  typedef typename base_type::mapped_type mapped_type;
  typedef typename base_type::mapped_pointer mapped_pointer;
  typedef typename base_type::mapped_const_pointer mapped_const_pointer;
  typedef typename base_type::mapped_reference mapped_reference;
  typedef typename base_type::mapped_const_reference mapped_const_reference;
  typedef typename base_type::value_type value_type;
  typedef typename base_type::pointer pointer;
  typedef typename base_type::const_pointer const_pointer;
  typedef typename base_type::reference reference;
  typedef typename base_type::const_reference const_reference;
  typedef typename base_type::point_iterator point_iterator;
  typedef typename base_type::const_iterator point_const_iterator;
  typedef typename base_type::iterator iterator;
  typedef typename base_type::const_iterator const_iterator;
  typedef typename base_type::reverse_iterator reverse_iterator;
  typedef typename base_type::const_reverse_iterator const_reverse_iterator;
  typedef typename base_type::node_update node_update;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
private:
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
};
}
namespace detail
{
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
class ov_tree_set : public Cmp_Fn,
                    public Node_And_It_Traits::node_update,
                    public types_traits<Key, Mapped, _Alloc, false>
{
private:
  typedef types_traits<Key, Mapped, _Alloc, false> traits_base;
  typedef Node_And_It_Traits traits_type;
  typedef typename remove_const<typename traits_base::value_type>::type
      non_const_value_type;
  typedef typename _Alloc::template rebind<non_const_value_type>::other
      value_allocator;
  typedef typename value_allocator::pointer value_vector;
  typedef typename traits_base::pointer mapped_pointer_;
  typedef typename traits_base::const_pointer mapped_const_pointer_;
  typedef typename traits_type::metadata_type metadata_type;
  typedef typename _Alloc::template rebind<metadata_type>::other
      metadata_allocator;
  typedef typename metadata_allocator::pointer metadata_pointer;
  typedef
      typename metadata_allocator::const_reference metadata_const_reference;
  typedef typename metadata_allocator::reference metadata_reference;
  typedef
      typename traits_type::null_node_update_pointer null_node_update_pointer;
public:
  typedef ov_tree_tag container_category;
  typedef _Alloc allocator_type;
  typedef typename _Alloc::size_type size_type;
  typedef typename _Alloc::difference_type difference_type;
  typedef Cmp_Fn cmp_fn;
  typedef typename traits_base::key_type key_type;
  typedef typename traits_base::key_pointer key_pointer;
  typedef typename traits_base::key_const_pointer key_const_pointer;
  typedef typename traits_base::key_reference key_reference;
  typedef typename traits_base::key_const_reference key_const_reference;
  typedef typename traits_base::mapped_type mapped_type;
  typedef typename traits_base::mapped_pointer mapped_pointer;
  typedef typename traits_base::mapped_const_pointer mapped_const_pointer;
  typedef typename traits_base::mapped_reference mapped_reference;
  typedef typename traits_base::mapped_const_reference mapped_const_reference;
  typedef typename traits_base::value_type value_type;
  typedef typename traits_base::pointer pointer;
  typedef typename traits_base::const_pointer const_pointer;
  typedef typename traits_base::reference reference;
  typedef typename traits_base::const_reference const_reference;
  typedef const_pointer point_const_iterator;
  typedef point_const_iterator point_iterator;
  typedef point_iterator iterator;
  typedef point_const_iterator const_iterator;
  template <typename Size_Type> class cond_dtor
  {
  public:
    ;
    ;
    ;
  protected:
    value_vector m_a_vec;
    iterator &m_r_last_it;
    const Size_Type m_max_size;
    bool m_no_action;
  };
  typedef typename traits_type::node_update node_update;
  typedef typename traits_type::node_iterator node_iterator;
  typedef typename traits_type::node_const_iterator node_const_iterator;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
private:
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
private:
  static value_allocator s_value_alloc;
  static metadata_allocator s_metadata_alloc;
  value_vector m_a_values;
  metadata_pointer m_a_metadata;
  iterator m_end_it;
  size_type m_size;
};
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
typename ov_tree_set<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                     _Alloc>::value_allocator
    ov_tree_set<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                _Alloc>::s_value_alloc;
template <typename Key, typename Mapped, typename Cmp_Fn,
          typename Node_And_It_Traits, typename _Alloc>
typename ov_tree_set<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                     _Alloc>::metadata_allocator
    ov_tree_set<Key, Mapped, Cmp_Fn, Node_And_It_Traits,
                _Alloc>::s_metadata_alloc;
}
namespace detail
{
template <typename Key, typename Mapped, typename Hash_Fn, typename Eq_Fn,
          typename _Alloc, bool Store_Hash, typename Comb_Hash_Fn,
          typename Resize_Policy>
class cc_ht_set
    : public hash_eq_fn<Key, Eq_Fn, _Alloc, Store_Hash>,
      public Resize_Policy,
      public ranged_hash_fn<Key, Hash_Fn, _Alloc, Comb_Hash_Fn, Store_Hash>,
      public types_traits<Key, Mapped, _Alloc, Store_Hash>
{
private:
  typedef types_traits<Key, Mapped, _Alloc, Store_Hash> traits_base;
  typedef typename traits_base::comp_hash comp_hash;
  typedef typename traits_base::value_type value_type_;
  typedef typename traits_base::pointer pointer_;
  typedef typename traits_base::const_pointer const_pointer_;
  typedef typename traits_base::reference reference_;
  typedef typename traits_base::const_reference const_reference_;
  struct entry : public traits_base::stored_data_type
  {
    typename _Alloc::template rebind<entry>::other::pointer m_p_next;
  };
  typedef cond_dealtor<entry, _Alloc> cond_dealtor_t;
  typedef typename _Alloc::template rebind<entry>::other entry_allocator;
  typedef typename entry_allocator::pointer entry_pointer;
  typedef typename entry_allocator::const_pointer const_entry_pointer;
  typedef typename entry_allocator::reference entry_reference;
  typedef typename entry_allocator::const_reference const_entry_reference;
  typedef typename _Alloc::template rebind<entry_pointer>::other
      entry_pointer_allocator;
  typedef typename entry_pointer_allocator::pointer entry_pointer_array;
  typedef ranged_hash_fn<Key, Hash_Fn, _Alloc, Comb_Hash_Fn, Store_Hash>
      ranged_hash_fn_base;
  typedef hash_eq_fn<Key, Eq_Fn, _Alloc, Store_Hash> hash_eq_fn_base;
  typedef Resize_Policy resize_base;
  class point_iterator_;
  class point_const_iterator_
  {
  public:
    typedef trivial_iterator_tag iterator_category;
    typedef trivial_iterator_difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    const_pointer m_p_value;
    friend class point_iterator_;
    friend class cc_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                           Comb_Hash_Fn, Resize_Policy>;
  };
  class point_iterator_
  {
  public:
    typedef trivial_iterator_tag iterator_category;
    typedef trivial_iterator_difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    friend class point_const_iterator_;
    friend class cc_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                           Comb_Hash_Fn, Resize_Policy>;
  protected:
    pointer m_p_value;
  };
  class const_iterator_ : public point_const_iterator_
  {
  public:
    typedef std::forward_iterator_tag iterator_category;
    typedef typename _Alloc::difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
  protected:
    typedef point_const_iterator_ base_type;
    ;
    const cc_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                    Comb_Hash_Fn, Resize_Policy> *m_p_tbl;
    std::pair<entry_pointer, typename _Alloc::size_type> m_pos;
    friend class cc_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                           Comb_Hash_Fn, Resize_Policy>;
  };
  class iterator_ : public const_iterator_
  {
  public:
    typedef std::forward_iterator_tag iterator_category;
    typedef typename _Alloc::difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    typedef const_iterator_ base_type;
    ;
    friend class cc_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                           Comb_Hash_Fn, Resize_Policy>;
  };
public:
  typedef _Alloc allocator_type;
  typedef typename _Alloc::size_type size_type;
  typedef typename _Alloc::difference_type difference_type;
  typedef Hash_Fn hash_fn;
  typedef Eq_Fn eq_fn;
  typedef Comb_Hash_Fn comb_hash_fn;
  typedef Resize_Policy resize_policy;
  enum
  {
    store_hash = Store_Hash
  };
  typedef typename traits_base::key_type key_type;
  typedef typename traits_base::key_pointer key_pointer;
  typedef typename traits_base::key_const_pointer key_const_pointer;
  typedef typename traits_base::key_reference key_reference;
  typedef typename traits_base::key_const_reference key_const_reference;
  typedef typename traits_base::mapped_type mapped_type;
  typedef typename traits_base::mapped_pointer mapped_pointer;
  typedef typename traits_base::mapped_const_pointer mapped_const_pointer;
  typedef typename traits_base::mapped_reference mapped_reference;
  typedef typename traits_base::mapped_const_reference mapped_const_reference;
  typedef typename traits_base::value_type value_type;
  typedef typename traits_base::pointer pointer;
  typedef typename traits_base::const_pointer const_pointer;
  typedef typename traits_base::reference reference;
  typedef typename traits_base::const_reference const_reference;
  typedef point_const_iterator_ point_iterator;
  typedef point_const_iterator_ point_const_iterator;
  typedef const_iterator_ iterator;
  typedef const_iterator_ const_iterator;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
private:
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
private:
  friend class const_iterator_;
  static entry_allocator s_entry_allocator;
  static entry_pointer_allocator s_entry_pointer_allocator;
  static iterator s_end_it;
  static const_iterator s_const_end_it;
  static point_iterator s_find_end_it;
  static point_const_iterator s_const_find_end_it;
  size_type m_num_e;
  size_type m_num_used_e;
  entry_pointer_array m_entries;
  enum
  {
    store_hash_ok = !Store_Hash
                    || !is_same<Hash_Fn, __gnu_pbds::null_type>::value
  };
  typedef __gnu_pbds::detail::__static_assert_dumclass<sizeof (
      __gnu_pbds::detail::__static_assert<bool(store_hash_ok)>)>
      sth__static_assert_type;
};
template <typename Key, typename Mapped, typename Hash_Fn, typename Eq_Fn,
          typename _Alloc, bool Store_Hash, typename Comb_Hash_Fn,
          typename Resize_Policy>
typename cc_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                   Comb_Hash_Fn, Resize_Policy>::entry_allocator
    cc_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash, Comb_Hash_Fn,
              Resize_Policy>::s_entry_allocator;
template <typename Key, typename Mapped, typename Hash_Fn, typename Eq_Fn,
          typename _Alloc, bool Store_Hash, typename Comb_Hash_Fn,
          typename Resize_Policy>
typename cc_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                   Comb_Hash_Fn, Resize_Policy>::entry_pointer_allocator
    cc_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash, Comb_Hash_Fn,
              Resize_Policy>::s_entry_pointer_allocator;
template <typename Key, typename Mapped, typename Hash_Fn, typename Eq_Fn,
          typename _Alloc, bool Store_Hash, typename Comb_Probe_Fn,
          typename Probe_Fn, typename Resize_Policy>
class gp_ht_set : public hash_eq_fn<Key, Eq_Fn, _Alloc, Store_Hash>,
                  public Resize_Policy,
                  public ranged_probe_fn<Key, Hash_Fn, _Alloc, Comb_Probe_Fn,
                                         Probe_Fn, Store_Hash>,
                  public types_traits<Key, Mapped, _Alloc, Store_Hash>
{
private:
  typedef types_traits<Key, Mapped, _Alloc, Store_Hash> traits_base;
  typedef typename traits_base::value_type value_type_;
  typedef typename traits_base::pointer pointer_;
  typedef typename traits_base::const_pointer const_pointer_;
  typedef typename traits_base::reference reference_;
  typedef typename traits_base::const_reference const_reference_;
  typedef typename traits_base::comp_hash comp_hash;
  enum entry_status
  {
    empty_entry_status,
    valid_entry_status,
    erased_entry_status
  } __attribute__ ((packed));
  struct entry : public traits_base::stored_data_type
  {
    entry_status m_stat;
  };
  typedef typename _Alloc::template rebind<entry>::other entry_allocator;
  typedef typename entry_allocator::pointer entry_pointer;
  typedef typename entry_allocator::const_pointer const_entry_pointer;
  typedef typename entry_allocator::reference entry_reference;
  typedef typename entry_allocator::const_reference const_entry_reference;
  typedef typename entry_allocator::pointer entry_array;
  typedef ranged_probe_fn<Key, Hash_Fn, _Alloc, Comb_Probe_Fn, Probe_Fn,
                          Store_Hash> ranged_probe_fn_base;
  typedef hash_eq_fn<Key, Eq_Fn, _Alloc, Store_Hash> hash_eq_fn_base;
  typedef Resize_Policy resize_base;
  class point_iterator_;
  class point_const_iterator_
  {
  public:
    typedef trivial_iterator_tag iterator_category;
    typedef trivial_iterator_difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    const_pointer m_p_value;
    friend class point_iterator_;
    friend class gp_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                           Comb_Probe_Fn, Probe_Fn, Resize_Policy>;
  };
  class point_iterator_
  {
  public:
    typedef trivial_iterator_tag iterator_category;
    typedef trivial_iterator_difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    friend class point_const_iterator_;
    friend class gp_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                           Comb_Probe_Fn, Probe_Fn, Resize_Policy>;
  protected:
    pointer m_p_value;
  };
  class const_iterator_ : public point_const_iterator_
  {
  public:
    typedef std::forward_iterator_tag iterator_category;
    typedef typename _Alloc::difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
  protected:
    typedef point_const_iterator_ base_type;
    ;
    const gp_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                    Comb_Probe_Fn, Probe_Fn, Resize_Policy> *m_p_tbl;
    typename _Alloc::size_type m_pos;
    friend class gp_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                           Comb_Probe_Fn, Probe_Fn, Resize_Policy>;
  };
  class iterator_ : public const_iterator_
  {
  public:
    typedef std::forward_iterator_tag iterator_category;
    typedef typename _Alloc::difference_type difference_type;
    typedef value_type_ value_type;
    typedef pointer_ pointer;
    typedef const_pointer_ const_pointer;
    typedef reference_ reference;
    typedef const_reference_ const_reference;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  protected:
    typedef const_iterator_ base_type;
    ;
    friend class gp_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                           Comb_Probe_Fn, Probe_Fn, Resize_Policy>;
  };
public:
  typedef _Alloc allocator_type;
  typedef typename _Alloc::size_type size_type;
  typedef typename _Alloc::difference_type difference_type;
  typedef Hash_Fn hash_fn;
  typedef Eq_Fn eq_fn;
  typedef Probe_Fn probe_fn;
  typedef Comb_Probe_Fn comb_probe_fn;
  typedef Resize_Policy resize_policy;
  enum
  {
    store_hash = Store_Hash
  };
  typedef typename traits_base::key_type key_type;
  typedef typename traits_base::key_pointer key_pointer;
  typedef typename traits_base::key_const_pointer key_const_pointer;
  typedef typename traits_base::key_reference key_reference;
  typedef typename traits_base::key_const_reference key_const_reference;
  typedef typename traits_base::mapped_type mapped_type;
  typedef typename traits_base::mapped_pointer mapped_pointer;
  typedef typename traits_base::mapped_const_pointer mapped_const_pointer;
  typedef typename traits_base::mapped_reference mapped_reference;
  typedef typename traits_base::mapped_const_reference mapped_const_reference;
  typedef typename traits_base::value_type value_type;
  typedef typename traits_base::pointer pointer;
  typedef typename traits_base::const_pointer const_pointer;
  typedef typename traits_base::reference reference;
  typedef typename traits_base::const_reference const_reference;
  typedef point_const_iterator_ point_iterator;
  typedef point_const_iterator_ point_const_iterator;
  typedef const_iterator_ iterator;
  typedef const_iterator_ const_iterator;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
private:
  friend class const_iterator_;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  static entry_allocator s_entry_allocator;
  static iterator s_end_it;
  static const_iterator s_const_end_it;
  size_type m_num_e;
  size_type m_num_used_e;
  entry_pointer m_entries;
  enum
  {
    store_hash_ok = !Store_Hash
                    || !is_same<Hash_Fn, __gnu_pbds::null_type>::value
  };
  typedef __gnu_pbds::detail::__static_assert_dumclass<sizeof (
      __gnu_pbds::detail::__static_assert<bool(store_hash_ok)>)>
      sth__static_assert_type;
};
template <typename Key, typename Mapped, typename Hash_Fn, typename Eq_Fn,
          typename _Alloc, bool Store_Hash, typename Comb_Probe_Fn,
          typename Probe_Fn, typename Resize_Policy>
typename gp_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                   Comb_Probe_Fn, Probe_Fn, Resize_Policy>::entry_allocator
    gp_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash, Comb_Probe_Fn,
              Probe_Fn, Resize_Policy>::s_entry_allocator;
template <typename Key, typename Mapped, typename Hash_Fn, typename Eq_Fn,
          typename _Alloc, bool Store_Hash, typename Comb_Probe_Fn,
          typename Probe_Fn, typename Resize_Policy>
typename gp_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                   Comb_Probe_Fn, Probe_Fn, Resize_Policy>::iterator
    gp_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash, Comb_Probe_Fn,
              Probe_Fn, Resize_Policy>::s_end_it;
template <typename Key, typename Mapped, typename Hash_Fn, typename Eq_Fn,
          typename _Alloc, bool Store_Hash, typename Comb_Probe_Fn,
          typename Probe_Fn, typename Resize_Policy>
typename gp_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash,
                   Comb_Probe_Fn, Probe_Fn, Resize_Policy>::const_iterator
    gp_ht_set<Key, Mapped, Hash_Fn, Eq_Fn, _Alloc, Store_Hash, Comb_Probe_Fn,
              Probe_Fn, Resize_Policy>::s_const_end_it;
}
}
extern "C" {
extern void __assert_fail (const char *__assertion, const char *__file,
                           unsigned int __line,
                           const char *__function) throw ()
    __attribute__ ((__noreturn__));
}
namespace __gnu_pbds
{
namespace detail
{
template <typename Key, typename Mapped, typename Node_And_It_Traits,
          typename _Alloc>
class pat_trie_set : public Node_And_It_Traits::synth_access_traits,
                     public Node_And_It_Traits::node_update,
                     public types_traits<Key, Mapped, _Alloc, false>,
                     public pat_trie_base
{
private:
  typedef pat_trie_base base_type;
  typedef types_traits<Key, Mapped, _Alloc, false> traits_base;
  typedef Node_And_It_Traits traits_type;
  typedef typename traits_type::synth_access_traits synth_access_traits;
  typedef typename synth_access_traits::const_iterator a_const_iterator;
  typedef typename traits_type::node node;
  typedef typename _Alloc::template rebind<node> __rebind_n;
  typedef typename __rebind_n::other::const_pointer node_const_pointer;
  typedef typename __rebind_n::other::pointer node_pointer;
  typedef typename traits_type::head head;
  typedef typename _Alloc::template rebind<head> __rebind_h;
  typedef typename __rebind_h::other head_allocator;
  typedef typename head_allocator::pointer head_pointer;
  typedef typename traits_type::leaf leaf;
  typedef typename _Alloc::template rebind<leaf> __rebind_l;
  typedef typename __rebind_l::other leaf_allocator;
  typedef typename leaf_allocator::pointer leaf_pointer;
  typedef typename leaf_allocator::const_pointer leaf_const_pointer;
  typedef typename traits_type::inode inode;
  typedef typename inode::iterator inode_iterator;
  typedef typename _Alloc::template rebind<inode> __rebind_in;
  typedef typename __rebind_in::other __rebind_ina;
  typedef typename __rebind_in::other inode_allocator;
  typedef typename __rebind_ina::pointer inode_pointer;
  typedef typename __rebind_ina::const_pointer inode_const_pointer;
  class cond_dealtor
  {
  protected:
    leaf_pointer m_p_nd;
    bool m_no_action_dtor;
    bool m_call_destructor;
  public:
    ;
    ;
    ;
    ;
  };
  class branch_bag
  {
  private:
    typedef inode_pointer __inp;
    typedef typename _Alloc::template rebind<__inp>::other __rebind_inp;
    typedef std::list<__inp, __rebind_inp> bag_type;
    bag_type m_bag;
  public:
    ;
    ;
    ;
    ;
  };
  typedef
      typename traits_type::null_node_update_pointer null_node_update_pointer;
public:
  typedef pat_trie_tag container_category;
  typedef _Alloc allocator_type;
  typedef typename _Alloc::size_type size_type;
  typedef typename _Alloc::difference_type difference_type;
  typedef typename traits_base::key_type key_type;
  typedef typename traits_base::key_pointer key_pointer;
  typedef typename traits_base::key_const_pointer key_const_pointer;
  typedef typename traits_base::key_reference key_reference;
  typedef typename traits_base::key_const_reference key_const_reference;
  typedef typename traits_base::mapped_type mapped_type;
  typedef typename traits_base::mapped_pointer mapped_pointer;
  typedef typename traits_base::mapped_const_pointer mapped_const_pointer;
  typedef typename traits_base::mapped_reference mapped_reference;
  typedef typename traits_base::mapped_const_reference mapped_const_reference;
  typedef typename traits_base::value_type value_type;
  typedef typename traits_base::pointer pointer;
  typedef typename traits_base::const_pointer const_pointer;
  typedef typename traits_base::reference reference;
  typedef typename traits_base::const_reference const_reference;
  typedef typename traits_type::access_traits access_traits;
  typedef typename traits_type::const_iterator point_const_iterator;
  typedef typename traits_type::iterator point_iterator;
  typedef point_const_iterator const_iterator;
  typedef point_iterator iterator;
  typedef typename traits_type::reverse_iterator reverse_iterator;
  typedef typename traits_type::const_reverse_iterator const_reverse_iterator;
  typedef typename traits_type::node_const_iterator node_const_iterator;
  typedef typename traits_type::node_iterator node_iterator;
  typedef typename traits_type::node_update node_update;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
protected:
  ;
  ;
  ;
private:
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  static head_allocator s_head_allocator;
  static inode_allocator s_inode_allocator;
  static leaf_allocator s_leaf_allocator;
  head_pointer m_p_head;
  size_type m_size;
};
template <typename Key, typename Mapped, typename Node_And_It_Traits,
          typename _Alloc>
typename pat_trie_set<Key, Mapped, Node_And_It_Traits, _Alloc>::head_allocator
    pat_trie_set<Key, Mapped, Node_And_It_Traits, _Alloc>::s_head_allocator;
template <typename Key, typename Mapped, typename Node_And_It_Traits,
          typename _Alloc>
typename pat_trie_set<Key, Mapped, Node_And_It_Traits, _Alloc>::inode_allocator
    pat_trie_set<Key, Mapped, Node_And_It_Traits, _Alloc>::s_inode_allocator;
template <typename Key, typename Mapped, typename Node_And_It_Traits,
          typename _Alloc>
typename pat_trie_set<Key, Mapped, Node_And_It_Traits, _Alloc>::leaf_allocator
    pat_trie_set<Key, Mapped, Node_And_It_Traits, _Alloc>::s_leaf_allocator;
}
namespace detail
{
template <typename Key, typename Mapped, typename _Alloc, typename Policy_Tl>
struct container_base_dispatch<Key, Mapped, _Alloc, list_update_tag, Policy_Tl>
{
private:
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 0> at0;
  typedef typename at0::type at0t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 1> at1;
  typedef typename at1::type at1t;
public:
  typedef lu_map<Key, Mapped, at0t, _Alloc, at1t> type;
};
template <typename Key, typename _Alloc, typename Policy_Tl>
struct container_base_dispatch<Key, null_type, _Alloc, list_update_tag,
                               Policy_Tl>
{
private:
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 0> at0;
  typedef typename at0::type at0t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 1> at1;
  typedef typename at1::type at1t;
public:
  typedef lu_set<Key, null_type, at0t, _Alloc, at1t> type;
};
template <typename Key, typename Mapped, typename _Alloc, typename Policy_Tl>
struct container_base_dispatch<Key, Mapped, _Alloc, pat_trie_tag, Policy_Tl>
{
private:
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 1> at1;
  typedef typename at1::type at1t;
public:
  typedef pat_trie_map<Key, Mapped, at1t, _Alloc> type;
};
template <typename Key, typename _Alloc, typename Policy_Tl>
struct container_base_dispatch<Key, null_type, _Alloc, pat_trie_tag, Policy_Tl>
{
private:
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 1> at1;
  typedef typename at1::type at1t;
public:
  typedef pat_trie_set<Key, null_type, at1t, _Alloc> type;
};
template <typename Key, typename Mapped, typename _Alloc, typename Policy_Tl>
struct container_base_dispatch<Key, Mapped, _Alloc, rb_tree_tag, Policy_Tl>
{
private:
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 0> at0;
  typedef typename at0::type at0t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 1> at1;
  typedef typename at1::type at1t;
public:
  typedef rb_tree_map<Key, Mapped, at0t, at1t, _Alloc> type;
};
template <typename Key, typename _Alloc, typename Policy_Tl>
struct container_base_dispatch<Key, null_type, _Alloc, rb_tree_tag, Policy_Tl>
{
private:
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 0> at0;
  typedef typename at0::type at0t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 1> at1;
  typedef typename at1::type at1t;
public:
  typedef rb_tree_set<Key, null_type, at0t, at1t, _Alloc> type;
};
template <typename Key, typename Mapped, typename _Alloc, typename Policy_Tl>
struct container_base_dispatch<Key, Mapped, _Alloc, splay_tree_tag, Policy_Tl>
{
private:
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 0> at0;
  typedef typename at0::type at0t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 1> at1;
  typedef typename at1::type at1t;
public:
  typedef splay_tree_map<Key, Mapped, at0t, at1t, _Alloc> type;
};
template <typename Key, typename _Alloc, typename Policy_Tl>
struct container_base_dispatch<Key, null_type, _Alloc, splay_tree_tag,
                               Policy_Tl>
{
private:
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 0> at0;
  typedef typename at0::type at0t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 1> at1;
  typedef typename at1::type at1t;
public:
  typedef splay_tree_set<Key, null_type, at0t, at1t, _Alloc> type;
};
template <typename Key, typename Mapped, typename _Alloc, typename Policy_Tl>
struct container_base_dispatch<Key, Mapped, _Alloc, ov_tree_tag, Policy_Tl>
{
private:
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 0> at0;
  typedef typename at0::type at0t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 1> at1;
  typedef typename at1::type at1t;
public:
  typedef ov_tree_map<Key, Mapped, at0t, at1t, _Alloc> type;
};
template <typename Key, typename _Alloc, typename Policy_Tl>
struct container_base_dispatch<Key, null_type, _Alloc, ov_tree_tag, Policy_Tl>
{
private:
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 0> at0;
  typedef typename at0::type at0t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 1> at1;
  typedef typename at1::type at1t;
public:
  typedef ov_tree_set<Key, null_type, at0t, at1t, _Alloc> type;
};
template <typename Key, typename Mapped, typename _Alloc, typename Policy_Tl>
struct container_base_dispatch<Key, Mapped, _Alloc, cc_hash_tag, Policy_Tl>
{
private:
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 0> at0;
  typedef typename at0::type at0t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 1> at1;
  typedef typename at1::type at1t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 2> at2;
  typedef typename at2::type at2t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 3> at3;
  typedef typename at3::type at3t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 4> at4;
  typedef typename at4::type at4t;
public:
  typedef cc_ht_map<Key, Mapped, at0t, at1t, _Alloc, at3t::value, at4t, at2t>
      type;
};
template <typename Key, typename _Alloc, typename Policy_Tl>
struct container_base_dispatch<Key, null_type, _Alloc, cc_hash_tag, Policy_Tl>
{
private:
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 0> at0;
  typedef typename at0::type at0t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 1> at1;
  typedef typename at1::type at1t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 2> at2;
  typedef typename at2::type at2t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 3> at3;
  typedef typename at3::type at3t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 4> at4;
  typedef typename at4::type at4t;
public:
  typedef cc_ht_set<Key, null_type, at0t, at1t, _Alloc, at3t::value, at4t,
                    at2t> type;
};
template <typename Key, typename Mapped, typename _Alloc, typename Policy_Tl>
struct container_base_dispatch<Key, Mapped, _Alloc, gp_hash_tag, Policy_Tl>
{
private:
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 0> at0;
  typedef typename at0::type at0t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 1> at1;
  typedef typename at1::type at1t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 2> at2;
  typedef typename at2::type at2t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 3> at3;
  typedef typename at3::type at3t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 4> at4;
  typedef typename at4::type at4t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 5> at5;
  typedef typename at5::type at5t;
public:
  typedef gp_ht_map<Key, Mapped, at0t, at1t, _Alloc, at3t::value, at4t, at5t,
                    at2t> type;
};
template <typename Key, typename _Alloc, typename Policy_Tl>
struct container_base_dispatch<Key, null_type, _Alloc, gp_hash_tag, Policy_Tl>
{
private:
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 0> at0;
  typedef typename at0::type at0t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 1> at1;
  typedef typename at1::type at1t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 2> at2;
  typedef typename at2::type at2t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 3> at3;
  typedef typename at3::type at3t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 4> at4;
  typedef typename at4::type at4t;
  typedef __gnu_cxx::typelist::at_index<Policy_Tl, 5> at5;
  typedef typename at5::type at5t;
public:
  typedef gp_ht_set<Key, null_type, at0t, at1t, _Alloc, at3t::value, at4t,
                    at5t, at2t> type;
};
}
namespace detail
{
template <typename Node_Pointer, typename Value_Type, typename Pointer,
          typename Const_Pointer, typename Reference, typename Const_Reference,
          bool Is_Forward_Iterator, typename _Alloc>
class bin_search_tree_const_it_
{
public:
  typedef std::bidirectional_iterator_tag iterator_category;
  typedef typename _Alloc::difference_type difference_type;
  typedef Value_Type value_type;
  typedef Pointer pointer;
  typedef Const_Pointer const_pointer;
  typedef Reference reference;
  typedef Const_Reference const_reference;
  inline bin_search_tree_const_it_ (const Node_Pointer p_nd = 0)
      : m_p_nd (const_cast<Node_Pointer> (p_nd))
  {
  }
  inline bin_search_tree_const_it_ (
      const bin_search_tree_const_it_<Node_Pointer, Value_Type, Pointer,
                                      Const_Pointer, Reference,
                                      Const_Reference, !Is_Forward_Iterator,
                                      _Alloc> &other)
      : m_p_nd (other.m_p_nd)
  {
  }
  inline bin_search_tree_const_it_<Node_Pointer, Value_Type, Pointer,
                                   Const_Pointer, Reference, Const_Reference,
                                   Is_Forward_Iterator, _Alloc> &
  operator=(
      const bin_search_tree_const_it_<Node_Pointer, Value_Type, Pointer,
                                      Const_Pointer, Reference,
                                      Const_Reference, Is_Forward_Iterator,
                                      _Alloc> &other)
  {
    m_p_nd = other.m_p_nd;
    return *this;
  }
  inline bin_search_tree_const_it_<Node_Pointer, Value_Type, Pointer,
                                   Const_Pointer, Reference, Const_Reference,
                                   Is_Forward_Iterator, _Alloc> &
  operator=(
      const bin_search_tree_const_it_<Node_Pointer, Value_Type, Pointer,
                                      Const_Pointer, Reference,
                                      Const_Reference, !Is_Forward_Iterator,
                                      _Alloc> &other)
  {
    m_p_nd = other.m_p_nd;
    return *this;
  }
  inline const_reference operator*() const
  {
    ;
    return m_p_nd->m_value;
  }
  inline bool operator==(
      const bin_search_tree_const_it_<Node_Pointer, Value_Type, Pointer,
                                      Const_Pointer, Reference,
                                      Const_Reference, Is_Forward_Iterator,
                                      _Alloc> &other) const
  {
    return m_p_nd == other.m_p_nd;
  }
  inline bool operator==(
      const bin_search_tree_const_it_<Node_Pointer, Value_Type, Pointer,
                                      Const_Pointer, Reference,
                                      Const_Reference, !Is_Forward_Iterator,
                                      _Alloc> &other) const
  {
    return m_p_nd == other.m_p_nd;
  }
  inline bool operator!=(
      const bin_search_tree_const_it_<Node_Pointer, Value_Type, Pointer,
                                      Const_Pointer, Reference,
                                      Const_Reference, Is_Forward_Iterator,
                                      _Alloc> &other) const
  {
    return m_p_nd != other.m_p_nd;
  }
  inline bool operator!=(
      const bin_search_tree_const_it_<Node_Pointer, Value_Type, Pointer,
                                      Const_Pointer, Reference,
                                      Const_Reference, !Is_Forward_Iterator,
                                      _Alloc> &other) const
  {
    return m_p_nd != other.m_p_nd;
  }
  inline bin_search_tree_const_it_<Node_Pointer, Value_Type, Pointer,
                                   Const_Pointer, Reference, Const_Reference,
                                   Is_Forward_Iterator, _Alloc> &
  operator++()
  {
    ;
    inc (integral_constant<int, Is_Forward_Iterator> ());
    return *this;
  }
  inline bin_search_tree_const_it_<Node_Pointer, Value_Type, Pointer,
                                   Const_Pointer, Reference, Const_Reference,
                                   Is_Forward_Iterator, _Alloc> &
  operator--()
  {
    dec (integral_constant<int, Is_Forward_Iterator> ());
    return *this;
  }
protected:
  inline void inc (false_type) { dec (true_type ()); }
  void inc (true_type)
  {
    if (m_p_nd->special () && m_p_nd->m_p_parent->m_p_parent == m_p_nd)
      {
        m_p_nd = m_p_nd->m_p_left;
        return;
      }
    if (m_p_nd->m_p_right != 0)
      {
        m_p_nd = m_p_nd->m_p_right;
        while (m_p_nd->m_p_left != 0)
          m_p_nd = m_p_nd->m_p_left;
        return;
      }
    Node_Pointer p_y = m_p_nd->m_p_parent;
    while (m_p_nd == p_y->m_p_right)
      {
        m_p_nd = p_y;
        p_y = p_y->m_p_parent;
      }
    if (m_p_nd->m_p_right != p_y)
      m_p_nd = p_y;
  }
  inline void dec (false_type) { inc (true_type ()); }
  void dec (true_type)
  {
    if (m_p_nd->special () && m_p_nd->m_p_parent->m_p_parent == m_p_nd)
      {
        m_p_nd = m_p_nd->m_p_right;
        return;
      }
    if (m_p_nd->m_p_left != 0)
      {
        Node_Pointer p_y = m_p_nd->m_p_left;
        while (p_y->m_p_right != 0)
          p_y = p_y->m_p_right;
        m_p_nd = p_y;
        return;
      }
    Node_Pointer p_y = m_p_nd->m_p_parent;
    while (m_p_nd == p_y->m_p_left)
      {
        m_p_nd = p_y;
        p_y = p_y->m_p_parent;
      }
    if (m_p_nd->m_p_left != p_y)
      m_p_nd = p_y;
  }
public:
  Node_Pointer m_p_nd;
};
template <typename Node_Pointer, typename Value_Type, typename Pointer,
          typename Const_Pointer, typename Reference, typename Const_Reference,
          bool Is_Forward_Iterator, typename _Alloc>
class bin_search_tree_it_
    : public bin_search_tree_const_it_<Node_Pointer, Value_Type, Pointer,
                                       Const_Pointer, Reference,
                                       Const_Reference, Is_Forward_Iterator,
                                       _Alloc>
{
public:
  inline bin_search_tree_it_ (const Node_Pointer p_nd = 0)
      : bin_search_tree_const_it_<Node_Pointer, Value_Type, Pointer,
                                  Const_Pointer, Reference, Const_Reference,
                                  Is_Forward_Iterator, _Alloc> (
            (Node_Pointer)p_nd)
  {
  }
  inline bin_search_tree_it_ (
      const bin_search_tree_it_<Node_Pointer, Value_Type, Pointer,
                                Const_Pointer, Reference, Const_Reference,
                                !Is_Forward_Iterator, _Alloc> &other)
      : bin_search_tree_const_it_<Node_Pointer, Value_Type, Pointer,
                                  Const_Pointer, Reference, Const_Reference,
                                  Is_Forward_Iterator, _Alloc> (other.m_p_nd)
  {
  }
  inline bin_search_tree_it_<Node_Pointer, Value_Type, Pointer, Const_Pointer,
                             Reference, Const_Reference, Is_Forward_Iterator,
                             _Alloc> &
  operator=(
      const bin_search_tree_it_<Node_Pointer, Value_Type, Pointer,
                                Const_Pointer, Reference, Const_Reference,
                                Is_Forward_Iterator, _Alloc> &other)
  {
    base_it_type::m_p_nd = other.m_p_nd;
    return *this;
  }
  inline
      typename bin_search_tree_const_it_<Node_Pointer, Value_Type, Pointer,
                                         Const_Pointer, Reference,
                                         Const_Reference, Is_Forward_Iterator,
                                         _Alloc>::reference
      operator*() const
  {
    ;
    return base_it_type::m_p_nd->m_value;
  }
  inline bin_search_tree_it_<Node_Pointer, Value_Type, Pointer, Const_Pointer,
                             Reference, Const_Reference, Is_Forward_Iterator,
                             _Alloc> &
  operator++()
  {
    bin_search_tree_const_it_<Node_Pointer, Value_Type, Pointer, Const_Pointer,
                              Reference, Const_Reference, Is_Forward_Iterator,
                              _Alloc>::
    operator++();
    return *this;
  }
  inline bin_search_tree_it_<Node_Pointer, Value_Type, Pointer, Const_Pointer,
                             Reference, Const_Reference, Is_Forward_Iterator,
                             _Alloc>
  operator++(int)
  {
    bin_search_tree_it_<Node_Pointer, Value_Type, Pointer, Const_Pointer,
                        Reference, Const_Reference, Is_Forward_Iterator,
                        _Alloc> ret_it (base_it_type::m_p_nd);
    operator++();
    return ret_it;
  }
  inline bin_search_tree_it_<Node_Pointer, Value_Type, Pointer, Const_Pointer,
                             Reference, Const_Reference, Is_Forward_Iterator,
                             _Alloc> &
  operator--()
  {
    bin_search_tree_const_it_<Node_Pointer, Value_Type, Pointer, Const_Pointer,
                              Reference, Const_Reference, Is_Forward_Iterator,
                              _Alloc>::
    operator--();
    return *this;
  }
protected:
  typedef bin_search_tree_const_it_<Node_Pointer, Value_Type, Pointer,
                                    Const_Pointer, Reference, Const_Reference,
                                    Is_Forward_Iterator, _Alloc> base_it_type;
};
}
namespace detail
{
template <typename Node, class Const_Iterator, class Iterator, typename _Alloc>
class bin_search_tree_const_node_it_
{
private:
  typedef typename _Alloc::template rebind<Node>::other::pointer node_pointer;
public:
  typedef trivial_iterator_tag iterator_category;
  typedef trivial_iterator_difference_type difference_type;
  typedef Const_Iterator value_type;
  typedef Const_Iterator reference;
  typedef Const_Iterator const_reference;
  typedef typename Node::metadata_type metadata_type;
  typedef
      typename _Alloc::template rebind<metadata_type>::other::const_reference
          metadata_const_reference;
  bin_search_tree_const_node_it_ (const node_pointer p_nd = 0)
      : m_p_nd (const_cast<node_pointer> (p_nd))
  {
  }
  const_reference operator*() const { return Const_Iterator (m_p_nd); }
  metadata_const_reference
  get_metadata () const
  {
    return m_p_nd->get_metadata ();
  }
  bin_search_tree_const_node_it_<Node, Const_Iterator, Iterator, _Alloc>
  get_l_child () const
  {
    return bin_search_tree_const_node_it_<Node, Const_Iterator, Iterator,
                                          _Alloc> (m_p_nd->m_p_left);
  }
  bin_search_tree_const_node_it_<Node, Const_Iterator, Iterator, _Alloc>
  get_r_child () const
  {
    return bin_search_tree_const_node_it_<Node, Const_Iterator, Iterator,
                                          _Alloc> (m_p_nd->m_p_right);
  }
  bool operator==(
      const bin_search_tree_const_node_it_<Node, Const_Iterator, Iterator,
                                           _Alloc> &other) const
  {
    return m_p_nd == other.m_p_nd;
  }
  bool operator!=(
      const bin_search_tree_const_node_it_<Node, Const_Iterator, Iterator,
                                           _Alloc> &other) const
  {
    return m_p_nd != other.m_p_nd;
  }
  node_pointer m_p_nd;
};
template <typename Node, class Const_Iterator, class Iterator, typename _Alloc>
class bin_search_tree_node_it_
    : public bin_search_tree_const_node_it_<Node, Const_Iterator, Iterator,
                                            _Alloc>
{
private:
  typedef typename _Alloc::template rebind<Node>::other::pointer node_pointer;
public:
  typedef Iterator value_type;
  typedef Iterator reference;
  typedef Iterator const_reference;
  inline bin_search_tree_node_it_ (const node_pointer p_nd = 0)
      : bin_search_tree_const_node_it_<Node, Const_Iterator, Iterator,
                                       _Alloc> (
            const_cast<node_pointer> (p_nd))
  {
  }
  Iterator operator*() const
  {
    return Iterator (bin_search_tree_const_node_it_<Node, Const_Iterator,
                                                    Iterator, _Alloc>::m_p_nd);
  }
  bin_search_tree_node_it_<Node, Const_Iterator, Iterator, _Alloc>
  get_l_child () const
  {
    return bin_search_tree_node_it_<Node, Const_Iterator, Iterator, _Alloc> (
        bin_search_tree_const_node_it_<Node, Const_Iterator, Iterator,
                                       _Alloc>::m_p_nd->m_p_left);
  }
  bin_search_tree_node_it_<Node, Const_Iterator, Iterator, _Alloc>
  get_r_child () const
  {
    return bin_search_tree_node_it_<Node, Const_Iterator, Iterator, _Alloc> (
        bin_search_tree_const_node_it_<Node, Const_Iterator, Iterator,
                                       _Alloc>::m_p_nd->m_p_right);
  }
};
}
namespace detail
{
template <typename Key, typename Mapped, class Cmp_Fn,
          template <typename Node_CItr, class Node_Itr, class _Cmp_Fn,
                    typename _Alloc> class Node_Update,
          class Node, typename _Alloc>
struct bin_search_tree_traits
{
private:
  typedef types_traits<Key, Mapped, _Alloc, false> type_traits;
public:
  typedef Node node;
  typedef bin_search_tree_const_it_<
      typename _Alloc::template rebind<node>::other::pointer,
      typename type_traits::value_type, typename type_traits::pointer,
      typename type_traits::const_pointer, typename type_traits::reference,
      typename type_traits::const_reference, true,
      _Alloc> point_const_iterator;
  typedef bin_search_tree_it_<
      typename _Alloc::template rebind<node>::other::pointer,
      typename type_traits::value_type, typename type_traits::pointer,
      typename type_traits::const_pointer, typename type_traits::reference,
      typename type_traits::const_reference, true, _Alloc> point_iterator;
  typedef bin_search_tree_const_it_<
      typename _Alloc::template rebind<node>::other::pointer,
      typename type_traits::value_type, typename type_traits::pointer,
      typename type_traits::const_pointer, typename type_traits::reference,
      typename type_traits::const_reference, false,
      _Alloc> const_reverse_iterator;
  typedef bin_search_tree_it_<
      typename _Alloc::template rebind<node>::other::pointer,
      typename type_traits::value_type, typename type_traits::pointer,
      typename type_traits::const_pointer, typename type_traits::reference,
      typename type_traits::const_reference, false, _Alloc> reverse_iterator;
  typedef bin_search_tree_const_node_it_<Node, point_const_iterator,
                                         point_iterator,
                                         _Alloc> node_const_iterator;
  typedef bin_search_tree_node_it_<Node, point_const_iterator, point_iterator,
                                   _Alloc> node_iterator;
  typedef Node_Update<node_const_iterator, node_iterator, Cmp_Fn, _Alloc>
      node_update;
  typedef __gnu_pbds::null_node_update<node_const_iterator, node_iterator,
                                       Cmp_Fn,
                                       _Alloc> *null_node_update_pointer;
};
template <typename Key, class Cmp_Fn,
          template <typename Node_CItr, class Node_Itr, class _Cmp_Fn,
                    typename _Alloc> class Node_Update,
          class Node, typename _Alloc>
struct bin_search_tree_traits<Key, null_type, Cmp_Fn, Node_Update, Node,
                              _Alloc>
{
private:
  typedef types_traits<Key, null_type, _Alloc, false> type_traits;
public:
  typedef Node node;
  typedef bin_search_tree_const_it_<
      typename _Alloc::template rebind<node>::other::pointer,
      typename type_traits::value_type, typename type_traits::pointer,
      typename type_traits::const_pointer, typename type_traits::reference,
      typename type_traits::const_reference, true,
      _Alloc> point_const_iterator;
  typedef point_const_iterator point_iterator;
  typedef bin_search_tree_const_it_<
      typename _Alloc::template rebind<node>::other::pointer,
      typename type_traits::value_type, typename type_traits::pointer,
      typename type_traits::const_pointer, typename type_traits::reference,
      typename type_traits::const_reference, false,
      _Alloc> const_reverse_iterator;
  typedef const_reverse_iterator reverse_iterator;
  typedef bin_search_tree_const_node_it_<Node, point_const_iterator,
                                         point_iterator,
                                         _Alloc> node_const_iterator;
  typedef node_const_iterator node_iterator;
  typedef Node_Update<node_const_iterator, node_iterator, Cmp_Fn, _Alloc>
      node_update;
  typedef __gnu_pbds::null_node_update<node_const_iterator, node_iterator,
                                       Cmp_Fn,
                                       _Alloc> *null_node_update_pointer;
};
}
namespace detail
{
template <typename Node_Update, bool _BTp> struct tree_metadata_helper;
template <typename Node_Update> struct tree_metadata_helper<Node_Update, false>
{
  typedef typename Node_Update::metadata_type type;
};
template <typename Node_Update> struct tree_metadata_helper<Node_Update, true>
{
  typedef null_type type;
};
template <typename Key, typename Data, typename Cmp_Fn,
          template <typename Node_CItr, typename Const_Iterator,
                    typename Cmp_Fn_, typename _Alloc_> class Node_Update,
          typename _Alloc>
struct tree_node_metadata_dispatch
{
private:
  typedef dumnode_const_iterator<Key, Data, _Alloc> __it_type;
  typedef Node_Update<__it_type, __it_type, Cmp_Fn, _Alloc> __node_u;
  typedef null_node_update<__it_type, __it_type, Cmp_Fn, _Alloc> __nnode_u;
  enum
  {
    null_update = is_same<__node_u, __nnode_u>::value
  };
public:
  typedef typename tree_metadata_helper<__node_u, null_update>::type type;
};
}
namespace detail
{
template <typename Key, typename Data, typename Cmp_Fn,
          template <typename Node_CItr, typename Node_Itr, typename Cmp_Fn_,
                    typename _Alloc> class Node_Update,
          typename Tag, typename _Alloc>
struct tree_traits;
template <typename Key, typename Data, typename _ATraits,
          template <typename Node_CItr, typename Node_Itr, typename _ATraits_,
                    typename _Alloc> class Node_Update,
          typename Tag, typename _Alloc>
struct trie_traits;
}
namespace detail
{
template <typename Value_Type, class Metadata, typename _Alloc>
struct rb_tree_node_
{
public:
  typedef Value_Type value_type;
  typedef Metadata metadata_type;
  typedef
      typename _Alloc::template rebind<rb_tree_node_<Value_Type, Metadata,
                                                     _Alloc> >::other::pointer
          node_pointer;
  typedef typename _Alloc::template rebind<metadata_type>::other::reference
      metadata_reference;
  typedef
      typename _Alloc::template rebind<metadata_type>::other::const_reference
          metadata_const_reference;
  bool
  special () const
  {
    return m_red;
  }
  metadata_reference
  get_metadata ()
  {
    return m_metadata;
  }
  node_pointer m_p_left;
  node_pointer m_p_right;
  node_pointer m_p_parent;
  value_type m_value;
  bool m_red;
  metadata_type m_metadata;
};
template <typename Value_Type, typename _Alloc>
struct rb_tree_node_<Value_Type, null_type, _Alloc>
{
public:
  typedef Value_Type value_type;
  typedef null_type metadata_type;
  typedef
      typename _Alloc::template rebind<rb_tree_node_<Value_Type, null_type,
                                                     _Alloc> >::other::pointer
          node_pointer;
  bool
  special () const
  {
    return m_red;
  }
  node_pointer m_p_left;
  node_pointer m_p_right;
  node_pointer m_p_parent;
  value_type m_value;
  bool m_red;
};
}
namespace detail
{
template <typename Key, typename Mapped, typename Cmp_Fn,
          template <typename Node_CItr, typename Node_Itr, typename Cmp_Fn_,
                    typename _Alloc_> class Node_Update,
          typename _Alloc>
struct tree_traits<Key, Mapped, Cmp_Fn, Node_Update, rb_tree_tag, _Alloc>
    : public bin_search_tree_traits<Key, Mapped, Cmp_Fn, Node_Update,
                                    rb_tree_node_<
                                        typename types_traits<Key, Mapped,
                                                              _Alloc, false>::
                                            value_type,
                                        typename tree_node_metadata_dispatch<Key,
                                                                             Mapped,
                                                                             Cmp_Fn,
                                                                             Node_Update,
                                                                             _Alloc>::
                                            type,
                                        _Alloc>,
                                    _Alloc>
{
};
template <typename Key, typename Cmp_Fn,
          template <typename Node_CItr, typename Node_Itr, typename Cmp_Fn_,
                    typename _Alloc_> class Node_Update,
          typename _Alloc>
struct tree_traits<Key, null_type, Cmp_Fn, Node_Update, rb_tree_tag, _Alloc>
    : public bin_search_tree_traits<Key, null_type, Cmp_Fn, Node_Update,
                                    rb_tree_node_<
                                        typename types_traits<Key, null_type,
                                                              _Alloc, false>::
                                            value_type,
                                        typename tree_node_metadata_dispatch<Key,
                                                                             null_type,
                                                                             Cmp_Fn,
                                                                             Node_Update,
                                                                             _Alloc>::
                                            type,
                                        _Alloc>,
                                    _Alloc>
{
};
}
namespace detail
{
template <typename Value_Type, class Metadata, typename _Alloc>
struct splay_tree_node_
{
public:
  typedef Value_Type value_type;
  typedef Metadata metadata_type;
  typedef typename _Alloc::
      template rebind<splay_tree_node_<Value_Type, Metadata,
                                       _Alloc> >::other::pointer node_pointer;
  typedef typename _Alloc::template rebind<metadata_type>::other::reference
      metadata_reference;
  typedef
      typename _Alloc::template rebind<metadata_type>::other::const_reference
          metadata_const_reference;
  inline bool
  special () const
  {
    return m_special;
  }
  inline metadata_reference
  get_metadata ()
  {
    return m_metadata;
  }
  value_type m_value;
  bool m_special;
  node_pointer m_p_left;
  node_pointer m_p_right;
  node_pointer m_p_parent;
  metadata_type m_metadata;
};
template <typename Value_Type, typename _Alloc>
struct splay_tree_node_<Value_Type, null_type, _Alloc>
{
public:
  typedef Value_Type value_type;
  typedef null_type metadata_type;
  typedef typename _Alloc::
      template rebind<splay_tree_node_<Value_Type, null_type,
                                       _Alloc> >::other::pointer node_pointer;
  inline bool
  special () const
  {
    return m_special;
  }
  node_pointer m_p_left;
  node_pointer m_p_right;
  node_pointer m_p_parent;
  value_type m_value;
  bool m_special;
};
}
namespace detail
{
template <typename Key, typename Mapped, typename Cmp_Fn,
          template <typename Node_CItr, typename Node_Itr, typename Cmp_Fn_,
                    typename _Alloc_> class Node_Update,
          typename _Alloc>
struct tree_traits<Key, Mapped, Cmp_Fn, Node_Update, splay_tree_tag, _Alloc>
    : public bin_search_tree_traits<Key, Mapped, Cmp_Fn, Node_Update,
                                    splay_tree_node_<
                                        typename types_traits<Key, Mapped,
                                                              _Alloc, false>::
                                            value_type,
                                        typename tree_node_metadata_dispatch<Key,
                                                                             Mapped,
                                                                             Cmp_Fn,
                                                                             Node_Update,
                                                                             _Alloc>::
                                            type,
                                        _Alloc>,
                                    _Alloc>
{
};
template <typename Key, class Cmp_Fn,
          template <typename Node_CItr, class Node_Itr, class Cmp_Fn_,
                    typename _Alloc_> class Node_Update,
          typename _Alloc>
struct tree_traits<Key, null_type, Cmp_Fn, Node_Update, splay_tree_tag, _Alloc>
    : public bin_search_tree_traits<Key, null_type, Cmp_Fn, Node_Update,
                                    splay_tree_node_<
                                        typename types_traits<Key, null_type,
                                                              _Alloc, false>::
                                            value_type,
                                        typename tree_node_metadata_dispatch<Key,
                                                                             null_type,
                                                                             Cmp_Fn,
                                                                             Node_Update,
                                                                             _Alloc>::
                                            type,
                                        _Alloc>,
                                    _Alloc>
{
};
}
namespace detail
{
template <typename Value_Type, typename Metadata_Type, typename _Alloc>
class ov_tree_node_const_it_
{
protected:
  typedef typename _Alloc::template rebind<Value_Type>::other::pointer pointer;
  typedef typename _Alloc::template rebind<Value_Type>::other::const_pointer
      const_pointer;
  typedef typename _Alloc::template rebind<Metadata_Type>::other::const_pointer
      const_metadata_pointer;
  typedef ov_tree_node_const_it_<Value_Type, Metadata_Type, _Alloc> this_type;
protected:
  template <typename Ptr>
  inline static Ptr
  mid_pointer (Ptr p_begin, Ptr p_end)
  {
    ;
    return (p_begin + (p_end - p_begin) / 2);
  }
public:
  typedef trivial_iterator_tag iterator_category;
  typedef trivial_iterator_difference_type difference_type;
  typedef typename _Alloc::template rebind<Value_Type>::other::const_pointer
      value_type;
  typedef typename _Alloc::template rebind<
      typename remove_const<Value_Type>::type>::other::const_pointer reference;
  typedef typename _Alloc::template rebind<
      typename remove_const<Value_Type>::type>::other::const_pointer
      const_reference;
  typedef Metadata_Type metadata_type;
  typedef
      typename _Alloc::template rebind<metadata_type>::other::const_reference
          metadata_const_reference;
public:
  inline ov_tree_node_const_it_ (const_pointer p_nd = 0,
                                 const_pointer p_begin_nd = 0,
                                 const_pointer p_end_nd = 0,
                                 const_metadata_pointer p_metadata = 0)
      : m_p_value (const_cast<pointer> (p_nd)),
        m_p_begin_value (const_cast<pointer> (p_begin_nd)),
        m_p_end_value (const_cast<pointer> (p_end_nd)),
        m_p_metadata (p_metadata)
  {
  }
  inline const_reference operator*() const { return m_p_value; }
  inline metadata_const_reference
  get_metadata () const
  {
    enum
    {
      has_metadata = !is_same<Metadata_Type, null_type>::value
    };
    typedef __gnu_pbds::detail::__static_assert_dumclass<sizeof (
        __gnu_pbds::detail::__static_assert<bool(has_metadata)>)>
        should_have_metadata__static_assert_type;
    ;
    return *m_p_metadata;
  }
  inline this_type
  get_l_child () const
  {
    if (m_p_begin_value == m_p_value)
      return (this_type (m_p_begin_value, m_p_begin_value, m_p_begin_value));
    const_metadata_pointer p_begin_metadata = m_p_metadata
                                              - (m_p_value - m_p_begin_value);
    return (this_type (mid_pointer (m_p_begin_value, m_p_value),
                       m_p_begin_value, m_p_value,
                       mid_pointer (p_begin_metadata, m_p_metadata)));
  }
  inline this_type
  get_r_child () const
  {
    if (m_p_value == m_p_end_value)
      return (this_type (m_p_end_value, m_p_end_value, m_p_end_value));
    const_metadata_pointer p_end_metadata = m_p_metadata
                                            + (m_p_end_value - m_p_value);
    return (this_type (mid_pointer (m_p_value + 1, m_p_end_value),
                       m_p_value + 1, m_p_end_value,
                       (m_p_metadata == 0)
                           ? 0
                           : mid_pointer (m_p_metadata + 1, p_end_metadata)));
  }
  inline bool operator==(const this_type &other) const
  {
    const bool is_end = m_p_begin_value == m_p_end_value;
    const bool is_other_end = other.m_p_begin_value == other.m_p_end_value;
    if (is_end)
      return (is_other_end);
    if (is_other_end)
      return (is_end);
    return m_p_value == other.m_p_value;
  }
  inline bool operator!=(const this_type &other) const
  {
    return !operator==(other);
  }
public:
  pointer m_p_value;
  pointer m_p_begin_value;
  pointer m_p_end_value;
  const_metadata_pointer m_p_metadata;
};
template <typename Value_Type, typename Metadata_Type, typename _Alloc>
class ov_tree_node_it_
    : public ov_tree_node_const_it_<Value_Type, Metadata_Type, _Alloc>
{
private:
  typedef ov_tree_node_it_<Value_Type, Metadata_Type, _Alloc> this_type;
  typedef ov_tree_node_const_it_<Value_Type, Metadata_Type, _Alloc> base_type;
  typedef typename base_type::pointer pointer;
  typedef typename base_type::const_pointer const_pointer;
  typedef typename base_type::const_metadata_pointer const_metadata_pointer;
public:
  typedef trivial_iterator_tag iterator_category;
  typedef trivial_iterator_difference_type difference_type;
  typedef
      typename _Alloc::template rebind<Value_Type>::other::pointer value_type;
  typedef typename _Alloc::template rebind<
      typename remove_const<Value_Type>::type>::other::pointer reference;
  typedef typename _Alloc::template rebind<
      typename remove_const<Value_Type>::type>::other::pointer const_reference;
  inline ov_tree_node_it_ (const_pointer p_nd = 0,
                           const_pointer p_begin_nd = 0,
                           const_pointer p_end_nd = 0,
                           const_metadata_pointer p_metadata = 0)
      : base_type (p_nd, p_begin_nd, p_end_nd, p_metadata)
  {
  }
  inline reference operator*() const
  {
    return reference (base_type::m_p_value);
  }
  inline ov_tree_node_it_
  get_l_child () const
  {
    if (base_type::m_p_begin_value == base_type::m_p_value)
      return (this_type (base_type::m_p_begin_value,
                         base_type::m_p_begin_value,
                         base_type::m_p_begin_value));
    const_metadata_pointer p_begin_metadata
        = base_type::m_p_metadata
          - (base_type::m_p_value - base_type::m_p_begin_value);
    return (this_type (
        base_type::mid_pointer (base_type::m_p_begin_value,
                                base_type::m_p_value),
        base_type::m_p_begin_value, base_type::m_p_value,
        base_type::mid_pointer (p_begin_metadata, base_type::m_p_metadata)));
  }
  inline ov_tree_node_it_
  get_r_child () const
  {
    if (base_type::m_p_value == base_type::m_p_end_value)
      return this_type (base_type::m_p_end_value, base_type::m_p_end_value,
                        base_type::m_p_end_value);
    const_metadata_pointer p_end_metadata
        = base_type::m_p_metadata
          + (base_type::m_p_end_value - base_type::m_p_value);
    return (this_type (
        base_type::mid_pointer (base_type::m_p_value + 1,
                                base_type::m_p_end_value),
        base_type::m_p_value + 1, base_type::m_p_end_value,
        (base_type::m_p_metadata == 0) ? 0 : base_type::mid_pointer (
                                                 base_type::m_p_metadata + 1,
                                                 p_end_metadata)));
  }
};
}
namespace detail
{
template <typename Key, typename Mapped, class Cmp_Fn,
          template <typename Node_CItr, class Node_Itr, class Cmp_Fn_,
                    typename _Alloc_> class Node_Update,
          typename _Alloc>
struct tree_traits<Key, Mapped, Cmp_Fn, Node_Update, ov_tree_tag, _Alloc>
{
private:
  typedef
      typename types_traits<Key, Mapped, _Alloc, false>::value_type value_type;
public:
  typedef
      typename tree_node_metadata_dispatch<Key, Mapped, Cmp_Fn, Node_Update,
                                           _Alloc>::type metadata_type;
  typedef ov_tree_node_const_it_<value_type, metadata_type, _Alloc>
      node_const_iterator;
  typedef ov_tree_node_it_<value_type, metadata_type, _Alloc> node_iterator;
  typedef Node_Update<node_const_iterator, node_iterator, Cmp_Fn, _Alloc>
      node_update;
  typedef __gnu_pbds::null_node_update<node_const_iterator, node_iterator,
                                       Cmp_Fn,
                                       _Alloc> *null_node_update_pointer;
};
template <typename Key, class Cmp_Fn,
          template <typename Node_CItr, class Node_Itr, class Cmp_Fn_,
                    typename _Alloc_> class Node_Update,
          typename _Alloc>
struct tree_traits<Key, null_type, Cmp_Fn, Node_Update, ov_tree_tag, _Alloc>
{
private:
  typedef typename types_traits<Key, null_type, _Alloc, false>::value_type
      value_type;
public:
  typedef
      typename tree_node_metadata_dispatch<Key, null_type, Cmp_Fn, Node_Update,
                                           _Alloc>::type metadata_type;
  typedef ov_tree_node_const_it_<value_type, metadata_type, _Alloc>
      node_const_iterator;
  typedef node_const_iterator node_iterator;
  typedef Node_Update<node_const_iterator, node_const_iterator, Cmp_Fn, _Alloc>
      node_update;
  typedef __gnu_pbds::null_node_update<node_const_iterator, node_iterator,
                                       Cmp_Fn,
                                       _Alloc> *null_node_update_pointer;
};
}
template <typename Key, typename Mapped, typename Hash_Fn, typename Eq_Fn,
          typename Resize_Policy, bool Store_Hash, typename Tag,
          typename Policy_Tl, typename _Alloc>
class basic_hash_table
    : public detail::
          container_base_dispatch<Key, Mapped, _Alloc, Tag,
                                  typename __gnu_cxx::typelist::append<
                                      typename __gnu_cxx::typelist::
                                          create4<Hash_Fn, Eq_Fn,
                                                  Resize_Policy,
                                                  detail::
                                                      integral_constant<int,
                                                                        Store_Hash> >::
                                              type,
                                      Policy_Tl>::type>::type
{
private:
  typedef typename detail::
      container_base_dispatch<Key, Mapped, _Alloc, Tag,
                              typename __gnu_cxx::typelist::append<
                                  typename __gnu_cxx::typelist::
                                      create4<Hash_Fn, Eq_Fn, Resize_Policy,
                                              detail::
                                                  integral_constant<int,
                                                                    Store_Hash> >::
                                          type,
                                  Policy_Tl>::type>::type base_type;
};
template <typename Key, typename Mapped,
          typename Hash_Fn = typename detail::default_hash_fn<Key>::type,
          typename Eq_Fn = typename detail::default_eq_fn<Key>::type,
          typename Comb_Hash_Fn = detail::default_comb_hash_fn::type,
          typename Resize_Policy =
              typename detail::default_resize_policy<Comb_Hash_Fn>::type,
          bool Store_Hash = detail::default_store_hash,
          typename _Alloc = std::allocator<char> >
class cc_hash_table
    : public basic_hash_table<Key, Mapped, Hash_Fn, Eq_Fn, Resize_Policy,
                              Store_Hash, cc_hash_tag,
                              typename __gnu_cxx::typelist::
                                  create1<Comb_Hash_Fn>::type,
                              _Alloc>
{
private:
  typedef basic_hash_table<Key, Mapped, Hash_Fn, Eq_Fn, Resize_Policy,
                           Store_Hash, cc_hash_tag,
                           typename __gnu_cxx::typelist::
                               create1<Comb_Hash_Fn>::type,
                           _Alloc> base_type;

public:
  typedef cc_hash_tag container_category;
  ;
};
template <typename Key, typename Mapped,
          typename Hash_Fn = typename detail::default_hash_fn<Key>::type,
          typename Eq_Fn = typename detail::default_eq_fn<Key>::type,
          typename Comb_Probe_Fn = detail::default_comb_hash_fn::type,
          typename Probe_Fn =
              typename detail::default_probe_fn<Comb_Probe_Fn>::type,
          typename Resize_Policy =
              typename detail::default_resize_policy<Comb_Probe_Fn>::type,
          bool Store_Hash = detail::default_store_hash,
          typename _Alloc = std::allocator<char> >
class gp_hash_table
    : public basic_hash_table<Key, Mapped, Hash_Fn, Eq_Fn, Resize_Policy,
                              Store_Hash, gp_hash_tag,
                              typename __gnu_cxx::typelist::
                                  create2<Comb_Probe_Fn, Probe_Fn>::type,
                              _Alloc>
{
  ;
  ;
};
template <typename Key, typename Mapped, typename Tag, typename Node_Update,
          typename Policy_Tl, typename _Alloc>
class basic_branch
    : public detail::container_base_dispatch<Key, Mapped, _Alloc, Tag,
                                             Policy_Tl>::type
{
private:
  typedef typename detail::container_base_dispatch<Key, Mapped, _Alloc, Tag,
                                                   Policy_Tl>::type base_type;

public:
  typedef Node_Update node_update;
  virtual ~basic_branch () {}

protected:
  basic_branch () {}
  basic_branch (const basic_branch &other)
      : base_type ((const base_type &)other)
  {
  }
  template <typename T0> basic_branch (T0 t0) : base_type (t0) {}
};
template <typename Key, typename Mapped, typename Cmp_Fn = std::less<Key>,
          typename Tag = rb_tree_tag,
          template <typename Node_CItr, typename Node_Itr, typename Cmp_Fn_,
                    typename _Alloc_> class Node_Update = null_node_update,
          typename _Alloc = std::allocator<char> >
class tree
    : public basic_branch<Key, Mapped, Tag,
                          typename detail::tree_traits<Key, Mapped, Cmp_Fn,
                                                       Node_Update, Tag,
                                                       _Alloc>::node_update,
                          typename __gnu_cxx::typelist::
                              create2<Cmp_Fn,
                                      detail::tree_traits<Key, Mapped, Cmp_Fn,
                                                          Node_Update, Tag,
                                                          _Alloc> >::type,
                          _Alloc>
{
private:
  typedef basic_branch<Key, Mapped, Tag,
                       typename detail::tree_traits<Key, Mapped, Cmp_Fn,
                                                    Node_Update, Tag,
                                                    _Alloc>::node_update,
                       typename __gnu_cxx::typelist::
                           create2<Cmp_Fn,
                                   detail::tree_traits<Key, Mapped, Cmp_Fn,
                                                       Node_Update, Tag,
                                                       _Alloc> >::type,
                       _Alloc> base_type;

public:
  typedef Cmp_Fn cmp_fn;
  tree () {}
  tree (const cmp_fn &c) : base_type (c) {}
  template <typename It>
  tree (It first, It last, const cmp_fn &c)
      : base_type (c)
  {
    base_type::copy_from_range (first, last);
  }
  tree (const tree &other) : base_type ((const base_type &)other) {}
  virtual ~tree () {}
  tree &operator=(const tree &other)
  {
    if (this != &other)
      {
        tree tmp (other);
        swap (tmp);
      }
    return *this;
  }
  void
  swap (tree &other)
  {
    base_type::swap (other);
  }
};
template <typename Key, typename Mapped,
          typename _ATraits =
              typename detail::default_trie_access_traits<Key>::type,
          typename Tag = pat_trie_tag,
          template <typename Node_CItr, typename Node_Itr, typename _ATraits_,
                    typename _Alloc_> class Node_Update = null_node_update,
          typename _Alloc = std::allocator<char> >
class trie
    : public basic_branch<Key, Mapped, Tag,
                          typename detail::trie_traits<Key, Mapped, _ATraits,
                                                       Node_Update, Tag,
                                                       _Alloc>::node_update,
                          typename __gnu_cxx::typelist::
                              create2<_ATraits,
                                      detail::trie_traits<Key, Mapped,
                                                          _ATraits,
                                                          Node_Update, Tag,
                                                          _Alloc> >::type,
                          _Alloc>
{
private:
  typedef basic_branch<Key, Mapped, Tag,
                       typename detail::trie_traits<Key, Mapped, _ATraits,
                                                    Node_Update, Tag,
                                                    _Alloc>::node_update,
                       typename __gnu_cxx::typelist::
                           create2<_ATraits,
                                   detail::trie_traits<Key, Mapped, _ATraits,
                                                       Node_Update, Tag,
                                                       _Alloc> >::type,
                       _Alloc> base_type;

public:
  typedef _ATraits access_traits;
};
template <typename Key, typename Mapped,
          class Eq_Fn = typename detail::default_eq_fn<Key>::type,
          class Update_Policy = detail::default_update_policy::type,
          class _Alloc = std::allocator<char> >
class list_update
    : public detail::
          container_base_dispatch<Key, Mapped, _Alloc, list_update_tag,
                                  typename __gnu_cxx::typelist::
                                      create2<Eq_Fn,
                                              Update_Policy>::type>::type
{
  ;
  ;
  ;
};
namespace test
{
class prog_bar
{
protected:
  enum
  {
    num_disp = 40
  };
public:
  prog_bar () {}
  void inc () {}
private:
  ;
  ;
private:
};
}
}
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace tr1
  {
  namespace __detail
  {
  template <typename _UIntType, int __w,
            bool = __w<std::numeric_limits<_UIntType>::digits> struct _Shift
  {
    static const _UIntType __value = 0;
  };
  template <typename _UIntType, int __w> struct _Shift<_UIntType, __w, true>
  {
    static const _UIntType __value = _UIntType (1) << __w;
  };
  template <typename _Tp, _Tp __a, _Tp __c, _Tp __m, bool> struct _Mod;
  template <typename _Tp, _Tp __a, _Tp __c, _Tp __m>
  inline _Tp
  __mod (_Tp __x)
  {
    return _Mod<_Tp, __a, __c, __m, __m == 0>::__calc (__x);
  }
  typedef __gnu_cxx::__conditional_type<(sizeof (unsigned) == 4), unsigned,
                                        unsigned long>::__type _UInt32Type;
  template <typename _Engine, typename _Distribution> struct _Adaptor
  {
    typedef typename remove_reference<_Engine>::type _BEngine;
    typedef typename _BEngine::result_type _Engine_result_type;
    typedef typename _Distribution::input_type result_type;
  public:
    _Adaptor (const _Engine &__g) : _M_g (__g) {}
    result_type operator()()
    {
      result_type __return_value;
      if (is_integral<_Engine_result_type>::value
          && is_integral<result_type>::value)
        __return_value = _M_g ();
      else if (!is_integral<_Engine_result_type>::value
               && !is_integral<result_type>::value)
        __return_value = result_type (_M_g () - _M_g.min ())
                         / result_type (_M_g.max () - _M_g.min ());
      else if (is_integral<_Engine_result_type>::value
               && !is_integral<result_type>::value)
        __return_value
            = result_type (_M_g () - _M_g.min ())
              / result_type (_M_g.max () - _M_g.min () + result_type (1));
      else
        __return_value
            = (((_M_g () - _M_g.min ()) / (_M_g.max () - _M_g.min ()))
               * std::numeric_limits<result_type>::max ());
      return __return_value;
    }
  private:
    _Engine _M_g;
  };
  template <typename _Engine, typename _Distribution>
  struct _Adaptor<_Engine *, _Distribution>
  {
    typedef typename _Engine::result_type _Engine_result_type;
    typedef typename _Distribution::input_type result_type;
  public:
  private:
    _Engine *_M_g;
  };
  }
  template <typename _Engine, typename _Dist> class variate_generator
  {
  public:
    typedef _Engine engine_type;
    typedef __detail::_Adaptor<_Engine, _Dist> engine_value_type;
    typedef _Dist distribution_type;
    typedef typename _Dist::result_type result_type;
    typedef typename __gnu_cxx::__enable_if<is_arithmetic<result_type>::value,
                                            result_type>::__type _IsValidType;
    variate_generator (engine_type __eng, distribution_type __dist)
        : _M_engine (__eng), _M_dist (__dist)
    {
    }
    result_type operator()() { return _M_dist (_M_engine); };
    ;
    ;
    ;
    ;
    ;
  private:
    engine_value_type _M_engine;
    distribution_type _M_dist;
  };
  template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
  class linear_congruential
  {
  public:
    typedef _UIntType result_type;
    static const _UIntType multiplier = __a;
    static const _UIntType increment = __c;
    static const _UIntType modulus = __m;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  private:
    ;
    _UIntType _M_x;
  };
  typedef linear_congruential<unsigned long, 16807, 0, 2147483647>
      minstd_rand0;
  typedef linear_congruential<unsigned long, 48271, 0, 2147483647> minstd_rand;
  template <class _UIntType, int __w, int __n, int __m, int __r, _UIntType __a,
            int __u, int __s, _UIntType __b, int __t, _UIntType __c, int __l>
  class mersenne_twister
  {
  public:
    typedef _UIntType result_type;
    static const int word_size = __w;
    static const int state_size = __n;
    static const int shift_size = __m;
    static const int mask_bits = __r;
    static const _UIntType parameter_a = __a;
    static const int output_u = __u;
    static const int output_s = __s;
    static const _UIntType output_b = __b;
    static const int output_t = __t;
    static const _UIntType output_c = __c;
    static const int output_l = __l;
    mersenne_twister () { seed (); }
    template <class _Gen> mersenne_twister (_Gen &__g) { seed (__g); }
    void
    seed ()
    {
      seed (5489UL);
    }
    void seed (unsigned long __value);
    template <class _Gen>
    void
    seed (_Gen &__g)
    {
      seed (__g, typename is_fundamental<_Gen>::type ());
    }
    result_type
    min () const
    {
      return 0;
    };
    result_type
    max () const
    {
      return __detail::_Shift<_UIntType, __w>::__value - 1;
    }
    result_type operator()();
    ;
    ;
  private:
    template <class _Gen>
    void
    seed (_Gen &__g, true_type)
    {
      return seed (static_cast<unsigned long> (__g));
    }
    template <class _Gen> void seed (_Gen &__g, false_type);
    _UIntType _M_x[state_size];
    int _M_p;
  };
  typedef mersenne_twister<unsigned long, 32, 624, 397, 31, 0x9908b0dful, 11,
                           7, 0x9d2c5680ul, 15, 0xefc60000ul, 18> mt19937;
  template <typename _IntType, _IntType __m, int __s, int __r>
  class subtract_with_carry
  {
  public:
    typedef _IntType result_type;
    static const _IntType modulus = __m;
    static const int long_lag = __r;
    static const int short_lag = __s;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  private:
    ;
    ;
    typedef typename __gnu_cxx::__add_unsigned<_IntType>::__type _UIntType;
    _UIntType _M_x[long_lag];
    _UIntType _M_carry;
    int _M_p;
  };
  class bernoulli_distribution
  {
  public:
    typedef int input_type;
    typedef bool result_type;
  public:
    ;
    ;
    ;
    ;
    ;
    ;
  private:
    double _M_p;
  };
  template <typename _IntType = int, typename _RealType = double>
  class geometric_distribution
  {
  public:
    typedef _RealType input_type;
    typedef _IntType result_type;
    ;
    ;
    ;
    ;
    ;
    ;
  private:
    ;
    _RealType _M_p;
    _RealType _M_log_p;
  };
  template <typename _RealType> class normal_distribution;
  template <typename _IntType = int, typename _RealType = double>
  class poisson_distribution
  {
  public:
    typedef _RealType input_type;
    typedef _IntType result_type;
    ;
    ;
    ;
    ;
    ;
    ;
  private:
    ;
    normal_distribution<_RealType> _M_nd;
    _RealType _M_mean;
    _RealType _M_lm_thr;
    _RealType _M_lfm, _M_sm, _M_d, _M_scx, _M_1cx, _M_c2b, _M_cb;
  };
  template <typename _IntType = int, typename _RealType = double>
  class binomial_distribution
  {
  public:
    typedef _RealType input_type;
    typedef _IntType result_type;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  private:
    ;
    ;
    normal_distribution<_RealType> _M_nd;
    _RealType _M_q;
    _RealType _M_d1, _M_d2, _M_s1, _M_s2, _M_c, _M_a1, _M_a123, _M_s, _M_lf,
        _M_lp1p;
    _RealType _M_p;
    _IntType _M_t;
    bool _M_easy;
  };
  template <typename _RealType = double> class uniform_real
  {
  public:
    typedef _RealType input_type;
    typedef _RealType result_type;
  public:
    explicit uniform_real (_RealType __min = _RealType (0),
                           _RealType __max = _RealType (1))
        : _M_min (__min), _M_max (__max)
    {
      ;
    }
    result_type
    min () const
    {
      return _M_min;
    }
    result_type
    max () const
    {
      return _M_max;
    }
    template <class _UniformRandomNumberGenerator>
    result_type operator()(_UniformRandomNumberGenerator &__urng)
    {
      return (__urng () * (_M_max - _M_min)) + _M_min;
    };
    ;
  private:
    _RealType _M_min;
    _RealType _M_max;
  };
  template <typename _RealType = double> class exponential_distribution
  {
  public:
    typedef _RealType input_type;
    typedef _RealType result_type;
  public:
    ;
    ;
    ;
  private:
    result_type _M_lambda;
  };
  template <typename _RealType = double> class normal_distribution
  {
  public:
    typedef _RealType input_type;
    typedef _RealType result_type;
  public:
    ;
    ;
    ;
    ;
    ;
    ;
    ;
  private:
    result_type _M_mean;
    result_type _M_sigma;
    result_type _M_saved;
    bool _M_saved_available;
  };
  template <typename _RealType = double> class gamma_distribution
  {
  public:
    typedef _RealType input_type;
    typedef _RealType result_type;
  public:
    ;
    ;
    ;
    result_type _M_alpha;
    result_type _M_l_d;
  };
  }
  namespace tr1
  {
  namespace __detail
  {
  template <typename _Tp, _Tp __a, _Tp __c, _Tp __m, bool> struct _Mod
  {
    static _Tp
    __calc (_Tp __x)
    {
      if (__a == 1)
        __x %= __m;
      else
        {
          static const _Tp __q = __m / __a;
          static const _Tp __r = __m % __a;
          _Tp __t1 = __a * (__x % __q);
          _Tp __t2 = __r * (__x / __q);
          if (__t1 >= __t2)
            __x = __t1 - __t2;
          else
            __x = __m - __t2 + __t1;
        }
      if (__c != 0)
        {
          const _Tp __d = __m - __x;
          if (__d > __c)
            __x += __c;
          else
            __x = __c - __d;
        }
      return __x;
    }
  };
  template <typename _Tp, _Tp __a, _Tp __c, _Tp __m>
  struct _Mod<_Tp, __a, __c, __m, true>
  {
    ;
  };
  }
  template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
  const _UIntType linear_congruential<_UIntType, __a, __c, __m>::multiplier;
  template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
  const _UIntType linear_congruential<_UIntType, __a, __c, __m>::increment;
  template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
  const _UIntType linear_congruential<_UIntType, __a, __c, __m>::modulus;
  template <class _UIntType, int __w, int __n, int __m, int __r, _UIntType __a,
            int __u, int __s, _UIntType __b, int __t, _UIntType __c, int __l>
  void
  mersenne_twister<_UIntType, __w, __n, __m, __r, __a, __u, __s, __b, __t, __c,
                   __l>::seed (unsigned long __value)
  {
    _M_x[0]
        = __detail::__mod<_UIntType, 1, 0,
                          __detail::_Shift<_UIntType, __w>::__value> (__value);
    for (int __i = 1; __i < state_size; ++__i)
      {
        _UIntType __x = _M_x[__i - 1];
        __x ^= __x >> (__w - 2);
        __x *= 1812433253ul;
        __x += __i;
        _M_x[__i]
            = __detail::__mod<_UIntType, 1, 0,
                              __detail::_Shift<_UIntType, __w>::__value> (__x);
      }
    _M_p = state_size;
  }
  template <class _UIntType, int __w, int __n, int __m, int __r, _UIntType __a,
            int __u, int __s, _UIntType __b, int __t, _UIntType __c, int __l>
  template <class _Gen>
  void
  mersenne_twister<_UIntType, __w, __n, __m, __r, __a, __u, __s, __b, __t, __c,
                   __l>::seed (_Gen &__gen, false_type)
  {
    for (int __i = 0; __i < state_size; ++__i)
      _M_x[__i] = __detail::__mod<_UIntType, 1, 0,
                                  __detail::_Shift<_UIntType, __w>::__value> (
          __gen ());
    _M_p = state_size;
  }
  template <class _UIntType, int __w, int __n, int __m, int __r, _UIntType __a,
            int __u, int __s, _UIntType __b, int __t, _UIntType __c, int __l>
  typename mersenne_twister<_UIntType, __w, __n, __m, __r, __a, __u, __s, __b,
                            __t, __c, __l>::result_type
      mersenne_twister<_UIntType, __w, __n, __m, __r, __a, __u, __s, __b, __t,
                       __c, __l>::
      operator()()
  {
    if (_M_p >= state_size)
      {
        const _UIntType __upper_mask = (~_UIntType ()) << __r;
        const _UIntType __lower_mask = ~__upper_mask;
        for (int __k = 0; __k < (__n - __m); ++__k)
          {
            _UIntType __y = ((_M_x[__k] & __upper_mask)
                             | (_M_x[__k + 1] & __lower_mask));
            _M_x[__k]
                = (_M_x[__k + __m] ^ (__y >> 1) ^ ((__y & 0x01) ? __a : 0));
          }
        for (int __k = (__n - __m); __k < (__n - 1); ++__k)
          {
            _UIntType __y = ((_M_x[__k] & __upper_mask)
                             | (_M_x[__k + 1] & __lower_mask));
            _M_x[__k] = (_M_x[__k + (__m - __n)] ^ (__y >> 1)
                         ^ ((__y & 0x01) ? __a : 0));
          }
        _UIntType __y
            = ((_M_x[__n - 1] & __upper_mask) | (_M_x[0] & __lower_mask));
        _M_x[__n - 1]
            = (_M_x[__m - 1] ^ (__y >> 1) ^ ((__y & 0x01) ? __a : 0));
        _M_p = 0;
      }
    result_type __z = _M_x[_M_p++];
    __z ^= (__z >> __u);
    __z ^= (__z << __s) & __b;
    __z ^= (__z << __t) & __c;
    __z ^= (__z >> __l);
    return __z;
  }
  template <typename _IntType, _IntType __m, int __s, int __r>
  const _IntType subtract_with_carry<_IntType, __m, __s, __r>::modulus;
  template <typename _IntType, _IntType __m, int __s, int __r>
  const int subtract_with_carry<_IntType, __m, __s, __r>::long_lag;
  ;
  ;
  template <typename _RealType, typename _CharT, typename _Traits>
  std::basic_ostream<_CharT, _Traits> &
  operator<<(std::basic_ostream<_CharT, _Traits> &__os,
             const gamma_distribution<_RealType> &__x);
  }
}
namespace __gnu_pbds
{
namespace test
{
class twister_rand_gen
{
public:
  twister_rand_gen (unsigned int seed
                    = static_cast<unsigned int> (std::time (0)))
      : m_base_generator (seed)
  {
  }
  void
  init (unsigned int seed)
  {
    m_base_generator.seed (seed);
  }
  static unsigned int
  get_time_determined_seed ()
  {
    return (static_cast<unsigned int> (std::time (0)));
  }
  unsigned long
  get_unsigned_long (unsigned long min = 0,
                     unsigned long max = (0x7fffffff * 2U + 1U) - 1)
  {
    ;
    const double prob = get_prob ();
    const unsigned long r = (unsigned long)((max - min + 1) * prob) + min;
    ;
    return r;
  }
  double
  get_prob ()
  {
    const double min = m_base_generator.min ();
    const double max = m_base_generator.max ();
    const double range = static_cast<const double> (max - min);
    const double res = static_cast<const double> (m_base_generator () - min);
    const double ret = res / range;
    ;
    return ret;
  }
private:
  typedef std::tr1::mt19937 base_generator_t;
  base_generator_t m_base_generator;
};
}
namespace test
{
namespace detail
{
template <typename T>
struct regression_test_erase_if_fn : public std::unary_function<T, bool>
{
private:
  typedef const T &const_reference;
public:
  bool operator()(const_reference r_t) const
  {
    return (r_t.length () == 0
            || static_cast<size_t> (*((r_t).begin ())) % 2 == 1);
  }
};
template <typename Hd, class Tl>
struct regression_test_erase_if_fn<std::pair<Hd, Tl> >
    : public std::unary_function<std::pair<Hd, Tl>, bool>
{
private:
  typedef const std::pair<Hd, Tl> &const_reference;
  typedef regression_test_erase_if_fn<Hd> hd_erase_if_fn;
  typedef regression_test_erase_if_fn<Tl> tl_erase_if_fn;
public:
  bool operator()(const_reference r_t) const
  {
    return (hd_erase_if_fn ()(r_t.first) && tl_erase_if_fn ()(r_t.second));
  }
};
}
}
}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
  struct forced_error : public std::exception
  {
  };
  inline void __throw_forced_error () { (throw (forced_error ())); }
  struct annotate_base
  {
    annotate_base ()
    {
      label ();
      map_alloc ();
    }
    static void
    set_label (size_t l)
    {
      label () = l;
    }
    static size_t
    get_label ()
    {
      return label ();
    }
    void
    insert (void *p, size_t size)
    {
      if (!p)
        {
          std::string error ("annotate_base::insert null insert!\n");
          log_to_string (error, make_entry (p, size));
          std::__throw_logic_error (error.c_str ());
        }
      const_iterator found = map_alloc ().find (p);
      if (found != map_alloc ().end ())
        {
          std::string error ("annotate_base::insert double insert!\n");
          log_to_string (error, make_entry (p, size));
          log_to_string (error, *found);
          std::__throw_logic_error (error.c_str ());
        }
      map_alloc ().insert (make_entry (p, size));
    }
    void
    erase (void *p, size_t size)
    {
      check_allocated (p, size);
      map_alloc ().erase (p);
    }
    inline void
    check_allocated (void *p, size_t size)
    {
      const_iterator found = map_alloc ().find (p);
      if (found == map_alloc ().end ())
        {
          std::string error ("annotate_base::check_allocated by value "
                             "null erase!\n");
          log_to_string (error, make_entry (p, size));
          std::__throw_logic_error (error.c_str ());
        }
      if (found->second.second != size)
        {
          std::string error ("annotate_base::check_allocated by value "
                             "wrong-size erase!\n");
          log_to_string (error, make_entry (p, size));
          log_to_string (error, *found);
          std::__throw_logic_error (error.c_str ());
        }
    }
    inline void
    check (size_t label)
    {
      std::string found;
      {
        const_iterator beg = map_alloc ().begin ();
        const_iterator end = map_alloc ().end ();
        while (beg != end)
          {
            if (beg->second.first == label)
              log_to_string (found, *beg);
            ++beg;
          }
      }
      if (!found.empty ())
        {
          std::string error ("annotate_base::check by label\n");
          error += found;
          std::__throw_logic_error (error.c_str ());
        }
    }

  private:
    typedef std::pair<size_t, size_t> data_type;
    typedef std::map<void *, data_type> map_alloc_type;
    typedef map_alloc_type::value_type entry_type;
    typedef map_alloc_type::const_iterator const_iterator;
    typedef map_alloc_type::const_reference const_reference;
    friend std::ostream &operator<<(std::ostream &, const annotate_base &);
    entry_type
    make_entry (void *p, size_t size)
    {
      return std::make_pair (p, data_type (get_label (), size));
    }
    static void
    log_to_string (std::string &s, const_reference ref)
    {
      char buf[40];
      const char tab ('\t');
      s += "label: ";
      unsigned long l = static_cast<unsigned long> (ref.second.first);
      __builtin_sprintf (buf, "%lu", l);
      s += buf;
      s += tab;
      s += "size: ";
      l = static_cast<unsigned long> (ref.second.second);
      __builtin_sprintf (buf, "%lu", l);
      s += buf;
      s += tab;
      s += "address: ";
      __builtin_sprintf (buf, "%p", ref.first);
      s += buf;
      s += '\n';
    }
    static size_t &
    label ()
    {
      static size_t _S_label (std::numeric_limits<size_t>::max ());
      return _S_label;
    }
    static map_alloc_type &
    map_alloc ()
    {
      static map_alloc_type _S_map;
      return _S_map;
    }
  };
  inline std::ostream &operator<<(std::ostream & os, const annotate_base &__b)
  {
    std::string error;
    typedef annotate_base base_type;
    {
      base_type::const_iterator beg = __b.map_alloc ().begin ();
      base_type::const_iterator end = __b.map_alloc ().end ();
      for (; beg != end; ++beg)
        __b.log_to_string (error, *beg);
    }
    return os << error;
  }
  struct condition_base
  {
    virtual ~condition_base (){};
  };
  struct random_condition : public condition_base
  {
    struct adjustor_base
    {
    private:
      const double _M_orig;
    public:
      adjustor_base () : _M_orig (probability ()) {}
      virtual ~adjustor_base () { set_probability (_M_orig); }
    };
    struct group_adjustor : public adjustor_base
    {
      group_adjustor (size_t size)
      {
        set_probability (1 - std::pow (double(1 - probability ()),
                                       double(0.5 / (size + 1))));
      }
    };
    struct never_adjustor : public adjustor_base
    {
    };
    struct always_adjustor : public adjustor_base
    {
    };
    random_condition ()
    {
      probability ();
      engine ();
    }
    static void
    set_probability (double __p)
    {
      probability () = __p;
    }
    static void
    throw_conditionally ()
    {
      if (generate () < probability ())
        __throw_forced_error ();
    }
    void
    seed (unsigned long __s)
    {
      engine ().seed (__s);
    }

  private:
    typedef std::tr1::uniform_real<double> distribution_type;
    typedef std::tr1::mt19937 engine_type;
    static double
    generate ()
    {
      typedef std::tr1::variate_generator<engine_type, distribution_type>
          gen_t;
      distribution_type distribution (0, 1);
      static gen_t generator (engine (), distribution);
      double random = generator ();
      if (random < distribution.min () || random > distribution.max ())
        {
          std::string __s ("random_condition::generate");
          __s += "\n";
          __s += "random number generated is: ";
          char buf[40];
          __builtin_sprintf (buf, "%f", random);
          __s += buf;
          std::__throw_out_of_range (__s.c_str ());
        }
      return random;
    }
    static double &
    probability ()
    {
      static double _S_p;
      return _S_p;
    }
    static engine_type &
    engine ()
    {
      static engine_type _S_e;
      return _S_e;
    }
  };
  template <typename _Tp, typename _Cond>
  class throw_allocator_base : public annotate_base, public _Cond
  {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp value_type;
    typedef value_type *pointer;
    typedef const value_type *const_pointer;
    typedef value_type &reference;
    typedef const value_type &const_reference;

  private:
    typedef _Cond condition_type;
    std::allocator<value_type> _M_allocator;
    using condition_type::throw_conditionally;

  public:
    size_type
    max_size () const throw ()
    {
      return _M_allocator.max_size ();
    }
    pointer
    allocate (size_type __n, std::allocator<void>::const_pointer hint = 0)
    {
      if (__n > this->max_size ())
        std::__throw_bad_alloc ();
      throw_conditionally ();
      pointer const a = _M_allocator.allocate (__n, hint);
      insert (a, sizeof (value_type) * __n);
      return a;
    }
    void
    construct (pointer __p, const value_type &val)
    {
      return _M_allocator.construct (__p, val);
    }
    void
    destroy (pointer __p)
    {
      _M_allocator.destroy (__p);
    }
    void
    deallocate (pointer __p, size_type __n)
    {
      erase (__p, sizeof (value_type) * __n);
      _M_allocator.deallocate (__p, __n);
    }
    void
    check (size_type __n)
    {
      annotate_base::check (__n);
    }
  };
  template <typename _Tp, typename _Cond>
  inline bool operator==(const throw_allocator_base<_Tp, _Cond> &,
                         const throw_allocator_base<_Tp, _Cond> &)
  {
    return true;
  }
  template <typename _Tp>
  struct throw_allocator_random
      : public throw_allocator_base<_Tp, random_condition>
  {
    template <typename _Tp1> struct rebind
    {
      typedef throw_allocator_random<_Tp1> other;
    };
    throw_allocator_random () throw () {}
    throw_allocator_random (const throw_allocator_random &) throw () {}
    template <typename _Tp1>
    throw_allocator_random (const throw_allocator_random<_Tp1> &) throw ()
    {
    }
    ~throw_allocator_random () throw () {}
  };
}
namespace __gnu_pbds
{
namespace test
{
struct basic_type
    : public std::basic_string<char, std::char_traits<char>,
                               __gnu_cxx::throw_allocator_random<char> >
{
private:
  typedef std::basic_string<char, std::char_traits<char>,
                            __gnu_cxx::throw_allocator_random<char> >
      base_type;
public:
  enum
  {
    distinct_chars = 4
  };
  basic_type () {}
  template <typename Gen> basic_type (Gen &r_gen, size_t max)
  {
    size_t rnd = r_gen.get_unsigned_long (0, static_cast<unsigned long> (max));
    while (rnd > 0)
      {
        base_type::push_back ('a' + static_cast<char> (rnd % distinct_chars));
        rnd /= distinct_chars;
      }
  }
  basic_type (const std::string other)
  {
    std::string::const_iterator it = other.begin ();
    while (it != other.end ())
      {
        base_type::push_back (*it);
        ++it;
      }
  }
  operator std::string() const { return std::string (base_type::c_str ()); }
};
}
namespace test
{
namespace detail
{
std::string
to_string (const basic_type &r_t)
{
  return (r_t);
}
std::string
to_string (const std::string &r_t)
{
  return (r_t);
}
template <typename Hd, class Tl>
std::string
to_string (const std::pair<Hd, Tl> &r_t)
{
  std::ostringstream ret;
  ret << to_string (r_t.first) << " " << to_string (r_t.second);
  return (ret.str ());
}
}
}
namespace test
{
namespace detail
{
template <typename Cntnr> struct regression_test_type_traits
{
  typedef Cntnr cntnr;
  typedef typename cntnr::key_type key_type;
  typedef typename cntnr::key_const_reference key_const_reference;
  typedef typename cntnr::value_type value_type;
  typedef typename cntnr::const_reference const_reference;
  typedef typename cntnr::mapped_type mapped_type;
  typedef typename cntnr::mapped_const_reference mapped_const_reference;
  template <typename Gen>
  static key_type
  generate_key (Gen &r_gen, size_t max)
  {
    return basic_type (r_gen, max);
  }
  template <typename Gen>
  static value_type
  generate_value (Gen &r_gen, size_t max)
  {
    return generate_value (r_gen, max, value_type ());
  }
  static key_const_reference
  extract_key (const_reference r_val)
  {
    return extract_key_imp (r_val);
  }
private:
  typedef typename cntnr::allocator_type::template rebind<basic_type>::other
      basic_type_rebind;
  typedef
      typename basic_type_rebind::const_reference basic_type_const_reference;
  typedef typename cntnr::allocator_type::
      template rebind<std::pair<const basic_type, basic_type> >::other
          pair_type_rebind;
  typedef typename pair_type_rebind::const_reference pair_type_const_reference;
  template <typename Gen>
  static value_type
  generate_value (Gen &gen, size_t max,
                  std::pair<const basic_type, basic_type>)
  {
    return std::make_pair (basic_type (gen, max), basic_type (gen, max));
  }
  static key_const_reference
  extract_key_imp (basic_type_const_reference r_val)
  {
    return r_val;
  }
  static key_const_reference
  extract_key_imp (pair_type_const_reference r_val)
  {
    return r_val.first;
  }
};
}
}
namespace test
{
namespace detail
{
template <typename Key, typename _Alloc> struct native_key_type;
template <typename _Alloc> struct native_key_type<basic_type, _Alloc>
{
  typedef std::string type;
  static type
  native_key (
      typename _Alloc::template rebind<basic_type>::other::const_reference
          r_key)
  {
    return (std::string (r_key));
  }
};
template <typename Hd, class Tl, typename _Alloc>
struct native_key_type<std::pair<Hd, Tl>, _Alloc>
{
  typedef typename native_key_type<Hd, _Alloc>::type hd_type;
  typedef typename native_key_type<Tl, _Alloc>::type tl_type;
  typedef std::pair<hd_type, tl_type> type;
};
template <typename Native_Key_Type, class Key_Type, class Data_Type,
          typename _Alloc>
struct native_type_traits_base;
template <typename Native_Key_Type, class Key_Type, typename _Alloc>
struct native_type_traits_base<Native_Key_Type, Key_Type, basic_type, _Alloc>
{
public:
  typedef std::map<Native_Key_Type, std::string> type;
public:
  static const typename type::key_type &
  extract_key (typename type::const_reference r_val)
  {
    return (r_val.first);
  }
  static typename type::value_type
  native_value (
      typename _Alloc::template rebind<std::pair<Key_Type, basic_type> >::
          other::const_reference r_val)
  {
    return (std::make_pair (
        native_key_type<Key_Type, _Alloc>::native_key (r_val.first),
        std::string (r_val.second)));
  }
};
template <typename Native_Key_Type, class Key_Type, typename _Alloc>
struct native_type_traits_base<Native_Key_Type, Key_Type,
                               __gnu_pbds::null_type, _Alloc>
{
public:
  typedef std::set<Native_Key_Type> type;
public:
};
template <typename Key_Type, class Data_Type, typename _Alloc>
struct native_type_traits
    : public native_type_traits_base<
          typename native_key_type<Key_Type, _Alloc>::type, Key_Type,
          Data_Type, _Alloc>
{
  typedef typename native_type_traits_base<
      typename native_key_type<Key_Type, _Alloc>::type, Key_Type, Data_Type,
      _Alloc>::type type;
  typedef typename type::key_type key_type;
  static typename native_key_type<Key_Type, _Alloc>::type
  native_key (
      typename _Alloc::template rebind<Key_Type>::other::const_reference r_key)
  {
    return (native_key_type<Key_Type, _Alloc>::native_key (r_key));
  }
};
}
}
namespace test
{
namespace detail
{
template <typename Cntnr, class Tag> struct regression_test_resize_traits
{
  enum
  {
    value = false
  };
};
template <typename Cntnr> struct regression_test_hash_resize_traits
{
  enum
  {
    value = Cntnr::resize_policy::external_size_access
  };
};
template <typename Cntnr>
struct regression_test_resize_traits<Cntnr, __gnu_pbds::cc_hash_tag>
    : public regression_test_hash_resize_traits<Cntnr>
{
};
template <typename Cntnr>
struct regression_test_resize_traits<Cntnr, __gnu_pbds::gp_hash_tag>
    : public regression_test_hash_resize_traits<Cntnr>
{
};
}
}
namespace test
{
namespace detail
{
template <typename Cntnr, class Tag>
struct regression_test_get_set_loacontainer_traits
{
  enum
  {
    value = false
  };
};
template <typename Cntnr>
struct regression_test_hash_get_set_loacontainer_traits
{
  enum
  {
    value = Cntnr::resize_policy::trigger_policy::get_set_loads
  };
};
template <typename Cntnr>
struct regression_test_get_set_loacontainer_traits<Cntnr,
                                                   __gnu_pbds::cc_hash_tag>
    : public regression_test_hash_get_set_loacontainer_traits<Cntnr>
{
};
template <typename Cntnr>
struct regression_test_get_set_loacontainer_traits<Cntnr,
                                                   __gnu_pbds::gp_hash_tag>
    : public regression_test_hash_get_set_loacontainer_traits<Cntnr>
{
};
}
}
namespace test
{
namespace detail
{
template <typename Cntnr, class Tag> struct regression_test_get_set_load_traits
{
  enum
  {
    value = false
  };
};
template <typename Cntnr> struct regression_test_hash_get_set_load_traits
{
  enum
  {
    value = Cntnr::resize_policy::trigger_policy::get_set_load
  };
};
template <typename Cntnr>
struct regression_test_get_set_load_traits<Cntnr, __gnu_pbds::cc_hash_tag>
    : public regression_test_hash_get_set_load_traits<Cntnr>
{
};
template <typename Cntnr>
struct regression_test_get_set_load_traits<Cntnr, __gnu_pbds::gp_hash_tag>
    : public regression_test_hash_get_set_load_traits<Cntnr>
{
};
}
}
namespace test
{
namespace detail
{
template <typename Tree_Cntnr> struct tree_supports_order_statistics
{
  enum
  {
    value = __gnu_pbds::detail::is_same<
        typename Tree_Cntnr::node_update,
        __gnu_pbds::tree_order_statistics_node_update<
            typename Tree_Cntnr::node_const_iterator,
            typename Tree_Cntnr::node_iterator, typename Tree_Cntnr::cmp_fn,
            typename Tree_Cntnr::allocator_type> >::value
  };
};
}
}
namespace test
{
namespace detail
{
template <typename Tree_Cntnr> struct trie_supports_order_statistics
{
  enum
  {
    value = __gnu_pbds::detail::is_same<
        typename Tree_Cntnr::node_update,
        __gnu_pbds::trie_order_statistics_node_update<
            typename Tree_Cntnr::node_const_iterator,
            typename Tree_Cntnr::node_iterator,
            typename Tree_Cntnr::access_traits,
            typename Tree_Cntnr::allocator_type> >::value
  };
};
}
}
namespace test
{
namespace detail
{
template <typename Tree_Cntnr> struct trie_supports_prefix_search
{
  enum
  {
    value = __gnu_pbds::detail::is_same<
        typename Tree_Cntnr::node_update,
        __gnu_pbds::trie_prefix_search_node_update<
            typename Tree_Cntnr::node_const_iterator,
            typename Tree_Cntnr::node_iterator,
            typename Tree_Cntnr::access_traits,
            typename Tree_Cntnr::allocator_type> >::value
  };
};
}
}
namespace test
{
namespace detail
{
template <typename Cntnr, class Tag> struct regression_test_node_update_traits
{
  enum
  {
    order_statistics = false,
    prefix_search = false
  };
};
template <typename Cntnr>
struct regression_test_node_update_traits<Cntnr, __gnu_pbds::pat_trie_tag>
{
  enum
  {
    order_statistics = trie_supports_order_statistics<Cntnr>::value,
    prefix_search = trie_supports_prefix_search<Cntnr>::value
  };
};
template <typename Cntnr>
struct regression_test_node_update_traits<Cntnr, __gnu_pbds::rb_tree_tag>
{
  enum
  {
    order_statistics = tree_supports_order_statistics<Cntnr>::value,
    prefix_search = false
  };
};
template <typename Cntnr>
struct regression_test_node_update_traits<Cntnr, __gnu_pbds::splay_tree_tag>
{
  enum
  {
    order_statistics = tree_supports_order_statistics<Cntnr>::value,
    prefix_search = false
  };
};
template <typename Cntnr>
struct regression_test_node_update_traits<Cntnr, __gnu_pbds::ov_tree_tag>
{
  enum
  {
    order_statistics = tree_supports_order_statistics<Cntnr>::value,
    prefix_search = false
  };
};
}
}
namespace test
{
namespace detail
{
template <typename Cntnr>
struct regression_test_traits
    : private regression_test_type_traits<Cntnr>,
      private native_type_traits<
          typename regression_test_type_traits<Cntnr>::key_type,
          typename regression_test_type_traits<Cntnr>::mapped_type,
          typename Cntnr::allocator_type>,
      private regression_test_resize_traits<Cntnr, typename Cntnr::
                                                       container_category>,
      private regression_test_node_update_traits<Cntnr,
                                                 typename Cntnr::
                                                     container_category>,
      private regression_test_get_set_loacontainer_traits<Cntnr,
                                                          typename Cntnr::
                                                              container_category>,
      private regression_test_get_set_load_traits<Cntnr,
                                                  typename Cntnr::
                                                      container_category>
{
private:
  typedef native_type_traits<
      typename regression_test_type_traits<Cntnr>::key_type,
      typename regression_test_type_traits<Cntnr>::mapped_type,
      typename Cntnr::allocator_type> native_type_traits_base;
  typedef regression_test_type_traits<Cntnr> type_traits_base;
public:
  typedef typename Cntnr::value_type value_type;
  typedef typename Cntnr::const_reference const_reference;
  typedef typename native_type_traits<
      typename regression_test_type_traits<Cntnr>::key_type,
      typename regression_test_type_traits<Cntnr>::mapped_type,
      typename Cntnr::allocator_type>::type native_type;
  typedef typename native_type::value_type native_value_type;
  typedef typename Cntnr::key_type key_type;
  typedef typename Cntnr::key_const_reference key_const_reference;
  typedef typename native_type::key_type native_key_type;
  enum
  {
    resize
    = regression_test_resize_traits<Cntnr,
                                    typename Cntnr::container_category>::value,
    get_set_loads
    = regression_test_get_set_loacontainer_traits<Cntnr,
                                                  typename Cntnr::
                                                      container_category>::
        value,
    get_set_load
    = regression_test_get_set_load_traits<Cntnr,
                                          typename Cntnr::container_category>::
        value,
    order_statistics
    = regression_test_node_update_traits<Cntnr,
                                         typename Cntnr::container_category>::
        order_statistics,
    prefix_search
    = regression_test_node_update_traits<Cntnr,
                                         typename Cntnr::container_category>::
        prefix_search
  };
  template <typename T>
  struct erase_if_fn : public regression_test_erase_if_fn<T>
  {
  };
  static size_t
  erase_if (native_type &r_native_c)
  {
    typedef regression_test_erase_if_fn<native_value_type> erase_if_fn;
    typename native_type::iterator it = r_native_c.begin ();
    size_t num_ersd = 0;
    while (it != r_native_c.end ())
      if (erase_if_fn ()(*it))
        {
          ++num_ersd;
          r_native_c.erase (it);
          it = r_native_c.begin ();
        }
      else
        ++it;
    return num_ersd;
  }
  template <typename Gen>
  static key_type
  generate_key (Gen &r_gen, size_t max)
  {
    return regression_test_type_traits<Cntnr>::generate_key (r_gen, max);
  }
  template <typename Gen>
  static value_type
  generate_value (Gen &r_gen, size_t max)
  {
    return regression_test_type_traits<Cntnr>::generate_value (r_gen, max);
  }
  static key_const_reference
  extract_key (const_reference r_val)
  {
    return type_traits_base::extract_key (r_val);
  }
  static native_key_type
  native_key (key_const_reference r_key)
  {
    return native_type_traits_base::native_key (r_key);
  }
  static native_value_type
  native_value (const_reference r_val)
  {
    return native_type_traits_base::native_value (r_val);
  }
  static const native_key_type &
  extract_native_key (const native_value_type &r_val)
  {
    return native_type_traits_base::extract_key (r_val);
  }
  static bool
  cmp (const_reference r_val, const native_value_type &r_native_val)
  {
    return val_to_string (r_val) == native_val_to_string (r_native_val);
  }
  static std::string
  val_to_string (const_reference r_val)
  {
    return to_string (r_val);
  }
  static std::string
  key_to_string (key_const_reference r_key)
  {
    return to_string (r_key);
  }
  static std::string
  native_val_to_string (const native_value_type &r_native_val)
  {
    return to_string (r_native_val);
  }
};
}
}
namespace test
{
struct native_hash_tag
{
};
}
namespace test
{
namespace detail
{
std::string
make_xml_name_start_tag (std::string name)
{
  return ("<" + name);
}
template <typename V>
std::string
make_xml_attrib_val (std::string attrib, const V val)
{
  std::ostringstream sstrm;
  sstrm << " " << attrib << " = \"" << val << "\"";
  return (sstrm.str ());
}
std::string
make_xml_name_start_tag_end_delimiter ()
{
  return (">\n");
}
std::string
make_xml_name_end_tag (std::string name)
{
  return ("</" + name + ">\n");
}
}
std::string
make_xml_tag (const std::string name,
              const std::string data = std::string (""))
{
  std::ostringstream sstrm;
  sstrm << detail::make_xml_name_start_tag (name);
  sstrm << detail::make_xml_name_start_tag_end_delimiter ();
  sstrm << data;
  sstrm << detail::make_xml_name_end_tag (name);
  return sstrm.str ();
}
template <typename Val0>
std::string
make_xml_tag (const std::string name, const std::string attrib0,
              const Val0 val0, const std::string data = std::string (""))
{
  std::ostringstream sstrm;
  sstrm << detail::make_xml_name_start_tag (name);
  sstrm << detail::make_xml_attrib_val (attrib0, val0);
  sstrm << detail::make_xml_name_start_tag_end_delimiter ();
  sstrm << data;
  sstrm << detail::make_xml_name_end_tag (name);
  return sstrm.str ();
};
}
namespace test
{
struct native_tree_tag
{
};
}
namespace test
{
template <typename _Alloc>
struct direct_mask_range_hashing_t_
    : public __gnu_pbds::direct_mask_range_hashing<typename _Alloc::size_type>
{
  typedef typename _Alloc::size_type size_type;
  typedef __gnu_pbds::direct_mask_range_hashing<size_type> base_type;
};
template <typename _Alloc>
struct direct_mod_range_hashing_t_
    : public __gnu_pbds::direct_mod_range_hashing<typename _Alloc::size_type>
{
  typedef typename _Alloc::size_type size_type;
  typedef __gnu_pbds::direct_mod_range_hashing<size_type> base_type;
};
template <typename _Alloc, typename _Alloc::size_type Min_Load_Nom,
          typename _Alloc::size_type Min_Load_Denom,
          typename _Alloc::size_type Max_Load_Nom,
          typename _Alloc::size_type Max_Load_Denom, bool External_Access>
struct hash_load_check_resize_trigger_t_
    : public __gnu_pbds::
          hash_load_check_resize_trigger<External_Access,
                                         typename _Alloc::size_type>
{
  typedef typename _Alloc::size_type size_type;
  typedef __gnu_pbds::hash_load_check_resize_trigger<External_Access,
                                                     size_type> base_type;
  ;
  enum
  {
    get_set_loads = External_Access,
    get_set_load = false
  };
};
template <typename _Alloc, typename _Alloc::size_type Load_Nom,
          typename _Alloc::size_type Load_Denom, bool External_Access>
struct cc_hash_max_collision_check_resize_trigger_t_
    : public __gnu_pbds::
          cc_hash_max_collision_check_resize_trigger<External_Access,
                                                     typename _Alloc::
                                                         size_type>
{
  typedef typename _Alloc::size_type size_type;
  typedef __gnu_pbds::
      cc_hash_max_collision_check_resize_trigger<External_Access, size_type>
          base_type;
  ;
  enum
  {
    get_set_load = External_Access,
    get_set_loads = false
  };
};
struct hash_prime_size_policy_t_ : public __gnu_pbds::hash_prime_size_policy
{
};
template <typename _Alloc>
struct hash_exponential_size_policy_t_
    : public __gnu_pbds::hash_exponential_size_policy<
          typename _Alloc::size_type>
{
};
template <typename Key, typename _Alloc>
struct linear_probe_fn_t_
    : public __gnu_pbds::linear_probe_fn<typename _Alloc::size_type>
{
};
template <typename Key, typename _Alloc>
struct quadratic_probe_fn_t_
    : public __gnu_pbds::quadratic_probe_fn<typename _Alloc::size_type>
{
};
template <typename _Alloc, typename _Alloc::size_type Max_Count>
struct lu_counter_policy_t_
    : public __gnu_pbds::lu_counter_policy<Max_Count, _Alloc>
{
  typedef __gnu_pbds::lu_counter_policy<Max_Count, _Alloc> base_type;
};
struct lu_move_to_front_policy_t_
    : public __gnu_pbds::lu_move_to_front_policy<>
{
};
}
namespace test
{
namespace detail
{
template <typename Cntnr, class Tag> struct ds_string_form;
template <typename Cntnr> struct ds_string_form<Cntnr, __gnu_pbds::cc_hash_tag>
{
  ;
};
template <typename Cntnr> struct ds_string_form<Cntnr, __gnu_pbds::gp_hash_tag>
{
};
template <typename Cntnr> struct tree_ds_string_form
{
  static std::string
  name (const std::string container_category_str)
  {
    if (tree_supports_order_statistics<Cntnr>::value)
      return (container_category_str + "ost_");
    return container_category_str;
  }
  static std::string
  desc (const std::string container_category_str)
  {
    const std::string category_str
        = make_xml_tag ("Tag", "value", container_category_str);
    const std::string node_update_str = make_xml_tag (
        "Node_Update", "value", (tree_supports_order_statistics<Cntnr>::value
                                     ? "tree_order_statistics_node_update"
                                     : "null_node_update"));
    return make_xml_tag ("type", "value", "tree",
                         category_str + node_update_str);
  }
};
template <typename Cntnr>
struct ds_string_form<Cntnr, __gnu_pbds::rb_tree_tag>
    : private tree_ds_string_form<Cntnr>
{
private:
  typedef tree_ds_string_form<Cntnr> base_type;
public:
  static std::string
  name ()
  {
    return base_type::name ("rb_tree_");
  }
  static std::string
  desc ()
  {
    return base_type::desc ("rb_tree_tag");
  }
};
template <typename Cntnr>
struct ds_string_form<Cntnr, __gnu_pbds::splay_tree_tag>
    : private tree_ds_string_form<Cntnr>
{
private:
  typedef tree_ds_string_form<Cntnr> base_type;
public:
  static std::string
  name ()
  {
    return base_type::name ("splay_tree_");
  }
  static std::string
  desc ()
  {
    return base_type::desc ("splay_tree_tag");
  }
};
template <typename Cntnr>
struct ds_string_form<Cntnr, __gnu_pbds::ov_tree_tag>
    : private tree_ds_string_form<Cntnr>
{
private:
  typedef tree_ds_string_form<Cntnr> base_type;
public:
  static std::string
  name ()
  {
    return (base_type::name ("ov_tree_"));
  }
  static std::string
  desc ()
  {
    return (base_type::desc ("ov_tree_tag"));
  }
};
template <typename Cntnr>
struct ds_string_form<Cntnr, __gnu_pbds::list_update_tag>
{
};
template <typename Cntnr>
struct ds_string_form<Cntnr, __gnu_pbds::pat_trie_tag>
{
};
}
}
namespace test
{
namespace detail
{
template <typename Cntnr> struct pb_ds_string_form
{
private:
  typedef typename Cntnr::mapped_type mapped_type;
  struct mapped_string_form
  {
  private:
    template <typename D_Cntnr> static std::string name (D_Cntnr)
    {
      return ("mmap_" + pb_ds_string_form<D_Cntnr>::name ());
    }
    template <typename D_Cntnr> static std::string desc (D_Cntnr)
    {
      return pb_ds_string_form<D_Cntnr>::desc ();
    }
    static std::string name (basic_type) { return ("map"); }
    static std::string desc (basic_type) { return (""); }
  public:
    static std::string
    name ()
    {
      return name (mapped_type ());
    }
    static std::string
    desc ()
    {
      return desc (mapped_type ());
    }
  };
  typedef detail::ds_string_form<Cntnr, typename Cntnr::container_category>
      ds_string_form_t;
public:
  static std::string
  name ()
  {
    return (ds_string_form_t::name () + mapped_string_form::name ());
  }
  static std::string
  desc ()
  {
    return (ds_string_form_t::desc () + mapped_string_form::desc ());
  }
};
template <typename Cntnr> struct native_string_form
{
};
template <typename Cntnr, class Tag>
struct tag_select_string_form : public pb_ds_string_form<Cntnr>
{
};
template <typename Cntnr>
struct tag_select_string_form<Cntnr, native_hash_tag>
    : public native_string_form<Cntnr>
{
};
template <typename Cntnr>
struct tag_select_string_form<Cntnr, native_tree_tag>
    : public native_string_form<Cntnr>
{
};
}
template <typename Cntnr>
struct string_form
    : public detail::tag_select_string_form<Cntnr,
                                            typename Cntnr::container_category>
{
};
}
namespace test
{
struct xml_test_formatter
{
  xml_test_formatter ()
  {
  }
  virtual ~xml_test_formatter () { }
};
struct xml_result_set_formatter
{
  xml_result_set_formatter (const std::string &name, const std::string &desc)
  {
  }
  virtual ~xml_result_set_formatter ()
  {
  }
};
}
namespace test
{
struct xml_test_rand_regression_formatter : public xml_test_formatter
{
  xml_test_rand_regression_formatter (size_t sd, size_t n, size_t m, double tp,
                                      double ip, double ep, double cp,
                                      double mp)
  {
  }
};
struct xml_result_set_regression_formatter : public xml_result_set_formatter
{
  xml_result_set_regression_formatter (const std::string &r_container_name,
                                       const std::string &r_container_desc)
      : xml_result_set_formatter (r_container_name, r_container_desc)
  {
  }
  ~xml_result_set_regression_formatter ()
  {
  }
};
}
namespace test
{
namespace detail
{
template <typename Cntnr> class container_rand_regression_test
{
public:
  container_rand_regression_test (unsigned long, size_t, size_t, double,
                                  double, double, double, double, bool);
  virtual ~container_rand_regression_test ();
  void operator()();
private:
  typedef Cntnr cntnr;
  typedef typename cntnr::allocator_type allocator_type;
  typedef typename cntnr::size_type size_type;
  typedef regression_test_traits<Cntnr> test_traits;
  typedef typename test_traits::key_type key_type;
  typedef typename test_traits::key_const_reference key_const_reference;
  typedef typename test_traits::value_type value_type;
  typedef typename test_traits::native_type native_type;
  typedef twister_rand_gen gen;
  typedef __gnu_pbds::container_traits<Cntnr> container_traits;
  typedef __gnu_cxx::throw_allocator_random<char> alloc_t;
  enum op
  {
    insert_op,
    erase_op,
    clear_op,
    other_op
  };
  op get_next_op ();
  size_t get_next_sub_op (size_t);
  static void defs ();
  static void key_defs ();
  static void mapped_defs ();
  static void value_defs ();
  ;
  static void iterator_defs ();
  static void node_iterator_defs (__gnu_pbds::detail::false_type);
  static void node_iterator_defs (__gnu_pbds::detail::true_type);
  static void policy_defs ();
  ;
  ;
  ;
  static void policy_defs (__gnu_pbds::tree_tag);
  ;
  ;
  void policy_access ();
  ;
  ;
  ;
  void policy_access (__gnu_pbds::tree_tag);
  ;
  ;
  void it_copy ();
  void it_assign ();
  void rev_it_copy ();
  void rev_it_assign ();
  void rev_it_copy_imp (__gnu_pbds::detail::false_type);
  void rev_it_copy_imp (__gnu_pbds::detail::true_type);
  void rev_it_assign_imp (__gnu_pbds::detail::false_type);
  void rev_it_assign_imp (__gnu_pbds::detail::true_type);
  bool default_constructor ();
  void swap ();
  bool copy_constructor ();
  bool assignment_operator ();
  bool it_constructor ();
  ;
  ;
  bool it_constructor_imp (__gnu_pbds::tree_tag);
  ;
  ;
  bool insert ();
  bool erase ();
  bool erase_it ();
  ;
  bool erase_it_imp (__gnu_pbds::detail::true_type);
  bool erase_rev_it ();
  bool erase_rev_it_imp (__gnu_pbds::detail::false_type);
  bool erase_rev_it_imp (__gnu_pbds::detail::true_type);
  bool erase_if ();
  bool clear ();
  bool resize ();
  ;
  bool resize_imp (__gnu_pbds::detail::false_type);
  bool get_set_loads ();
  ;
  bool get_set_loads_imp (__gnu_pbds::detail::false_type);
  void get_set_load ();
  ;
  void get_set_load_imp (__gnu_pbds::detail::false_type);
  bool subscript ();
  bool subscript_imp (__gnu_pbds::detail::false_type);
  ;
  bool split_join ();
  ;
  bool split_join_imp (__gnu_pbds::detail::true_type);
  void cmp (const Cntnr &, const native_type &, const std::string &);
  void basic_cmp_ (const Cntnr &, const native_type &);
  void cmp_ (const Cntnr &, const native_type &);
  ;
  void order_preserving_cmp_imp (const Cntnr &, const native_type &,
                                 __gnu_pbds::detail::true_type);
  ;
  void back_order_preserving_cmp_imp (const Cntnr &, const native_type &,
                                      __gnu_pbds::detail::true_type);
  void reverse_iteration_cmp_imp (const Cntnr &, const native_type &,
                                  __gnu_pbds::detail::false_type);
  void reverse_iteration_cmp_imp (const Cntnr &, const native_type &,
                                  __gnu_pbds::detail::true_type);
  void order_statistics_cmp_imp (const Cntnr &, const native_type &,
                                 __gnu_pbds::detail::false_type);
  void order_statistics_cmp_imp (const Cntnr &, const native_type &,
                                 __gnu_pbds::detail::true_type);
  void prefix_search_cmp_imp (const Cntnr &, const native_type &,
                              __gnu_pbds::detail::false_type);
  ;
  template <typename Const_It, class Const_Native_It>
  void it_cmp_imp (Const_It, Const_It, Const_Native_It, Const_Native_It);
  template <typename Const_It, class Const_Native_It>
  void back_it_cmp_imp (Const_It, Const_It, Const_Native_It, Const_Native_It);
  ;
  void lower_bound_cmp_imp (const Cntnr &, const native_type &,
                            __gnu_pbds::detail::true_type);
  ;
  void upper_bound_cmp_imp (const Cntnr &, const native_type &,
                            __gnu_pbds::detail::true_type);
  void print_container (const native_type &,
                        std::ostream &r_os = std::cerr) const;
  void print_container (const cntnr &, std::ostream &r_os = std::cerr) const;
  struct destructor_printer
  {
    destructor_printer (const std::string &r_msg)
        : m_msg (r_msg), m_print (true)
    {
    }
    void
    cancel_print ()
    {
      m_print = false;
    }
    ~destructor_printer ()
    {
      if (!m_print)
        return;
      std::cerr << std::endl << "Uncaught exception: " << std::endl << m_msg
                << std::endl;
    }
  private:
    const std::string m_msg;
    bool m_print;
  };
  const unsigned long m_seed;
  const size_t m_n;
  const size_t m_m;
  const double m_tp;
  const double m_ip;
  const double m_ep;
  const double m_cp;
  const double m_mp;
  const bool m_disp;
  twister_rand_gen m_g;
  Cntnr *m_p_c;
  native_type m_native_c;
  alloc_t m_alloc;
  size_t m_i;
};
template <typename Cntnr>
container_rand_regression_test<Cntnr>::container_rand_regression_test (
    unsigned long seed, size_t n, size_t m, double tp, double ip, double ep,
    double cp, double mp, bool disp)
    : m_seed ((seed == 0) ? twister_rand_gen::get_time_determined_seed ()
                          : seed),
      m_n (n), m_m (m), m_tp (tp), m_ip (ip), m_ep (ep), m_cp (cp), m_mp (mp),
      m_disp (disp), m_p_c (0)
{
}
template <typename Cntnr>
container_rand_regression_test<Cntnr>::~container_rand_regression_test ()
{
}
template <typename Cntnr>
bool
container_rand_regression_test<Cntnr>::default_constructor ()
{
  ;
  bool done = true;
  m_alloc.set_probability (m_tp);
  try
    {
      m_p_c = new Cntnr;
    }
  catch (__gnu_cxx::forced_error &)
    {
      done = false;
    }
  if (m_p_c)
    if (m_g.get_prob () < m_mp)
      cmp (*m_p_c, m_native_c, __FUNCTION__);
  ;
  return done;
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::swap ()
{
  ;
  m_alloc.set_probability (0);
  Cntnr *p_c = new Cntnr;
  m_alloc.set_probability (1);
  p_c->swap (*m_p_c);
  std::swap (p_c, m_p_c);
  delete p_c;
  if (m_g.get_prob () < m_mp)
    cmp (*m_p_c, m_native_c, __FUNCTION__);
  ;
}
template <typename Cntnr>
bool
container_rand_regression_test<Cntnr>::copy_constructor ()
{
  ;
  bool done = true;
  Cntnr *p_c = 0;
  m_alloc.set_probability (m_tp);
  typename alloc_t::group_adjustor adjust (m_p_c->size ());
  try
    {
      p_c = new Cntnr (*m_p_c);
      std::swap (p_c, m_p_c);
    }
  catch (__gnu_cxx::forced_error &)
    {
      done = false;
    }
  delete p_c;
  if (m_g.get_prob () < m_mp)
    cmp (*m_p_c, m_native_c, __FUNCTION__);
  ;
  return done;
}
template <typename Cntnr>
bool
container_rand_regression_test<Cntnr>::assignment_operator ()
{
  ;
  bool done = true;
  Cntnr *p_c = 0;
  m_alloc.set_probability (m_tp);
  typename alloc_t::group_adjustor adjust (m_p_c->size ());
  try
    {
      p_c = new Cntnr ();
      *p_c = *m_p_c;
      std::swap (p_c, m_p_c);
    }
  catch (__gnu_cxx::forced_error &)
    {
      done = false;
    }
  delete p_c;
  if (m_g.get_prob () < m_mp)
    cmp (*m_p_c, m_native_c, __FUNCTION__);
  ;
  return done;
}
template <typename Cntnr>
bool
container_rand_regression_test<Cntnr>::it_constructor ()
{
  ;
  return it_constructor_imp (typename Cntnr::container_category ());
}
template <typename Cntnr>
bool container_rand_regression_test<Cntnr>::it_constructor_imp (
    __gnu_pbds::tree_tag)
{
  bool done = true;
  Cntnr *p_c = 0;
  m_alloc.set_probability (m_tp);
  typename alloc_t::group_adjustor adjust (m_p_c->size ());
  try
    {
      switch (get_next_sub_op (2))
        {
        case 0:
          p_c = new Cntnr (m_p_c->get_cmp_fn ());
          m_native_c.clear ();
          break;
        case 1:
          p_c = new Cntnr (m_p_c->begin (), m_p_c->end (),
                           m_p_c->get_cmp_fn ());
          break;
        default:
          if (!(false))
            {
              std::cerr << "Failure at "
                        << "/home/marxin/Programming/gcc/libstdc++-v3/"
                           "testsuite/util/regression/rand/assoc/"
                           "container_rand_regression_test.tcc"
                        << ": " << 328 << std::endl;
              std::cerr << "" << std::endl;
              std::cerr << "container:" << std::endl;
              print_container (*(m_p_c));
              std::cerr << std::endl;
              std::cerr << "native container:" << std::endl;
              print_container (*(&m_native_c));
              std::cerr << std::endl;
              throw std::logic_error ("fucked!");
            };
        };
      std::swap (p_c, m_p_c);
    }
  catch (__gnu_cxx::forced_error &)
    {
      done = false;
    }
  delete p_c;
  if (m_g.get_prob () < m_mp)
    cmp (*m_p_c, m_native_c, __FUNCTION__);
  ;
  return done;
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::cmp (const Cntnr &r_c,
                                            const native_type &r_native_c,
                                            const std::string &r_call_fn)
{
  m_alloc.set_probability (1);
  const size_t size = r_c.size ();
  const size_t native_size = r_native_c.size ();
  if (!(size == native_size))
    {
      std::cerr << "Failure at "
                << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/util/"
                   "regression/rand/assoc/container_rand_regression_test.tcc"
                << ": " << 415 << std::endl;
      std::cerr << size << " " << native_size << std::endl;
      std::cerr << "container:" << std::endl;
      print_container (*(&r_c));
      std::cerr << std::endl;
      std::cerr << "native container:" << std::endl;
      print_container (*(&r_native_c));
      std::cerr << std::endl;
      throw std::logic_error ("fucked!");
    };
  const bool empty = r_c.empty ();
  const bool native_empty = r_native_c.empty ();
  if (!(empty == native_empty))
    {
      std::cerr << "Failure at "
                << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/util/"
                   "regression/rand/assoc/container_rand_regression_test.tcc"
                << ": " << 420 << std::endl;
      std::cerr << empty << " " << native_empty << std::endl;
      std::cerr << "container:" << std::endl;
      print_container (*(&r_c));
      std::cerr << std::endl;
      std::cerr << "native container:" << std::endl;
      print_container (*(&r_native_c));
      std::cerr << std::endl;
      throw std::logic_error ("fucked!");
    };
  try
    {
      basic_cmp_ (r_c, r_native_c);
      cmp_ (r_c, r_native_c);
    }
  catch (...)
    {
      if (!(false))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 430 << std::endl;
          std::cerr << "call-fn: " + r_call_fn << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(&r_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&r_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
    }
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::basic_cmp_ (
    const Cntnr &r_c, const native_type &r_native_c)
{
  destructor_printer dest_print___ (__FUNCTION__);
  if (static_cast<size_t> (std::distance (r_c.begin (), r_c.end ()))
      != r_c.size ())
    if (!(false))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 442 << std::endl;
        std::cerr << static_cast<unsigned long> (
                         std::distance (r_c.begin (), r_c.end ())) << " "
                  << static_cast<unsigned long> (r_c.size ()) << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(&r_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&r_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
  typename native_type::const_iterator it = r_native_c.begin ();
  while (it != r_native_c.end ())
    {
      typename native_type::key_type native_key
          = test_traits::extract_native_key (*it);
      m_alloc.set_probability (0);
      const key_type k = native_key;
      m_alloc.set_probability (1);
      typename cntnr::point_const_iterator found_it = r_c.find (k);
      if (!(found_it != r_c.end ()))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 457 << std::endl;
          std::cerr << test_traits::native_val_to_string (*it) << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(&r_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&r_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
      if (!test_traits::cmp (*found_it, *it))
        if (!(false))
          {
            std::cerr << "Failure at "
                      << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                         "util/regression/rand/assoc/"
                         "container_rand_regression_test.tcc"
                      << ": " << 462 << std::endl;
            std::cerr << "" << std::endl;
            std::cerr << "container:" << std::endl;
            print_container (*(&r_c));
            std::cerr << std::endl;
            std::cerr << "native container:" << std::endl;
            print_container (*(&r_native_c));
            std::cerr << std::endl;
            throw std::logic_error ("fucked!");
          };
      ++it;
    }
  dest_print___.cancel_print ();
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::cmp_ (const Cntnr &r_c,
                                             const native_type &r_native_c)
{
  enum
  {
    order_preserving = container_traits::order_preserving,
    back_order_preserving
    = container_traits::order_preserving
      && !__gnu_pbds::detail::is_same<
             typename std::iterator_traits<
                 typename cntnr::const_iterator>::iterator_category,
             std::forward_iterator_tag>::value,
    reverse_iteration = container_traits::reverse_iteration,
    order_statistics = test_traits::order_statistics,
    prefix_search = test_traits::prefix_search,
    has_mapped = !__gnu_pbds::detail::is_same<typename Cntnr::mapped_type,
                                              __gnu_pbds::null_type>::value
  };
  order_preserving_cmp_imp (
      r_c, r_native_c,
      __gnu_pbds::detail::integral_constant<int, order_preserving> ());
  back_order_preserving_cmp_imp (
      r_c, r_native_c,
      __gnu_pbds::detail::integral_constant<int, back_order_preserving> ());
  order_statistics_cmp_imp (
      r_c, r_native_c,
      __gnu_pbds::detail::integral_constant<int, order_statistics> ());
  prefix_search_cmp_imp (
      r_c, r_native_c,
      __gnu_pbds::detail::integral_constant<int, prefix_search> ());
  reverse_iteration_cmp_imp (
      r_c, r_native_c,
      __gnu_pbds::detail::integral_constant<int, reverse_iteration> ());
  lower_bound_cmp_imp (
      r_c, r_native_c,
      __gnu_pbds::detail::integral_constant<int, order_preserving> ());
  upper_bound_cmp_imp (
      r_c, r_native_c,
      __gnu_pbds::detail::integral_constant<int, order_preserving> ());
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::order_preserving_cmp_imp (
    const Cntnr &r_c, const native_type &r_native_c,
    __gnu_pbds::detail::true_type)
{
  destructor_printer dest_print___ (__FUNCTION__);
  typename cntnr::const_iterator b = r_c.begin ();
  typename cntnr::const_iterator e = r_c.end ();
  typename native_type::const_iterator native_b = r_native_c.begin ();
  typename native_type::const_iterator native_e = r_native_c.end ();
  try
    {
      it_cmp_imp (b, e, native_b, native_e);
    }
  catch (...)
    {
      if (!(false))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 538 << std::endl;
          std::cerr << "" << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(&r_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&r_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        }
    }
  try
    {
      back_it_cmp_imp (b, e, native_b, native_e);
    }
  catch (...)
    {
      if (!(false))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 547 << std::endl;
          std::cerr << "" << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(&r_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&r_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        }
    }
  dest_print___.cancel_print ();
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::back_order_preserving_cmp_imp (
    const Cntnr &r_c, const native_type &r_native_c,
    __gnu_pbds::detail::true_type)
{
  destructor_printer dest_print___ (__FUNCTION__);
  typename cntnr::const_iterator b = r_c.begin ();
  typename cntnr::const_iterator e = r_c.end ();
  typename native_type::const_iterator native_b = r_native_c.begin ();
  typename native_type::const_iterator native_e = r_native_c.end ();
  it_cmp_imp (b, e, native_b, native_e);
  dest_print___.cancel_print ();
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::reverse_iteration_cmp_imp (
    const Cntnr &, const native_type &, __gnu_pbds::detail::false_type)
{
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::reverse_iteration_cmp_imp (
    const Cntnr &r_c, const native_type &r_native_c,
    __gnu_pbds::detail::true_type)
{
  destructor_printer dest_print___ (__FUNCTION__);
  typename cntnr::const_reverse_iterator b = r_c.rbegin ();
  typename cntnr::const_reverse_iterator e = r_c.rend ();
  typename native_type::const_reverse_iterator native_b = r_native_c.rbegin ();
  typename native_type::const_reverse_iterator native_e = r_native_c.rend ();
  try
    {
      it_cmp_imp (b, e, native_b, native_e);
    }
  catch (...)
    {
      if (!(false))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 601 << std::endl;
          std::cerr << "" << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(&r_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&r_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        }
    }
  try
    {
      back_it_cmp_imp (b, e, native_b, native_e);
    }
  catch (...)
    {
      if (!(false))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 610 << std::endl;
          std::cerr << "" << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(&r_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&r_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        }
    }
  dest_print___.cancel_print ();
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::order_statistics_cmp_imp (
    const Cntnr &, const native_type &, __gnu_pbds::detail::false_type)
{
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::order_statistics_cmp_imp (
    const Cntnr &r_c, const native_type &r_native_c,
    __gnu_pbds::detail::true_type)
{
  {
    m_alloc.set_probability (0);
    const key_type k = test_traits::generate_key (m_g, m_m);
    m_alloc.set_probability (1);
    const size_type order = r_c.order_of_key (k);
    const size_type native_order
        = std::distance (r_native_c.begin (),
                         r_native_c.lower_bound (test_traits::native_key (k)));
    if (!(order == native_order))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 635 << std::endl;
        std::cerr << test_traits::key_to_string (k) << " "
                  << static_cast<unsigned long> (order) << " "
                  << static_cast<unsigned long> (native_order) << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(&r_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&r_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
  }
  const size_type rand_ord = static_cast<size_t> (
      m_g.get_unsigned_long (0, 2 * static_cast<unsigned long> (m_m)));
  typename cntnr::const_iterator it = r_c.find_by_order (rand_ord);
  typename native_type::const_iterator native_it = r_native_c.begin ();
  std::advance (native_it, std::min (rand_ord, r_native_c.size ()));
  if (it == r_c.end () && native_it != r_native_c.end ())
    if (!(false))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 651 << std::endl;
        std::cerr << static_cast<unsigned long> (rand_ord) << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
  if (it != r_c.end () && native_it == r_native_c.end ())
    if (!(false))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 657 << std::endl;
        std::cerr << static_cast<unsigned long> (rand_ord) << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
  if (it != r_c.end () && native_it != r_native_c.end ())
    if (!(test_traits::cmp (*it, *native_it)))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 663 << std::endl;
        std::cerr << static_cast<unsigned long> (rand_ord) << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::prefix_search_cmp_imp (
    const Cntnr &, const native_type &, __gnu_pbds::detail::false_type)
{
}
template <typename Cntnr>
template <typename Const_It, class Const_Native_It>
void
container_rand_regression_test<Cntnr>::it_cmp_imp (Const_It b, Const_It e,
                                                   Const_Native_It native_b,
                                                   Const_Native_It native_e)
{
  destructor_printer dest_print___ (__FUNCTION__);
  if (std::distance (b, e) != std::distance (native_b, native_e))
    {
      const size_t dist = std::distance (b, e);
      const size_t native_dist = std::distance (native_b, native_e);
      if (!(false))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 735 << std::endl;
          std::cerr << static_cast<unsigned long> (dist) << " "
                    << static_cast<unsigned long> (native_dist) << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
    }
  while (b != e)
    {
      if (!(native_b != native_e))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 743 << std::endl;
          std::cerr << "" << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
      if (!test_traits::cmp (*b, *native_b))
        if (!(false))
          {
            std::cerr << "Failure at "
                      << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                         "util/regression/rand/assoc/"
                         "container_rand_regression_test.tcc"
                      << ": " << 746 << std::endl;
            std::cerr << test_traits::val_to_string (*b) << " "
                      << test_traits::val_to_string (*native_b) << std::endl;
            std::cerr << "container:" << std::endl;
            print_container (*(m_p_c));
            std::cerr << std::endl;
            std::cerr << "native container:" << std::endl;
            print_container (*(&m_native_c));
            std::cerr << std::endl;
            throw std::logic_error ("fucked!");
          };
      ++b;
      ++native_b;
    }
  if (!(native_b == native_e))
    {
      std::cerr << "Failure at "
                << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/util/"
                   "regression/rand/assoc/container_rand_regression_test.tcc"
                << ": " << 755 << std::endl;
      std::cerr << "" << std::endl;
      std::cerr << "container:" << std::endl;
      print_container (*(m_p_c));
      std::cerr << std::endl;
      std::cerr << "native container:" << std::endl;
      print_container (*(&m_native_c));
      std::cerr << std::endl;
      throw std::logic_error ("fucked!");
    };
  dest_print___.cancel_print ();
}
template <typename Cntnr>
template <typename Const_It, class Const_Native_It>
void
container_rand_regression_test<Cntnr>::back_it_cmp_imp (
    Const_It b, Const_It e, Const_Native_It native_b, Const_Native_It native_e)
{
  destructor_printer dest_print___ (__FUNCTION__);
  while (b != e)
    {
      if (!(native_b != native_e))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 769 << std::endl;
          std::cerr << test_traits::val_to_string (*native_e) << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
      --e;
      --native_e;
      if (!(test_traits::cmp (*e, *native_e)))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 776 << std::endl;
          std::cerr << test_traits::val_to_string (*e)
                    << test_traits::val_to_string (*native_e) << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
    }
  if (!(native_b == native_e))
    {
      std::cerr << "Failure at "
                << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/util/"
                   "regression/rand/assoc/container_rand_regression_test.tcc"
                << ": " << 782 << std::endl;
      std::cerr << test_traits::val_to_string (*native_e) << std::endl;
      std::cerr << "container:" << std::endl;
      print_container (*(m_p_c));
      std::cerr << std::endl;
      std::cerr << "native container:" << std::endl;
      print_container (*(&m_native_c));
      std::cerr << std::endl;
      throw std::logic_error ("fucked!");
    };
  dest_print___.cancel_print ();
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::lower_bound_cmp_imp (
    const Cntnr &r_c, const native_type &r_native_c,
    __gnu_pbds::detail::true_type)
{
  destructor_printer dest_print___ (__FUNCTION__);
  m_alloc.set_probability (0);
  const key_type k = test_traits::generate_key (m_g, m_m);
  m_alloc.set_probability (1);
  typename cntnr::const_iterator it = r_c.lower_bound (k);
  typename native_type::key_type native_k = test_traits::native_key (k);
  typename native_type::const_iterator native_it
      = r_native_c.lower_bound (native_k);
  if (it != r_c.end () && native_it == r_native_c.end ())
    if (!(""))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 809 << std::endl;
        std::cerr << "it: " + test_traits::val_to_string (*it) + "\n\n"
                  << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(&r_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&r_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
  if (it == r_c.end () && native_it != r_native_c.end ())
    if (!(""))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 814 << std::endl;
        std::cerr << "native_it: " + test_traits::val_to_string (*native_it)
                     + "\n\n" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(&r_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&r_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
  if (it != r_c.end () && !test_traits::cmp (*it, *native_it))
    if (!(false))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 819 << std::endl;
        std::cerr << "key: " + test_traits::key_to_string (k) + "\n\n" + "it: "
                     + test_traits::val_to_string (*it) + "\n\n"
                     + "native_it: " + test_traits::val_to_string (*native_it)
                     + "\n\n" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(&r_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&r_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
  dest_print___.cancel_print ();
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::upper_bound_cmp_imp (
    const Cntnr &r_c, const native_type &r_native_c,
    __gnu_pbds::detail::true_type)
{
  destructor_printer dest_print___ (__FUNCTION__);
  m_alloc.set_probability (0);
  const key_type k = test_traits::generate_key (m_g, m_m);
  m_alloc.set_probability (1);
  typename cntnr::const_iterator it = r_c.upper_bound (k);
  typename native_type::key_type native_k = test_traits::native_key (k);
  typename native_type::const_iterator native_it
      = r_native_c.upper_bound (native_k);
  if (it == r_c.end () && native_it != r_native_c.end ())
    if (!(false))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 848 << std::endl;
        std::cerr << "key: " + test_traits::key_to_string (k) + "\n\n"
                     + "native_it: " + test_traits::val_to_string (*native_it)
                     + "\n\n" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(&r_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&r_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
  if (it != r_c.end () && native_it == r_native_c.end ())
    if (!(false))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 854 << std::endl;
        std::cerr << "key: " + test_traits::key_to_string (k) + "\n\n" + "it: "
                     + test_traits::val_to_string (*it) + "\n\n" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(&r_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&r_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
  if (it != r_c.end () && !test_traits::cmp (*it, *native_it))
    if (!(false))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 860 << std::endl;
        std::cerr << "key: " + test_traits::key_to_string (k) + "\n\n" + "it: "
                     + test_traits::val_to_string (*it) + "\n\n"
                     + "native_it: " + test_traits::val_to_string (*native_it)
                     + "\n\n" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(&r_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&r_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
  dest_print___.cancel_print ();
}
template <typename Cntnr>
void container_rand_regression_test<Cntnr>::operator()()
{
  typedef xml_result_set_regression_formatter formatter_type;
  formatter_type *p_fmt = 0;
  if (m_disp)
    p_fmt = new formatter_type (string_form<Cntnr>::name (),
                                string_form<Cntnr>::desc ());
  m_g.init (m_seed);
  const size_t memory_label = 775;
  m_alloc.seed (m_seed);
  m_alloc.set_label (memory_label);
  prog_bar pb ();
  m_i = 0;
  try
    {
      for (m_i = 0; m_i < m_n; ++m_i)
        {
          ;
          allocator_type::set_label (m_i);
          switch (m_i)
            {
            case 0:
              {
                bool done = false;
                while (!done)
                  done = default_constructor ();
              };
              break;
            case 1:
              defs ();
              break;
            case 2:
              policy_access ();
              break;
            case 3:
              it_copy ();
              break;
            case 4:
              it_assign ();
              break;
            case 5:
              rev_it_copy ();
              break;
            case 6:
              rev_it_assign ();
              break;
            default:
              switch (get_next_op ())
                {
                case insert_op:
                  switch (get_next_sub_op (2))
                    {
                    case 0:
                      {
                        bool done = false;
                        while (!done)
                          done = insert ();
                      }
                      break;
                    case 1:
                      {
                        bool done = false;
                        while (!done)
                          done = subscript ();
                      }
                      break;
                    default:
                      if (!(false))
                        {
                          std::cerr
                              << "Failure at "
                              << "/home/marxin/Programming/gcc/libstdc++-v3/"
                                 "testsuite/util/regression/rand/assoc/"
                                 "container_rand_regression_test.tcc"
                              << ": " << 934 << std::endl;
                          std::cerr << "" << std::endl;
                          std::cerr << "container:" << std::endl;
                          print_container (*(m_p_c));
                          std::cerr << std::endl;
                          std::cerr << "native container:" << std::endl;
                          print_container (*(&m_native_c));
                          std::cerr << std::endl;
                          throw std::logic_error ("fucked!");
                        };
                    }
                  break;
                case erase_op:
                  switch (get_next_sub_op (4))
                    {
                    case 0:
                      {
                        bool done = false;
                        while (!done)
                          done = erase ();
                      }
                      break;
                    case 1:
                      {
                        bool done = false;
                        while (!done)
                          done = erase_if ();
                      }
                      break;
                    case 2:
                      {
                        bool done = false;
                        while (!done)
                          done = erase_it ();
                      }
                      break;
                    case 3:
                      {
                        bool done = false;
                        while (!done)
                          done = erase_rev_it ();
                      }
                      break;
                    default:
                      if (!(false))
                        {
                          std::cerr
                              << "Failure at "
                              << "/home/marxin/Programming/gcc/libstdc++-v3/"
                                 "testsuite/util/regression/rand/assoc/"
                                 "container_rand_regression_test.tcc"
                              << ": " << 953 << std::endl;
                          std::cerr << "" << std::endl;
                          std::cerr << "container:" << std::endl;
                          print_container (*(m_p_c));
                          std::cerr << std::endl;
                          std::cerr << "native container:" << std::endl;
                          print_container (*(&m_native_c));
                          std::cerr << std::endl;
                          throw std::logic_error ("fucked!");
                        };
                    }
                  break;
                case clear_op:
                  {
                    bool done = false;
                    while (!done)
                      done = clear ();
                  }
                  break;
                case other_op:
                  switch (get_next_sub_op (8))
                    {
                    case 0:
                      swap ();
                      break;
                    case 1:
                      {
                        bool done = false;
                        while (!done)
                          done = copy_constructor ();
                      }
                      break;
                    case 2:
                      {
                        bool done = false;
                        while (!done)
                          done = it_constructor ();
                      }
                      break;
                    case 3:
                      {
                        bool done = false;
                        while (!done)
                          done = assignment_operator ();
                      }
                      break;
                    case 4:
                      {
                        bool done = false;
                        while (!done)
                          done = split_join ();
                      }
                      break;
                    case 5:
                      resize ();
                      break;
                    case 6:
                      get_set_load ();
                      break;
                    case 7:
                      get_set_loads ();
                      break;
                    default:
                      if (!(false))
                        {
                          std::cerr
                              << "Failure at "
                              << "/home/marxin/Programming/gcc/libstdc++-v3/"
                                 "testsuite/util/regression/rand/assoc/"
                                 "container_rand_regression_test.tcc"
                              << ": " << 987 << std::endl;
                          std::cerr << "" << std::endl;
                          std::cerr << "container:" << std::endl;
                          print_container (*(m_p_c));
                          std::cerr << std::endl;
                          std::cerr << "native container:" << std::endl;
                          print_container (*(&m_native_c));
                          std::cerr << std::endl;
                          throw std::logic_error ("fucked!");
                        };
                    }
                  break;
                default:
                  if (!(false))
                    {
                      std::cerr << "Failure at "
                                << "/home/marxin/Programming/gcc/libstdc++-v3/"
                                   "testsuite/util/regression/rand/assoc/"
                                   "container_rand_regression_test.tcc"
                                << ": " << 991 << std::endl;
                      std::cerr << "" << std::endl;
                      std::cerr << "container:" << std::endl;
                      print_container (*(m_p_c));
                      std::cerr << std::endl;
                      std::cerr << "native container:" << std::endl;
                      print_container (*(&m_native_c));
                      std::cerr << std::endl;
                      throw std::logic_error ("fucked!");
                    };
                };
            }
        }
    }
  catch (...)
    {
      std::cerr << "Failed at index " << static_cast<unsigned long> (m_i)
                << std::endl;
      fprintf (stderr, "EXCEPTION...\n");
      throw;
    }
  delete m_p_c;
  try
    {
      m_alloc.check (memory_label);
    }
  catch (...)
    {
      std::cerr << "detected leaks!" << std::endl;
      std::cerr << m_alloc << std::endl;
      if (!(false))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 1016 << std::endl;
          std::cerr << "" << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
    }
  m_alloc.set_probability (0);
  if (m_disp)
    {
      delete p_fmt;
    }
}
template <typename Cntnr>
typename container_rand_regression_test<Cntnr>::op
container_rand_regression_test<Cntnr>::get_next_op ()
{
  const double prob = m_g.get_prob ();
  if (prob < m_ip)
    return insert_op;
  if (prob < m_ip + m_ep)
    return erase_op;
  if (prob < m_ip + m_ep + m_cp)
    return clear_op;
  if (!(prob <= 1))
    {
      std::cerr << "Failure at "
                << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/util/"
                   "regression/rand/assoc/container_rand_regression_test.tcc"
                << ": " << 1044 << std::endl;
      std::cerr << prob << std::endl;
      std::cerr << "container:" << std::endl;
      print_container (*(m_p_c));
      std::cerr << std::endl;
      std::cerr << "native container:" << std::endl;
      print_container (*(&m_native_c));
      std::cerr << std::endl;
      throw std::logic_error ("fucked!");
    };
  return other_op;
}
template <typename Cntnr>
size_t
container_rand_regression_test<Cntnr>::get_next_sub_op (size_t max)
{
  const double p = m_g.get_prob ();
  const double delta = 1 / static_cast<double> (max);
  size_t i = 0;
  while (true)
    if (p <= (i + 1) * delta)
      {
        if (!(i < max))
          {
            std::cerr << "Failure at "
                      << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                         "util/regression/rand/assoc/"
                         "container_rand_regression_test.tcc"
                      << ": " << 1059 << std::endl;
            std::cerr << i << " " << max << std::endl;
            std::cerr << "container:" << std::endl;
            print_container (*(m_p_c));
            std::cerr << std::endl;
            std::cerr << "native container:" << std::endl;
            print_container (*(&m_native_c));
            std::cerr << std::endl;
            throw std::logic_error ("fucked!");
          };
        return i;
      }
    else
      ++i;
}
template <typename Cntnr>
bool
container_rand_regression_test<Cntnr>::insert ()
{
  ;
  bool done = true;
  destructor_printer dest_print___ (__FUNCTION__);
  try
    {
      m_alloc.set_probability (0);
      value_type v = test_traits::generate_value (m_g, m_m);
      m_alloc.set_probability (m_tp);
      key_const_reference r_k = test_traits::extract_key (v);
      typename cntnr::point_const_iterator found_it = m_p_c->find (r_k);
      const bool existed = (found_it != m_p_c->end ());
      const std::pair<typename cntnr::point_iterator, bool> ins_ret
          = m_p_c->insert (v);
      if (ins_ret.second)
        {
          if (!(!existed))
            {
              std::cerr << "Failure at "
                        << "/home/marxin/Programming/gcc/libstdc++-v3/"
                           "testsuite/util/regression/rand/assoc/"
                           "container_rand_regression_test.tcc"
                        << ": " << 1087 << std::endl;
              std::cerr << "" << std::endl;
              std::cerr << "container:" << std::endl;
              print_container (*(m_p_c));
              std::cerr << std::endl;
              std::cerr << "native container:" << std::endl;
              print_container (*(&m_native_c));
              std::cerr << std::endl;
              throw std::logic_error ("fucked!");
            };
        }
      else
        {
          if (!(existed))
            {
              std::cerr << "Failure at "
                        << "/home/marxin/Programming/gcc/libstdc++-v3/"
                           "testsuite/util/regression/rand/assoc/"
                           "container_rand_regression_test.tcc"
                        << ": " << 1091 << std::endl;
              std::cerr << "" << std::endl;
              std::cerr << "container:" << std::endl;
              print_container (*(m_p_c));
              std::cerr << std::endl;
              std::cerr << "native container:" << std::endl;
              print_container (*(&m_native_c));
              std::cerr << std::endl;
              throw std::logic_error ("fucked!");
            };
          if (!(found_it == ins_ret.first))
            {
              std::cerr << "Failure at "
                        << "/home/marxin/Programming/gcc/libstdc++-v3/"
                           "testsuite/util/regression/rand/assoc/"
                           "container_rand_regression_test.tcc"
                        << ": " << 1092 << std::endl;
              std::cerr << "" << std::endl;
              std::cerr << "container:" << std::endl;
              print_container (*(m_p_c));
              std::cerr << std::endl;
              std::cerr << "native container:" << std::endl;
              print_container (*(&m_native_c));
              std::cerr << std::endl;
              throw std::logic_error ("fucked!");
            };
        }
      m_native_c.insert (test_traits::native_value (v));
    }
  catch (__gnu_cxx::forced_error &)
    {
      done = false;
    }
  catch (__gnu_pbds::insert_error &)
    {
      if (!(false))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 1102 << std::endl;
          std::cerr << "" << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
    }
  if (m_g.get_prob () < m_mp)
    cmp (*m_p_c, m_native_c, __FUNCTION__);
  ;
  dest_print___.cancel_print ();
  return done;
}
template <typename Cntnr>
bool
container_rand_regression_test<Cntnr>::subscript ()
{
  ;
  enum
  {
    no_data
    = __gnu_pbds::detail::is_same<typename Cntnr::key_const_reference,
                                  typename Cntnr::const_reference>::value
  };
  return (
      subscript_imp (__gnu_pbds::detail::integral_constant<int, no_data> ()));
}
template <typename Cntnr>
bool container_rand_regression_test<Cntnr>::subscript_imp (
    __gnu_pbds::detail::false_type)
{
  bool done = true;
  destructor_printer dest_print___ (__FUNCTION__);
  try
    {
      m_alloc.set_probability (0);
      value_type v = test_traits::generate_value (m_g, m_m);
      m_alloc.set_probability (m_tp);
      (*m_p_c)[v.first] = v.second;
      m_native_c[test_traits::native_value (v).first]
          = test_traits::native_value (v).second;
    }
  catch (__gnu_cxx::forced_error &)
    {
      done = false;
    }
  if (m_g.get_prob () < m_mp)
    cmp (*m_p_c, m_native_c, __FUNCTION__);
  ;
  dest_print___.cancel_print ();
  return done;
}
template <typename Cntnr>
bool
container_rand_regression_test<Cntnr>::clear ()
{
  m_p_c->clear ();
  m_native_c.clear ();
  return true;
}
template <typename Cntnr>
bool
container_rand_regression_test<Cntnr>::erase ()
{
  ;
  bool done = true;
  destructor_printer dest_print___ (__FUNCTION__);
  m_alloc.set_probability (0);
  const key_type k = test_traits::generate_key (m_g, m_m);
  m_alloc.set_probability (m_tp);
  try
    {
      const bool cntnd = m_p_c->find (k) != m_p_c->end ();
      if (!(cntnd == (m_native_c.find (test_traits::native_key (k))
                      != m_native_c.end ())))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 1210 << std::endl;
          std::cerr << test_traits::key_to_string (k) << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
      const bool ersd = m_p_c->erase (k);
      const bool native_ersd = m_native_c.erase (test_traits::native_key (k))
                               != 0;
      if (!(ersd == native_ersd))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 1215 << std::endl;
          std::cerr << ersd << " " << native_ersd << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
      if (!(m_p_c->find (k) == m_p_c->end ()))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 1218 << std::endl;
          std::cerr << "" << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
    }
  catch (__gnu_cxx::forced_error &)
    {
      done = false;
      if (!(container_traits::erase_can_throw))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 1225 << std::endl;
          std::cerr << container_traits::erase_can_throw << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
    }
  if (m_g.get_prob () < m_mp)
    cmp (*m_p_c, m_native_c, __FUNCTION__);
  ;
  dest_print___.cancel_print ();
  return done;
}
template <typename Cntnr>
bool
container_rand_regression_test<Cntnr>::erase_if ()
{
  ;
  bool done = true;
  destructor_printer dest_print___ (__FUNCTION__);
  try
    {
      typedef
          typename std::iterator_traits<typename cntnr::iterator>::reference
              it_const_reference;
      typedef
          typename test_traits::template erase_if_fn<value_type> erase_if_fn_t;
      m_alloc.set_probability (m_tp);
      const size_t ersd = m_p_c->erase_if (erase_if_fn_t ());
      const size_t native_ersd = test_traits::erase_if (m_native_c);
      if (!(ersd == native_ersd))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 1256 << std::endl;
          std::cerr << ersd << " " << native_ersd << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
    }
  catch (__gnu_cxx::forced_error &)
    {
      done = false;
      if (!(container_traits::erase_can_throw))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 1262 << std::endl;
          std::cerr << container_traits::erase_can_throw << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
    }
  if (m_g.get_prob () < m_mp)
    cmp (*m_p_c, m_native_c, __FUNCTION__);
  ;
  dest_print___.cancel_print ();
  return done;
}
template <typename Cntnr>
bool
container_rand_regression_test<Cntnr>::erase_it ()
{
  enum
  {
    erase_iterators = container_traits::order_preserving
  };
  return (erase_it_imp (
      __gnu_pbds::detail::integral_constant<int, erase_iterators> ()));
}
template <typename Cntnr>
bool container_rand_regression_test<Cntnr>::erase_it_imp (
    __gnu_pbds::detail::true_type)
{
  ;
  bool done = true;
  destructor_printer dest_print___ (__FUNCTION__);
  try
    {
      m_alloc.set_probability (0);
      const key_type k = test_traits::generate_key (m_g, m_m);
      m_alloc.set_probability (m_tp);
      typename cntnr::iterator found_it = m_p_c->find (k);
      typename native_type::iterator native_it
          = m_native_c.find (test_traits::native_key (k));
      const bool found = found_it != m_p_c->end ();
      const bool native_found = native_it != m_native_c.end ();
      if (!(found == native_found))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 1315 << std::endl;
          std::cerr << found << " " << native_found << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
      typename cntnr::const_iterator next_it = found_it;
      if (next_it != m_p_c->end ())
        ++next_it;
      typename cntnr::iterator next_ers_it = m_p_c->erase (found_it);
      if (native_it != m_native_c.end ())
        m_native_c.erase (native_it);
      bool range_guarantee = __gnu_pbds::detail::is_same<
          typename container_traits::invalidation_guarantee,
          __gnu_pbds::range_invalidation_guarantee>::value;
      if (range_guarantee)
        if (!(next_ers_it == next_it))
          {
            std::cerr << "Failure at "
                      << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                         "util/regression/rand/assoc/"
                         "container_rand_regression_test.tcc"
                      << ": " << 1335 << std::endl;
            std::cerr << "" << std::endl;
            std::cerr << "container:" << std::endl;
            print_container (*(m_p_c));
            std::cerr << std::endl;
            std::cerr << "native container:" << std::endl;
            print_container (*(&m_native_c));
            std::cerr << std::endl;
            throw std::logic_error ("fucked!");
          };
    }
  catch (__gnu_cxx::forced_error &)
    {
      done = false;
      if (!(container_traits::erase_can_throw))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 1340 << std::endl;
          std::cerr << container_traits::erase_can_throw << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
    }
  if (m_g.get_prob () < m_mp)
    cmp (*m_p_c, m_native_c, __FUNCTION__);
  ;
  dest_print___.cancel_print ();
  return done;
}
template <typename Cntnr>
bool
container_rand_regression_test<Cntnr>::erase_rev_it ()
{
  enum
  {
    erase_iterators = container_traits::order_preserving
                      && container_traits::reverse_iteration
  };
  return (erase_rev_it_imp (
      __gnu_pbds::detail::integral_constant<int, erase_iterators> ()));
}
template <typename Cntnr>
bool container_rand_regression_test<Cntnr>::erase_rev_it_imp (
    __gnu_pbds::detail::false_type)
{
  return true;
}
template <typename Cntnr>
bool container_rand_regression_test<Cntnr>::erase_rev_it_imp (
    __gnu_pbds::detail::true_type)
{
  ;
  bool done = true;
  destructor_printer dest_print___ (__FUNCTION__);
  try
    {
      m_alloc.set_probability (0);
      const key_type k = test_traits::generate_key (m_g, m_m);
      m_alloc.set_probability (m_tp);
      typename cntnr::iterator found_it = m_p_c->find (k);
      typename native_type::iterator native_it
          = m_native_c.find (test_traits::native_key (k));
      typename cntnr::const_reverse_iterator next_it = found_it;
      if (next_it != m_p_c->end ())
        ++next_it;
      typename cntnr::reverse_iterator next_ers_it
          = m_p_c->erase ((typename cntnr::reverse_iterator)found_it);
      if (!(next_ers_it == next_it))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 1395 << std::endl;
          std::cerr << "" << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
      if (native_it != m_native_c.end ())
        m_native_c.erase (native_it);
    }
  catch (__gnu_cxx::forced_error &)
    {
      done = false;
      if (!(container_traits::erase_can_throw))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 1403 << std::endl;
          std::cerr << container_traits::erase_can_throw << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
    }
  if (m_g.get_prob () < m_mp)
    cmp (*m_p_c, m_native_c, __FUNCTION__);
  ;
  dest_print___.cancel_print ();
  return done;
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::defs ()
{
  typedef typename Cntnr::size_type test_size_type;
  typedef typename Cntnr::difference_type difference_type;
  key_defs ();
  mapped_defs ();
  value_defs ();
  iterator_defs ();
  node_iterator_defs (
      __gnu_pbds::detail::
          integral_constant<int, container_traits::order_preserving> ());
  policy_defs ();
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::key_defs ()
{
  typedef typename Cntnr::key_type test_key_type;
  typedef typename Cntnr::key_reference test_key_reference;
  typedef typename Cntnr::key_const_reference test_key_const_reference;
  typedef typename Cntnr::key_pointer test_key_pointer;
  typedef typename Cntnr::key_const_pointer test_key_const_pointer;
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::mapped_defs ()
{
  typedef typename Cntnr::mapped_type test_mapped_type;
  typedef typename Cntnr::mapped_reference test_mapped_reference;
  typedef typename Cntnr::mapped_const_reference test_mapped_const_reference;
  typedef typename Cntnr::mapped_pointer test_mapped_pointer;
  typedef typename Cntnr::mapped_const_pointer test_mapped_const_pointer;
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::value_defs ()
{
  typedef typename Cntnr::value_type test_value_type;
  typedef typename Cntnr::reference test_reference;
  typedef typename Cntnr::const_reference test_const_reference;
  typedef typename Cntnr::pointer test_pointer;
  typedef typename Cntnr::const_pointer test_const_pointer;
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::iterator_defs ()
{
  typedef typename Cntnr::point_iterator test_point_iterator;
  typedef typename Cntnr::point_const_iterator const_test_point_iterator;
  typedef typename Cntnr::iterator test_iterator;
  typedef typename Cntnr::const_iterator const_test_iterator;
}
template <typename Cntnr>
void container_rand_regression_test<Cntnr>::node_iterator_defs (
    __gnu_pbds::detail::false_type)
{
}
template <typename Cntnr>
void container_rand_regression_test<Cntnr>::node_iterator_defs (
    __gnu_pbds::detail::true_type)
{
  typedef typename Cntnr::node_iterator test_node_iterator;
  typedef typename Cntnr::node_const_iterator test_node_const_iterator;
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::policy_defs ()
{
  typedef typename Cntnr::allocator_type test_allocator;
  policy_defs (typename Cntnr::container_category ());
}
template <typename Cntnr>
void container_rand_regression_test<Cntnr>::policy_defs (__gnu_pbds::tree_tag)
{
  typedef typename Cntnr::cmp_fn test_cmp_fn;
  typedef typename Cntnr::node_update test_node_update;
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::policy_access ()
{
  policy_access (typename Cntnr::container_category ());
}
template <typename Cntnr>
void
    container_rand_regression_test<Cntnr>::policy_access (__gnu_pbds::tree_tag)
{
  {
    typename Cntnr::cmp_fn &r_t = m_p_c->get_cmp_fn ();
    ((&r_t)
         ? static_cast<void> (0)
         : __assert_fail ("&r_t", "/home/marxin/Programming/gcc/libstdc++-v3/"
                                  "testsuite/util/regression/rand/assoc/"
                                  "container_rand_regression_test.tcc",
                          1678, __PRETTY_FUNCTION__));
  }
  {
    const typename Cntnr::cmp_fn &r_t = ((const Cntnr &)*m_p_c).get_cmp_fn ();
    ((&r_t)
         ? static_cast<void> (0)
         : __assert_fail ("&r_t", "/home/marxin/Programming/gcc/libstdc++-v3/"
                                  "testsuite/util/regression/rand/assoc/"
                                  "container_rand_regression_test.tcc",
                          1683, __PRETTY_FUNCTION__));
  }
}
template <typename Cntnr>
bool
container_rand_regression_test<Cntnr>::split_join ()
{
  enum
  {
    split_join = container_traits::order_preserving
  };
  typedef __gnu_pbds::detail::integral_constant<int, split_join> __true_type;
  return split_join_imp (__true_type ());
}
template <typename Cntnr>
bool container_rand_regression_test<Cntnr>::split_join_imp (
    __gnu_pbds::detail::true_type)
{
  ;
  bool done = true;
  destructor_printer dest_print___ (__FUNCTION__);
  try
    {
      m_alloc.set_probability (0);
      Cntnr lhs (*m_p_c);
      Cntnr rhs;
      native_type native_lhs (m_native_c);
      native_type native_rhs;
      const key_type k = test_traits::generate_key (m_g, m_m);
      m_alloc.set_probability (m_tp);
      lhs.split (k, rhs);
      typename native_type::const_iterator it
          = native_lhs.upper_bound (test_traits::native_key (k));
      while (!native_lhs.empty () && it != native_lhs.end ())
        {
          native_rhs.insert (*it);
          typename native_type::const_iterator next_it = it;
          ++next_it;
          native_lhs.erase (test_traits::extract_native_key (*it));
          it = next_it;
        }
      if (m_g.get_prob () < m_mp)
        cmp (lhs, native_lhs, __FUNCTION__);
      ;
      if (m_g.get_prob () < m_mp)
        cmp (rhs, native_rhs, __FUNCTION__);
      ;
      m_alloc.set_probability (m_tp);
      if (m_g.get_prob () < 0.5)
        lhs.swap (rhs);
      lhs.join (rhs);
      if (!(rhs.size () == 0))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 1768 << std::endl;
          std::cerr << rhs.size () << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
      if (!(rhs.empty ()))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 1769 << std::endl;
          std::cerr << rhs.size () << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
      m_p_c->swap (lhs);
    }
  catch (__gnu_cxx::forced_error &)
    {
      done = false;
      if (!(container_traits::split_join_can_throw))
        {
          std::cerr << "Failure at "
                    << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                       "util/regression/rand/assoc/"
                       "container_rand_regression_test.tcc"
                    << ": " << 1775 << std::endl;
          std::cerr << container_traits::split_join_can_throw << std::endl;
          std::cerr << "container:" << std::endl;
          print_container (*(m_p_c));
          std::cerr << std::endl;
          std::cerr << "native container:" << std::endl;
          print_container (*(&m_native_c));
          std::cerr << std::endl;
          throw std::logic_error ("fucked!");
        };
    }
  if (m_g.get_prob () < m_mp)
    cmp (*m_p_c, m_native_c, __FUNCTION__);
  ;
  dest_print___.cancel_print ();
  return done;
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::it_copy ()
{
  {
    typename cntnr::iterator it = m_p_c->end ();
    typename cntnr::const_iterator const_it (it);
    if (!(const_it == it))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1794 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    if (!(!(const_it != it)))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1795 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    typename cntnr::point_const_iterator const_find_it (it);
    if (!(const_find_it == it))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1798 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    if (!(!(const_find_it != it)))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1799 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    typename cntnr::point_iterator find_it (it);
    if (!(find_it == it))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1802 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    if (!(!(find_it != it)))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1803 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
  }
  {
    typename cntnr::const_iterator const_it = m_p_c->end ();
    typename cntnr::point_const_iterator const_find_it (const_it);
    if (!(const_find_it == const_it))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1809 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    if (!(!(const_find_it != const_it)))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1810 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
  }
  {
    typename cntnr::point_iterator find_it = m_p_c->end ();
    typename cntnr::point_const_iterator const_find_it (find_it);
    if (!(find_it == const_find_it))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1816 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    if (!(!(find_it != const_find_it)))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1817 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
  }
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::it_assign ()
{
  {
    typename cntnr::iterator it = m_p_c->end ();
    typename cntnr::const_iterator const_it;
    const_it = it;
    if (!(const_it == it))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1830 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    if (!(!(const_it != it)))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1831 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    typename cntnr::point_const_iterator const_find_it;
    const_find_it = it;
    if (!(const_find_it == it))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1835 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    if (!(!(const_find_it != it)))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1836 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    typename cntnr::point_iterator find_it;
    find_it = it;
    if (!(find_it == it))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1840 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    if (!(!(find_it != it)))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1841 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
  }
  {
    typename cntnr::const_iterator const_it = m_p_c->end ();
    typename cntnr::point_const_iterator const_find_it;
    const_find_it = const_it;
    if (!(const_find_it == const_it))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1848 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    if (!(!(const_find_it != const_it)))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1849 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
  }
  {
    typename cntnr::point_iterator find_it = m_p_c->end ();
    typename cntnr::point_const_iterator const_find_it;
    const_find_it = find_it;
    if (!(find_it == const_find_it))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1856 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    if (!(!(find_it != const_find_it)))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1857 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
  }
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::rev_it_copy ()
{
  enum
  {
    reverse_iteration = container_traits::reverse_iteration
  };
  rev_it_copy_imp (
      __gnu_pbds::detail::integral_constant<int, reverse_iteration> ());
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::rev_it_assign ()
{
  enum
  {
    reverse_iteration = container_traits::reverse_iteration
  };
  rev_it_assign_imp (
      __gnu_pbds::detail::integral_constant<int, reverse_iteration> ());
}
template <typename Cntnr>
void container_rand_regression_test<Cntnr>::rev_it_copy_imp (
    __gnu_pbds::detail::false_type)
{
}
template <typename Cntnr>
void container_rand_regression_test<Cntnr>::rev_it_copy_imp (
    __gnu_pbds::detail::true_type)
{
  {
    typename cntnr::iterator it = m_p_c->end ();
    typename cntnr::const_reverse_iterator const_it (it);
    if (!(const_it == it))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1901 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    if (!(!(const_it != it)))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1902 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    typename cntnr::point_const_iterator const_find_it (it);
    if (!(const_find_it == it))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1905 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    if (!(!(const_find_it != it)))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1906 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    typename cntnr::point_iterator find_it (it);
    if (!(find_it == it))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1909 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    if (!(!(find_it != it)))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1910 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
  }
}
template <typename Cntnr>
void container_rand_regression_test<Cntnr>::rev_it_assign_imp (
    __gnu_pbds::detail::false_type)
{
}
template <typename Cntnr>
void container_rand_regression_test<Cntnr>::rev_it_assign_imp (
    __gnu_pbds::detail::true_type)
{
  {
    typename cntnr::iterator it = m_p_c->end ();
    typename cntnr::const_reverse_iterator const_it;
    const_it = it;
    if (!(const_it == it))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1929 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    if (!(!(const_it != it)))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1930 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    typename cntnr::point_const_iterator const_find_it;
    const_find_it = it;
    if (!(const_find_it == it))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1934 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    if (!(!(const_find_it != it)))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1935 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    typename cntnr::point_iterator find_it;
    find_it = it;
    if (!(find_it == it))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1939 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
    if (!(!(find_it != it)))
      {
        std::cerr << "Failure at "
                  << "/home/marxin/Programming/gcc/libstdc++-v3/testsuite/"
                     "util/regression/rand/assoc/"
                     "container_rand_regression_test.tcc"
                  << ": " << 1940 << std::endl;
        std::cerr << "" << std::endl;
        std::cerr << "container:" << std::endl;
        print_container (*(m_p_c));
        std::cerr << std::endl;
        std::cerr << "native container:" << std::endl;
        print_container (*(&m_native_c));
        std::cerr << std::endl;
        throw std::logic_error ("fucked!");
      };
  }
}
template <typename Cntnr>
bool
container_rand_regression_test<Cntnr>::resize ()
{
  typedef __gnu_pbds::detail::integral_constant<int, test_traits::resize>
      resize_ind;
  return resize_imp (resize_ind ());
}
template <typename Cntnr>
bool container_rand_regression_test<Cntnr>::resize_imp (
    __gnu_pbds::detail::false_type)
{
  return true;
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::get_set_load ()
{
  typedef __gnu_pbds::detail::integral_constant<int, test_traits::get_set_load>
      get_set_load_ind;
  get_set_load_imp (get_set_load_ind ());
}
template <typename Cntnr>
void container_rand_regression_test<Cntnr>::get_set_load_imp (
    __gnu_pbds::detail::false_type)
{
}
template <typename Cntnr>
bool
container_rand_regression_test<Cntnr>::get_set_loads ()
{
  typedef __gnu_pbds::detail::integral_constant<int,
                                                test_traits::get_set_loads>
      get_set_loads_ind;
  return get_set_loads_imp (get_set_loads_ind ());
}
template <typename Cntnr>
bool container_rand_regression_test<Cntnr>::get_set_loads_imp (
    __gnu_pbds::detail::false_type)
{
  return true;
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::print_container (
    const native_type &r_cnt, std::ostream &r_os) const
{
  m_alloc.set_probability (0);
  typename native_type::const_iterator it = r_cnt.begin ();
  while (it != r_cnt.end ())
    {
      r_os << test_traits::val_to_string (*it) + "\n";
      ++it;
    }
}
template <typename Cntnr>
void
container_rand_regression_test<Cntnr>::print_container (
    const cntnr &r_cnt, std::ostream &r_os) const
{
  m_alloc.set_probability (0);
  typename cntnr::const_iterator it = r_cnt.begin ();
  while (it != r_cnt.end ())
    {
      r_os << test_traits::val_to_string (*it) + "\n";
      ++it;
    }
}
}
}
namespace test
{
class illegal_input_error : public std::exception
{
};
void verify_prob (double prob);
;
;
;
;
}
namespace test
{
template <typename Key, typename Data,
          class Hash_Fn =
              typename __gnu_pbds::detail::default_hash_fn<Key>::type,
          class Eq_Fn = std::equal_to<Key>,
          typename _Alloc = std::allocator<std::pair<const Key, Data> > >
struct hash_common_types
{
private:
  typedef typename _Alloc::size_type size_type;
  typedef __gnu_pbds::test::hash_load_check_resize_trigger_t_<_Alloc, 1, 8, 1,
                                                              2, false>
      no_access_half_load_check_resize_trigger_policy;
  typedef __gnu_pbds::test::hash_load_check_resize_trigger_t_<_Alloc, 1, 8, 1,
                                                              2, true>
      access_half_load_check_resize_trigger_policy;
  typedef __gnu_pbds::test::hash_load_check_resize_trigger_t_<_Alloc, 1, 8, 1,
                                                              1, false>
      no_access_one_load_check_resize_trigger_policy;
  typedef __gnu_pbds::test::
      cc_hash_max_collision_check_resize_trigger_t_<_Alloc, 1, 2, false>
          no_access_half_max_col_check_check_resize_trigger_policy;
  typedef __gnu_pbds::test::
      cc_hash_max_collision_check_resize_trigger_t_<_Alloc, 1, 2, true>
          access_half_max_col_check_check_resize_trigger_policy;
  typedef __gnu_pbds::test::linear_probe_fn_t_<Key, _Alloc> lin_p_t;
  typedef __gnu_pbds::test::quadratic_probe_fn_t_<Key, _Alloc> quad_p_t;
  typedef typename __gnu_cxx::typelist::
      create4<__gnu_pbds::detail::false_type,
              __gnu_pbds::test::direct_mask_range_hashing_t_<_Alloc>,
              no_access_half_load_check_resize_trigger_policy,
              __gnu_pbds::test::hash_exponential_size_policy_t_<_Alloc> >::type
          performance_cc_policy0;
  typedef typename __gnu_cxx::typelist::
      create4<__gnu_pbds::detail::false_type,
              __gnu_pbds::test::direct_mod_range_hashing_t_<_Alloc>,
              no_access_half_load_check_resize_trigger_policy,
              __gnu_pbds::test::hash_prime_size_policy_t_>::type
          performance_cc_policy1;
  typedef typename __gnu_cxx::typelist::
      create4<__gnu_pbds::detail::false_type,
              __gnu_pbds::test::direct_mask_range_hashing_t_<_Alloc>,
              no_access_one_load_check_resize_trigger_policy,
              __gnu_pbds::test::hash_exponential_size_policy_t_<_Alloc> >::type
          performance_cc_policy2;
  typedef typename __gnu_cxx::typelist::
      create4<__gnu_pbds::detail::false_type,
              __gnu_pbds::test::direct_mod_range_hashing_t_<_Alloc>,
              no_access_one_load_check_resize_trigger_policy,
              __gnu_pbds::test::hash_prime_size_policy_t_>::type
          performance_cc_policy3;
  typedef typename __gnu_cxx::typelist::
      create4<__gnu_pbds::detail::true_type,
              __gnu_pbds::test::direct_mask_range_hashing_t_<_Alloc>,
              no_access_half_load_check_resize_trigger_policy,
              __gnu_pbds::test::hash_exponential_size_policy_t_<_Alloc> >::type
          performance_cc_policy4;
  typedef typename __gnu_cxx::typelist::
      create4<__gnu_pbds::detail::false_type,
              __gnu_pbds::test::direct_mask_range_hashing_t_<_Alloc>,
              no_access_half_max_col_check_check_resize_trigger_policy,
              __gnu_pbds::test::hash_exponential_size_policy_t_<_Alloc> >::type
          performance_cc_policy5;
  typedef typename __gnu_cxx::typelist::
      create4<__gnu_pbds::detail::false_type,
              __gnu_pbds::test::direct_mask_range_hashing_t_<_Alloc>,
              access_half_max_col_check_check_resize_trigger_policy,
              __gnu_pbds::test::hash_exponential_size_policy_t_<_Alloc> >::type
          regression_cc_policy0;
  typedef typename __gnu_cxx::typelist::
      create4<__gnu_pbds::detail::false_type,
              __gnu_pbds::test::direct_mask_range_hashing_t_<_Alloc>,
              access_half_load_check_resize_trigger_policy,
              __gnu_pbds::test::hash_exponential_size_policy_t_<_Alloc> >::type
          regression_cc_policy1;
  typedef typename __gnu_cxx::typelist::
      create4<__gnu_pbds::detail::true_type,
              __gnu_pbds::test::direct_mod_range_hashing_t_<_Alloc>,
              no_access_half_load_check_resize_trigger_policy,
              __gnu_pbds::test::hash_prime_size_policy_t_>::type
          regression_cc_policy2;
  typedef typename __gnu_cxx::typelist::
      create5<__gnu_pbds::detail::false_type, lin_p_t,
              __gnu_pbds::test::direct_mask_range_hashing_t_<_Alloc>,
              no_access_half_load_check_resize_trigger_policy,
              __gnu_pbds::test::hash_exponential_size_policy_t_<_Alloc> >::type
          performance_gp_policy0;
  typedef typename __gnu_cxx::typelist::
      create5<__gnu_pbds::detail::false_type, quad_p_t,
              __gnu_pbds::test::direct_mod_range_hashing_t_<_Alloc>,
              no_access_half_load_check_resize_trigger_policy,
              __gnu_pbds::test::hash_prime_size_policy_t_>::type
          performance_gp_policy1;
  typedef typename __gnu_cxx::typelist::
      create5<__gnu_pbds::detail::false_type, quad_p_t,
              __gnu_pbds::test::direct_mod_range_hashing_t_<_Alloc>,
              access_half_load_check_resize_trigger_policy,
              __gnu_pbds::test::hash_prime_size_policy_t_>::type
          regression_gp_policy0;
  typedef typename __gnu_cxx::typelist::
      create5<__gnu_pbds::detail::true_type, lin_p_t,
              __gnu_pbds::test::direct_mask_range_hashing_t_<_Alloc>,
              access_half_load_check_resize_trigger_policy,
              __gnu_pbds::test::hash_exponential_size_policy_t_<_Alloc> >::type
          regression_gp_policy1;
  typedef typename __gnu_cxx::typelist::
      create6<performance_cc_policy0, performance_cc_policy1,
              performance_cc_policy2, performance_cc_policy3,
              performance_cc_policy4, performance_cc_policy5>::type
          performance_cc_range_hashing_policies;
  typedef typename __gnu_cxx::typelist::create3<regression_cc_policy0,
                                                regression_cc_policy1,
                                                regression_cc_policy2>::type
      regression_cc_range_hashing_policies;
  typedef typename __gnu_cxx::typelist::create2<performance_gp_policy0,
                                                performance_gp_policy1>::type
      performance_gp_range_hashing_policies;
  typedef typename __gnu_cxx::typelist::create2<regression_gp_policy0,
                                                regression_gp_policy1>::type
      regression_gp_range_hashing_policies;
  template <typename Policy_Tl> struct no_access_generic_cc_hash_table_t
  {
  private:
    typedef typename __gnu_cxx::typelist::at_index<Policy_Tl, 0>::type
        store_hash_indicator;
    enum
    {
      store_hash = store_hash_indicator::value
    };
    typedef typename __gnu_cxx::typelist::at_index<Policy_Tl, 1>::type
        comb_hash_fn;
    typedef typename __gnu_cxx::typelist::at_index<Policy_Tl, 2>::type
        trigger_policy;
    typedef
        typename __gnu_cxx::typelist::at_index<Policy_Tl, 3>::type size_policy;
  public:
    typedef __gnu_pbds::
        cc_hash_table<Key, Data, Hash_Fn, Eq_Fn, comb_hash_fn,
                      __gnu_pbds::hash_standard_resize_policy<size_policy,
                                                              trigger_policy,
                                                              false>,
                      store_hash, _Alloc> type;
  };
  template <typename Policy_Tl> struct access_generic_cc_hash_table_t
  {
  private:
    typedef typename __gnu_cxx::typelist::at_index<Policy_Tl, 0>::type
        store_hash_indicator;
    enum
    {
      store_hash = store_hash_indicator::value
    };
    typedef typename __gnu_cxx::typelist::at_index<Policy_Tl, 1>::type
        comb_hash_fn;
    typedef typename __gnu_cxx::typelist::at_index<Policy_Tl, 2>::type
        trigger_policy;
    typedef
        typename __gnu_cxx::typelist::at_index<Policy_Tl, 3>::type size_policy;
  public:
    typedef __gnu_pbds::
        cc_hash_table<Key, Data, Hash_Fn, Eq_Fn, comb_hash_fn,
                      __gnu_pbds::hash_standard_resize_policy<size_policy,
                                                              trigger_policy,
                                                              true>,
                      store_hash, _Alloc> type;
  };
  template <typename Policy_Tl> struct no_access_generic_gp_hash_table_t
  {
  private:
    typedef typename __gnu_cxx::typelist::at_index<Policy_Tl, 0>::type
        store_hash_indicator;
    enum
    {
      store_hash = store_hash_indicator::value
    };
    typedef
        typename __gnu_cxx::typelist::at_index<Policy_Tl, 1>::type probe_fn;
    typedef typename __gnu_cxx::typelist::at_index<Policy_Tl, 2>::type
        comb_probe_fn;
    typedef typename __gnu_cxx::typelist::at_index<Policy_Tl, 3>::type
        trigger_policy;
    typedef
        typename __gnu_cxx::typelist::at_index<Policy_Tl, 4>::type size_policy;
  public:
    typedef __gnu_pbds::
        gp_hash_table<Key, Data, Hash_Fn, Eq_Fn, comb_probe_fn, probe_fn,
                      __gnu_pbds::hash_standard_resize_policy<size_policy,
                                                              trigger_policy,
                                                              false>,
                      store_hash, _Alloc> type;
  };
  template <typename Policy_Tl> struct access_generic_gp_hash_table_t
  {
  private:
    typedef typename __gnu_cxx::typelist::at_index<Policy_Tl, 0>::type
        store_hash_indicator;
    enum
    {
      store_hash = store_hash_indicator::value
    };
    typedef
        typename __gnu_cxx::typelist::at_index<Policy_Tl, 1>::type probe_fn;
    typedef typename __gnu_cxx::typelist::at_index<Policy_Tl, 2>::type
        comb_probe_fn;
    typedef typename __gnu_cxx::typelist::at_index<Policy_Tl, 3>::type
        trigger_policy;
    typedef
        typename __gnu_cxx::typelist::at_index<Policy_Tl, 4>::type size_policy;
  public:
    typedef __gnu_pbds::
        gp_hash_table<Key, Data, Hash_Fn, Eq_Fn, comb_probe_fn, probe_fn,
                      __gnu_pbds::hash_standard_resize_policy<size_policy,
                                                              trigger_policy,
                                                              true>,
                      store_hash, _Alloc> type;
  };
  typedef typename __gnu_cxx::typelist::
      transform<performance_cc_range_hashing_policies,
                no_access_generic_cc_hash_table_t>::type performance_cc_types;
  typedef typename __gnu_cxx::typelist::
      transform<regression_cc_range_hashing_policies,
                access_generic_cc_hash_table_t>::type regression_cc_types;
  typedef typename __gnu_cxx::typelist::at_index<performance_cc_types, 0>::type
      performance_min_cc_type;
  typedef typename __gnu_cxx::typelist::
      transform<performance_gp_range_hashing_policies,
                no_access_generic_gp_hash_table_t>::type performance_gp_types;
  typedef typename __gnu_cxx::typelist::
      transform<regression_gp_range_hashing_policies,
                access_generic_gp_hash_table_t>::type regression_gp_types;
  typedef typename __gnu_cxx::typelist::at_index<performance_gp_types, 0>::type
      performance_min_gp_type;
public:
  typedef typename __gnu_cxx::typelist::append<performance_cc_types,
                                               performance_gp_types>::type
      performance_tl;
  typedef typename __gnu_cxx::typelist::append<regression_gp_types,
                                               regression_cc_types>::type
      regression_tl;
  typedef typename __gnu_cxx::typelist::create1<performance_min_cc_type>::type
      performance_min_tl;
};
template <typename Key, typename Data, class Comb_Hash_Fn_TL,
          class Comb_Probe_Fn_TL, class Eq_Fn = std::equal_to<Key>,
          typename _Alloc = std::allocator<std::pair<const Key, Data> > >
struct ranged_hash_common_types
{
private:
  typedef typename _Alloc::size_type size_type;
  typedef __gnu_pbds::test::hash_load_check_resize_trigger_t_<_Alloc, 1, 8, 1,
                                                              2, false>
      no_access_half_load_check_resize_trigger_policy;
  typedef __gnu_pbds::test::hash_load_check_resize_trigger_t_<_Alloc, 1, 8, 1,
                                                              1, false>
      no_access_one_load_check_resize_trigger_policy;
  typedef __gnu_pbds::
      hash_standard_resize_policy<__gnu_pbds::test::
                                      hash_exponential_size_policy_t_<_Alloc>,
                                  no_access_half_load_check_resize_trigger_policy>
          mask_half_resize_policy_t;
  typedef __gnu_pbds::
      hash_standard_resize_policy<__gnu_pbds::test::
                                      hash_exponential_size_policy_t_<_Alloc>,
                                  no_access_one_load_check_resize_trigger_policy>
          mask_one_resize_policy_t;
  typedef __gnu_pbds::
      hash_standard_resize_policy<__gnu_pbds::test::hash_prime_size_policy_t_,
                                  no_access_half_load_check_resize_trigger_policy>
          mod_half_resize_policy_t;
  typedef __gnu_pbds::
      hash_standard_resize_policy<__gnu_pbds::test::hash_prime_size_policy_t_,
                                  no_access_one_load_check_resize_trigger_policy>
          mod_one_resize_policy_t;
  template <typename Comb_Hash_Fn_> struct half_resize_policy_selector;
  template <typename _Alloc_>
  struct
      half_resize_policy_selector<__gnu_pbds::test::
                                      direct_mask_range_hashing_t_<_Alloc_> >
  {
    typedef mask_half_resize_policy_t type;
  };
  template <typename _Alloc_>
  struct half_resize_policy_selector<__gnu_pbds::test::
                                         direct_mod_range_hashing_t_<_Alloc_> >
  {
    typedef mod_half_resize_policy_t type;
  };
  template <typename Comb_Hash_Fn_> struct one_resize_policy_selector;
  template <typename _Alloc_>
  struct one_resize_policy_selector<__gnu_pbds::test::
                                        direct_mask_range_hashing_t_<_Alloc_> >
  {
    typedef mask_one_resize_policy_t type;
  };
  template <typename _Alloc_>
  struct one_resize_policy_selector<__gnu_pbds::test::
                                        direct_mod_range_hashing_t_<_Alloc_> >
  {
    typedef mod_one_resize_policy_t type;
  };
  template <typename Comb_Hash_Fn> struct generic_cc_hash_table_t
  {
    typedef __gnu_pbds::
        cc_hash_table<Key, Data, __gnu_pbds::null_type, Eq_Fn, Comb_Hash_Fn,
                      typename one_resize_policy_selector<
                          typename Comb_Hash_Fn::comb_fn>::type,
                      false, _Alloc> type;
  };
  typedef
      typename __gnu_cxx::typelist::transform<Comb_Hash_Fn_TL,
                                              generic_cc_hash_table_t>::type
          performance_cc_types;
  template <typename Comb_Probe_Fn> struct no_access_generic_gp_hash_table_t
  {
    typedef __gnu_pbds::
        gp_hash_table<Key, Data, __gnu_pbds::null_type, Eq_Fn, Comb_Probe_Fn,
                      __gnu_pbds::null_type,
                      typename half_resize_policy_selector<
                          typename Comb_Probe_Fn::comb_fn>::type,
                      false, _Alloc> type;
  };
  typedef typename __gnu_cxx::typelist::
      transform<Comb_Probe_Fn_TL, no_access_generic_gp_hash_table_t>::type
          performance_gp_types;
public:
  typedef typename __gnu_cxx::typelist::append<performance_cc_types,
                                               performance_gp_types>::type
      performance_tl;
};
template <typename Key, typename Data, class Eq_Fn = std::equal_to<Key>,
          typename _Alloc = std::allocator<char> >
class lu_common_types
{
private:
  typedef typename _Alloc::size_type size_type;
  typedef __gnu_pbds::test::lu_move_to_front_policy_t_ mtf_u;
  typedef __gnu_pbds::test::lu_counter_policy_t_<_Alloc, 5> cnt_5_u;
  typedef typename __gnu_cxx::typelist::create1<mtf_u>::type lu_policy0;
  typedef typename __gnu_cxx::typelist::create1<cnt_5_u>::type lu_policy1;
  typedef typename __gnu_cxx::typelist::create2<lu_policy0, lu_policy1>::type
      lu_policies;
  template <typename Policy_Tl> struct generic_list_update_t
  {
  private:
    typedef typename __gnu_cxx::typelist::at_index<Policy_Tl, 0>::type
        update_policy_t;
  public:
    typedef __gnu_pbds::list_update<Key, Data, Eq_Fn, update_policy_t, _Alloc>
        type;
  };
  typedef typename __gnu_cxx::typelist::transform<lu_policies,
                                                  generic_list_update_t>::type
      lu_types;
  typedef
      typename __gnu_cxx::typelist::at_index<lu_types, 0>::type min_lu_type;
public:
  typedef lu_types performance_tl;
  typedef lu_types regression_tl;
  typedef typename __gnu_cxx::typelist::create1<min_lu_type>::type
      performance_min_tl;
};
template <typename Key, typename Data, class Cmp_Fn = std::less<Key>,
          template <typename Node_CItr, class Node_Itr, class Cmp_Fn_,
                    typename _Alloc_> class Node_Update
          = __gnu_pbds::null_node_update,
          typename _Alloc = std::allocator<std::pair<const Key, Data> > >
struct tree_common_types
{
private:
  typedef __gnu_pbds::tree<Key, Data, Cmp_Fn, __gnu_pbds::ov_tree_tag,
                           Node_Update, _Alloc> ov_tree_assoc_container_t;
  typedef __gnu_pbds::tree<Key, Data, Cmp_Fn, __gnu_pbds::rb_tree_tag,
                           Node_Update, _Alloc> rb_tree_assoc_container_t;
  typedef __gnu_pbds::tree<Key, Data, Cmp_Fn, __gnu_pbds::splay_tree_tag,
                           Node_Update, _Alloc> splay_tree_assoc_container_t;
public:
  typedef
      typename __gnu_cxx::typelist::create3<splay_tree_assoc_container_t,
                                            rb_tree_assoc_container_t,
                                            ov_tree_assoc_container_t>::type
          performance_tl;
  typedef
      typename __gnu_cxx::typelist::create3<ov_tree_assoc_container_t,
                                            splay_tree_assoc_container_t,
                                            rb_tree_assoc_container_t>::type
          regression_tl;
  typedef
      typename __gnu_cxx::typelist::create1<rb_tree_assoc_container_t>::type
          performance_min_tl;
};
template <typename Key, typename Data,
          class _ATraits
          = typename __gnu_pbds::detail::default_trie_access_traits<Key>::type,
          class Tag = __gnu_pbds::pat_trie_tag,
          template <typename Node_CItr, typename Node_Itr, class _ATraits_,
                    typename _Alloc_> class Node_Update
          = __gnu_pbds::null_node_update,
          typename _Alloc = std::allocator<char> >
class trie_common_types
{
private:
  typedef __gnu_pbds::trie<Key, Data, _ATraits, Tag, Node_Update, _Alloc> type;
public:
  typedef typename __gnu_cxx::typelist::create1<type>::type performance_tl;
  typedef typename __gnu_cxx::typelist::create1<type>::type regression_tl;
  typedef typename __gnu_cxx::typelist::create1<type>::type performance_min_tl;
};
}
template <typename _Tv, typename Cmp_Fn = std::less<_Tv>,
          typename Tag = pairing_heap_tag,
          typename _Alloc = std::allocator<char> >
class priority_queue
    : public detail::container_base_dispatch<_Tv, Cmp_Fn, _Alloc, Tag>::type
{
};
namespace test
{
template <typename Value_Type, typename Cmp_Fn = std::less<Value_Type>,
          typename _Alloc = std::allocator<Value_Type> >
struct pq_common_types
{
private:
  typedef __gnu_pbds::priority_queue<Value_Type, Cmp_Fn,
                                     __gnu_pbds::pairing_heap_tag,
                                     _Alloc> pairing_heap_t;
  typedef __gnu_pbds::priority_queue<Value_Type, Cmp_Fn,
                                     __gnu_pbds::binomial_heap_tag,
                                     _Alloc> binomial_heap_t;
  typedef __gnu_pbds::priority_queue<Value_Type, Cmp_Fn,
                                     __gnu_pbds::rc_binomial_heap_tag,
                                     _Alloc> rc_binomial_heap_t;
  typedef __gnu_pbds::priority_queue<Value_Type, Cmp_Fn,
                                     __gnu_pbds::binary_heap_tag,
                                     _Alloc> binary_heap_t;
  typedef __gnu_pbds::priority_queue<Value_Type, Cmp_Fn,
                                     __gnu_pbds::thin_heap_tag,
                                     _Alloc> thin_heap_t;
  typedef typename __gnu_cxx::typelist::create5<thin_heap_t, pairing_heap_t,
                                                binomial_heap_t,
                                                rc_binomial_heap_t,
                                                binary_heap_t>::type all_tl;
public:
  typedef all_tl performance_tl;
  typedef all_tl regression_tl;
  typedef all_tl performance_min_tl;
  typedef all_tl regression_min_tl;
};
}
namespace test
{
typedef __gnu_cxx::throw_allocator_random<basic_type> alloc_type;
struct hash
{
  typedef alloc_type::rebind<basic_type>::other basic_type_rebind;
  typedef basic_type_rebind::const_reference const_reference;
  typedef basic_type::const_iterator const_iterator;
  ;
};
typedef __gnu_pbds::trie_string_access_traits<basic_type, 'a',
                                              'a' + basic_type::distinct_chars
                                              - 1,
                                              false,
                                              alloc_type> access_traits_t;
template <typename Data_Type> struct tree_types
{
private:
  typedef
      typename tree_common_types<basic_type, Data_Type, std::less<basic_type>,
                                 __gnu_pbds::null_node_update,
                                 alloc_type>::regression_tl
          no_order_statistics_tl_t;
  typedef
      typename tree_common_types<basic_type, Data_Type, std::less<basic_type>,
                                 __gnu_pbds::tree_order_statistics_node_update,
                                 alloc_type>::regression_tl
          order_statistics_tl_t;
public:
  typedef
      typename __gnu_cxx::typelist::append<no_order_statistics_tl_t,
                                           order_statistics_tl_t>::type tl_t;
  typedef no_order_statistics_tl_t min_tl_t;
};
template <typename Data_Type> struct trie_types
{
private:
  typedef
      typename trie_common_types<basic_type, Data_Type, access_traits_t,
                                 __gnu_pbds::pat_trie_tag,
                                 __gnu_pbds::null_node_update,
                                 alloc_type>::regression_tl no_updates_tl_t;
  typedef
      typename trie_common_types<basic_type, Data_Type, access_traits_t,
                                 __gnu_pbds::pat_trie_tag,
                                 __gnu_pbds::trie_order_statistics_node_update,
                                 alloc_type>::regression_tl
          order_statistics_tl_t;
  typedef
      typename trie_common_types<basic_type, Data_Type, access_traits_t,
                                 __gnu_pbds::pat_trie_tag,
                                 __gnu_pbds::trie_prefix_search_node_update,
                                 alloc_type>::regression_tl prefix_search_tl_t;
public:
  typedef typename __gnu_cxx::typelist::
      append<no_updates_tl_t,
             typename __gnu_cxx::typelist::
                 append<prefix_search_tl_t, order_statistics_tl_t>::type>::type
          tl_t;
  typedef no_updates_tl_t min_tl_t;
};
template <typename Data_Type> struct hash_types
{
  typedef typename hash_common_types<basic_type, Data_Type, hash,
                                     std::equal_to<basic_type>,
                                     alloc_type>::regression_tl tl_t;
  typedef tl_t min_tl_t;
};
template <typename Data_Type> struct lu_types
{
  typedef typename lu_common_types<basic_type, Data_Type,
                                   std::equal_to<basic_type>,
                                   alloc_type>::regression_tl tl_t;
  typedef tl_t min_tl_t;
};
typedef pq_common_types<basic_type, std::less<basic_type>, alloc_type>
    pq_types;
typedef tree_types<basic_type>::tl_t tree_map_tl_t;
namespace detail
{
struct rand_reg_test
{
public:
  rand_reg_test (size_t seed, size_t n, size_t m, double tp, double ip,
                 double ep, double cp, double mp, bool d)
      : m_sd (seed), m_n (n), m_m (m), m_tp (tp), m_ip (ip), m_ep (ep),
        m_cp (cp), m_mp (mp), m_disp (d)
  {
    if (m_disp)
      xml_test_rand_regression_formatter (seed, n, m, tp, ip, ep, cp, mp);
  }
  template <typename Cntnr> void operator()(Cntnr)
  {
    unsigned long ul = static_cast<unsigned long> (m_sd);
    container_rand_regression_test<Cntnr> t (ul, m_n, m_n, m_tp, m_ip, m_ep,
                                             m_cp, m_mp, m_disp);
    t ();
  }
private:
  const size_t m_sd;
  const size_t m_n;
  const size_t m_m;
  const double m_tp;
  const double m_ip;
  const double m_ep;
  const double m_cp;
  const double m_mp;
  const bool m_disp;
};
void usage (const std::string &r_name);
void verify_params (size_t &, size_t &, size_t &, double &, double &, double &,
                    double &, double &, bool &);
}
template <typename TL>
int
rand_regression_test (size_t iter, size_t keys, const std::string name, TL tl)
{
  size_t n = iter;
  size_t m = keys;
  size_t sd = 1234567;
  double tp = 0.2;
  double ip = 0.6;
  double ep = 0.2;
  double cp = 0.001;
  double mp = 0.25;
  bool disp = true;
  try
    {
      detail::verify_params (sd, n, m, tp, ip, ep, cp, mp, disp);
    }
  catch (__gnu_pbds::test::illegal_input_error &)
    {
      detail::usage (name);
      return -1;
    }
  catch (...)
    {
      return -2;
    };
  try
    {
      detail::rand_reg_test tst (sd, n, m, tp, ip, ep, cp, mp, disp);
      __gnu_cxx::typelist::apply (tst, tl);
    }
  catch (...)
    {
      std::cerr << "Test failed with seed " << sd << std::endl;
      throw;
    }
  return 0;
}
namespace detail
{
inline void
usage (const std::string &name)
{
  using namespace std;
  cerr << "usage: " << name
       << " <sd> <n> <m> <tp> <ip> <ep> <cp> <mp> ['t' | 'f']" << endl << endl;
  cerr << "This test performs basic regression tests on various associative "
          "containers."
          "For each container, it performs a sequence of operations. At each "
          "iteration, it does "
          "the following: " << endl;
  cerr << "*  Performs an operation on the container " << endl;
  cerr << "*  Performs the same operation on an cntnr object" << endl;
  cerr << "*  Possibly compares the container to the cntnr object" << endl;
  cerr << "*  Checks that exceptions (thrown by an allocator) "
          "do not violate exception guarantees";
  cerr << endl << endl;
  cerr << "sd = seed for random-number generator; "
          "0 = time determined value" << endl;
  cerr << "n = number of iterations" << endl;
  cerr << "m = number of distinct values" << endl;
  cerr << "tp = probability that an exception will be actively thrown" << endl;
  cerr << "ip = probability that an operation will be insert" << endl;
  cerr << "ep = probability that an operation will be erase" << endl;
  cerr << "cp = probability that an operation will be clear" << endl;
  cerr
      << "(therefore, 1 - (ip + ep + cp) = probability of any other operation)"
      << endl;
  cerr << "mp = probability that the container will be compared to the cntnr "
          "object" << endl;
  cerr << "'t' or 'f' determine whether progress will be displayed" << endl;
}
inline void
verify_params (size_t &r_seed, size_t &r_n, size_t &r_m, double &r_tp,
               double &r_ip, double &r_ep, double &r_cp, double &r_mp,
               bool &r_d)
{
}
}
}
}
int
main (int argc, char *a_p_argv[])
{
  using namespace __gnu_pbds::test;
  typedef tree_map_tl_t map_tl_t;
  return rand_regression_test (
      5000, 10000, "tree_data_map_rand_regression_test", map_tl_t ());
}
